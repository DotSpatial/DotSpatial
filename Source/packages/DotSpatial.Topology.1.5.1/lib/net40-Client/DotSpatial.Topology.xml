<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotSpatial.Topology</name>
    </assembly>
    <members>
        <member name="T:DotSpatial.Topology.DimensionType">
            <summary>
            Constants representing the dimensions of a point, a curve and a surface.
            Also, constants representing the dimensions of the empty point and
            non-empty geometries, and a wildcard dimension meaning "any dimension".
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.DimensionType.Point">
            <summary>
            Dimension value of a point (0).
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.DimensionType.Curve">
            <summary>
            Dimension value of a curve (1).
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.DimensionType.Surface">
            <summary>
            Dimension value of a surface (2).
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.DimensionType.False">
            <summary>
            Dimension value of a empty point (-1).
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.DimensionType.True">
            <summary>
            Dimension value of non-empty geometries (= {Point, Curve, A}).
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.DimensionType.Dontcare">
            <summary>
            Dimension value for any dimension (= {False, True}).
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.FeatureType">
            <summary>
            An abreviated list for quick classification
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.FeatureType.Unspecified">
            <summary>
            None specified or custom
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.FeatureType.Point">
            <summary>
            Point
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.FeatureType.Line">
            <summary>
            Line
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.FeatureType.Polygon">
            <summary>
            Polygon
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.FeatureType.MultiPoint">
            <summary>
            MultiPoint
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Angle">
            <summary>
            A geometric angle mesured in degrees or radians
            the angle will wrap around, so setting larger values will
            result in an appropriate angle.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Angle.PI">
            <summary>
            The value of 3.14159 or whatever from Math.PI
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Angle.#ctor(System.Double)">
            <summary>
            Creates a new instance of an angle with the radians specified
            </summary>
            <param name="radians">The angle in radians</param>
        </member>
        <member name="M:DotSpatial.Topology.Angle.Copy">
            <summary>
            Returns a new instance of the Angle class with the same angle as this object.
            </summary>
            <returns>Angle which has the same values</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.Equals(System.Object)">
            <summary>
            False for anything that is not an angle.
            Tests two angles to see if they have the same value.
            </summary>
            <param name="obj">An object to test.</param>
            <returns>Boolean, true if the angles have the same value.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.GetHashCode">
            <summary>
            Gets a hash code
            </summary>
            <returns>Int hash code</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.op_Explicit(System.Double)~DotSpatial.Topology.Angle">
            <summary>
            Returns a new angle object with an angle of Value in radians
            </summary>
            <param name="value">The double value indicating the angle</param>
            <returns>An Angle structure with the specified value</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.op_Explicit(DotSpatial.Topology.Angle)~System.Double">
            <summary>
            Returns a double specifying the radian value of the angle
            </summary>
            <param name="value">The angle structure to determine the angle of</param>
            <returns>A Double with the angle in radians</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.op_Equality(DotSpatial.Topology.Angle,DotSpatial.Topology.Angle)">
            <summary>
            Returns true if the two angles are equal to each other.
            </summary>
            <param name="a">An angle to compare</param>
            <param name="b">A second angle.</param>
            <returns>Boolean, true if they are equal.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.op_Inequality(DotSpatial.Topology.Angle,DotSpatial.Topology.Angle)">
            <summary>
            Returns true if the two angles are equal to each other.
            </summary>
            <param name="a">An angle to compare</param>
            <param name="b">A second angle.</param>
            <returns>Boolean, true if they are equal.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.op_Addition(DotSpatial.Topology.Angle,DotSpatial.Topology.Angle)">
            <summary>
            Returns the sum of the two angles, cycling if greater than 2 pi.
            </summary>
            <param name="a">An angle to add</param>
            <param name="b">A second angle to add</param>
            <returns>A new Angle structure equal to the sum of the two angles</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.op_Subtraction(DotSpatial.Topology.Angle,DotSpatial.Topology.Angle)">
            <summary>
            Returns the difference of two angles.
            </summary>
            <param name="a">An angle to subtract from</param>
            <param name="b">The angle to subtract</param>
            <returns>A new angle structure with a sum equal to the two angles</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.op_Division(DotSpatial.Topology.Angle,DotSpatial.Topology.Angle)">
            <summary>
            Divides angle A by angle B
            </summary>
            <param name="a">An angle to divide</param>
            <param name="b">An angle to divide into A</param>
            <returns>A new angle with the quotient of the division</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.op_Multiply(DotSpatial.Topology.Angle,DotSpatial.Topology.Angle)">
            <summary>
            Multiplies angle A by Angle B.
            </summary>
            <param name="a">An angle to multiply</param>
            <param name="b">A second angle to multiply.</param>
            <returns>A new angle with the product of the two angles.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.Cos(DotSpatial.Topology.Angle)">
            <summary>
            Returns the mathematical Cos of the angle specified
            </summary>
            <param name="value">The Angle to find the cosign of</param>
            <returns>Double, the cosign of the angle specified</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.Sin(DotSpatial.Topology.Angle)">
            <summary>
            Returns the mathematical Sin of the angle specified
            </summary>
            <param name="value">The Angle to find the Sin of</param>
            <returns>Double, the Sin of the Angle</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.Tan(DotSpatial.Topology.Angle)">
            <summary>
            Returns the mathematical Tan of the angle specified
            </summary>
            <param name="value">The Angle to find the Tan of</param>
            <returns>Double, the Tan of the Angle</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.ATan(System.Double)">
            <summary>
            Returns the mathematical ATan of the value specified
            </summary>
            <param name="value">The Double to find the ATan of</param>
            <returns>Angle, the ATan of the Value specified</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.ACos(System.Double)">
            <summary>
            Returns the mathematical ACos of the value specified
            </summary>
            <param name="value">The Double to find the ACos of</param>
            <returns>Angle, the ACos of the Value specified</returns>
        </member>
        <member name="M:DotSpatial.Topology.Angle.ASin(System.Double)">
            <summary>
            Returns the mathematical ASin of the value specified
            </summary>
            <param name="value">The Double to find the ASin of</param>
            <returns>Angle, the ASin of the Value specified</returns>
        </member>
        <member name="P:DotSpatial.Topology.Angle.Degrees">
            <summary>
            Gets or sets the angle in degrees, ranging from -360 to 360
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Angle.DegreesPos">
            <summary>
            Gets or sets the angle in degrees ranging from 0 to 360
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Angle.Radians">
            <summary>
            Only allows values from -2PI to 2PI.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.BufferStyle">
            <summary>
            Buffer styles.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.BufferStyle.CapRound">
            <summary>
            Specifies a round line buffer end cap endCapStyle (Default).
            </summary>/
        </member>
        <member name="F:DotSpatial.Topology.BufferStyle.CapButt">
            <summary>
            Specifies a butt (or flat) line buffer end cap endCapStyle.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.BufferStyle.CapSquare">
            <summary>
            Specifies a square line buffer end cap endCapStyle.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.PrecisionModelType">
            <summary>
            The types of Precision Model which NTS supports.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.PrecisionModelType.Floating">
            <summary>
            Floating precision corresponds to the standard
            double-precision floating-point representation, which is
            based on the IEEE-754 standard
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.PrecisionModelType.FloatingSingle">
            <summary>
            Floating single precision corresponds to the standard
            single-precision floating-point representation, which is
            based on the IEEE-754 standard
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.PrecisionModelType.Fixed">
            <summary>
            Fixed Precision indicates that coordinates have a fixed number of decimal places.
            The number of decimal places is determined by the log10 of the scale factor.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.LocationType">
            <summary>
            A list of DE-9IM row indices clarifying the interior, boundary or exterior.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.LocationType.Interior">
            <summary>
            DE-9IM row index of the interior of the first point and column index of
            the interior of the second point. Location value for the interior of a
            point.
            int value = 0;
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.LocationType.Boundary">
            <summary>
            DE-9IM row index of the boundary of the first point and column index of
            the boundary of the second point. Location value for the boundary of a
            point.
            int value = 1;
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.LocationType.Exterior">
            <summary>
            DE-9IM row index of the exterior of the first point and column index of
            the exterior of the second point. Location value for the exterior of a
            point.
            int value = 2;
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.LocationType.Null">
            <summary>
            Used for uninitialized location values.
            int value = -1;
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Ordinate">
            <summary>
            Standard ordinate index values.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Ordinate.X">
            <summary>
            X Ordinate = 0.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Ordinate.Y">
            <summary>
            Y Ordinate = 1.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Ordinate.Z">
            <summary>
            Z Ordinate = 2.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Ordinate.M">
            <summary>
            M Ordinate = 3.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.BeBinaryReader">
            <summary>
            Extends the <see cref="T:System.IO.BinaryReader"/> class to allow reading values in the BigEndian format.
            </summary>
            <remarks>
            While BigEndianBinaryReader extends BinaryReader
            adding methods for reading integer values
            and double values  in the BigEndian format,
            this implementation overrides methods, such <see cref="M:System.IO.BinaryReader.ReadInt32"/>
            and <see cref="M:System.IO.BinaryReader.ReadDouble"/> and more,
            for reading ByteOrder.BigEndian values in the BigEndian format.
            </remarks>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryReader.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Utilities.BeBinaryReader"/> class.
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryReader.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the BEBinaryReader class.
            </summary>
            <param name="input">The supplied stream.</param>
            <param name="encoding">The character encoding.</param>
            <exception cref="T:System.ArgumentNullException">encoding is null. </exception>
            <exception cref="T:System.ArgumentException">The stream does not support reading, the stream is null, or the stream is already closed. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryReader.ReadInt16">
            <summary>
            Reads a 2-byte signed integer from the current stream using big endian encoding
            and advances the current position of the stream by two bytes.
            </summary>
            <returns>
            A 2-byte signed integer read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryReader.ReadInt32">
            <summary>
            Reads a 4-byte signed integer from the current stream using big endian encoding
            and advances the current position of the stream by four bytes.
            </summary>
            <returns>
            A 4-byte signed integer read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryReader.ReadInt64">
            <summary>
            Reads an 8-byte signed integer from the current stream using big endian encoding
            and advances the current position of the stream by eight bytes.
            </summary>
            <returns>
            An 8-byte signed integer read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryReader.ReadSingle">
            <summary>
            Reads a 4-byte floating point value from the current stream using big endian encoding
            and advances the current position of the stream by four bytes.
            </summary>
            <returns>
            A 4-byte floating point value read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryReader.ReadDouble">
            <summary>
            Reads an 8-byte floating point value from the current stream using big endian encoding
            and advances the current position of the stream by eight bytes.
            </summary>
            <returns>
            An 8-byte floating point value read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryReader.ReadDecimal">
            <inheritdoc />
        </member>
        <member name="T:DotSpatial.Topology.Utilities.BeBinaryWriter">
            <summary>
            Extends the <see cref="T:System.IO.BinaryWriter"/> class to allow writing values in the BigEndian format.
            </summary>
            <remarks>
            While BigEndianBinaryWriter extends <see cref="T:System.IO.BinaryWriter"/>
            adding methods for writing integer values (BigEndianBinaryWriter.WriteIntBE)
            and double values (BigEndianBinaryWriter.WriteDoubleBE) in the BigEndian format,
            this implementation overrides methods, such BinaryWriter.Write(Int32)
            and BinaryWriter.Write(Double)and more,
            for writing T:ByteOrder.BigEndian values in the BigEndian format.
            </remarks>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryWriter.#ctor">
            <summary>
            Initializes a new instance of the class.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryWriter.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the class.
            </summary>
            <param name="output">The supplied stream.</param>
            <exception cref="T:System.ArgumentNullException">output is null. </exception>
            <exception cref="T:System.ArgumentException">
            The stream does not support writing, or the stream is already closed. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryWriter.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the class.
            </summary>
            <param name="output">The supplied stream.</param>
            <param name="encoding">The character encoding.</param>
            <exception cref="T:System.ArgumentNullException">output or encoding is null. </exception>
            <exception cref="T:System.ArgumentException">
            The stream does not support writing, or the stream is already closed. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryWriter.Write(System.Int16)">
            <summary>
            Writes a two-byte signed integer to the current stream using BigEndian encoding
            and advances the stream position by two bytes.
            </summary>
            <param name="value">The two-byte signed integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryWriter.Write(System.Int32)">
            <summary>
            Writes a four-byte signed integer to the current stream using BigEndian encoding
            and advances the stream position by four bytes.
            </summary>
            <param name="value">The four-byte signed integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryWriter.Write(System.Int64)">
            <summary>
            Writes an eight-byte signed integer to the current stream using BigEndian encoding
            and advances the stream position by eight bytes.
            </summary>
            <param name="value">The eight-byte signed integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryWriter.Write(System.Single)">
            <summary>
            Writes a four-byte floating-point value to the current stream using BigEndian encoding
            and advances the stream position by four bytes.
            </summary>
            <param name="value">The four-byte floating-point value to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryWriter.Write(System.Double)">
            <summary>
            Writes an eight-byte floating-point value to the current stream using BigEndian encoding
            and advances the stream position by eight bytes.
            </summary>
            <param name="value">The eight-byte floating-point value to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryWriter.Write(System.String)">
            <summary>
            Writes a length-prefixed string to this stream in the current encoding
            of the <see cref="T:System.IO.BinaryWriter"></see>,
            and advances the current position of the stream in accordance
            with the encoding used and the specific characters being written to the stream.
            </summary>
            <param name="value">The value to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.ArgumentNullException">value is null. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.BeBinaryWriter.Write(System.Decimal)">
            <summary>
            Writes a decimal value to the current stream and advances the stream position by sixteen bytes.
            </summary>
            <param name="value">The decimal value to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.ByteOrder">
            <summary>
            Byte order
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.ByteOrder.BigEndian">
            <summary>
            Big Endian
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.ByteOrder.LittleEndian">
            <summary>
            Little Endian
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Coordinate">
            <summary>
            The original idea of comming up with a coordinate that used public accessors and an
            ICoordinate interface was actually quite slow, given that every access point was
            multiplied across many instances.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Coordinate.M">
            <summary>
            An optional place holder for a measure value if needed
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Coordinate.X">
            <summary>
            The X or horizontal, or longitudinal ordinate
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Coordinate.Y">
            <summary>
            The Y or vertical, or latitudinal ordinate
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Coordinate.Z">
            <summary>
            The Z or up or altitude ordinate
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.#ctor">
            <summary>
            Creates an empty coordinate
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.#ctor(System.Double,System.Double)">
            <summary>
            Creates a 2D coordinate with NaN for the Z and M values
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new coordinate with the specified values
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.#ctor(System.Double[])">
            <summary>
            Creates a new coordinate with the values in X, Y, Z order, or X, Y order.
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.#ctor(DotSpatial.Topology.ICoordinate)">
            <summary>
            Constructs a new instance of the coordinate
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.#ctor(DotSpatial.Topology.Coordinate)">
            <summary>
            Constructs a new instance of the coordinate
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a new instance of Coordinate
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.Equals(System.Object)">
            <summary>
            Compares the X, Y and Z values with the specified item.
            If the Z value is NaN then only the X and Y values are considered
            </summary>
            <param name="obj">This should be either a Coordiante or an ICoordinate</param>
            <returns>Boolean, true if the two are equal</returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.GetHashCode">
            <summary>
            returns the simple base.GetHashCode
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.ToArray">
            <summary>
            Returns the underlying two dimensional array of coordinates
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.Distance(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns Euclidean 2D distance from ICoordinate p.
            </summary>
            <param name="end"><i>ICoordinate</i> with which to do the distance comparison.</param>
            <returns>Double, the distance between the two locations.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.Equals2D(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns whether the planar projections of the two <i>Coordinate</i>s are equal.
            </summary>
            <param name="b">The ICoordinate with which to do the 2D comparison.</param>
            <returns>
            <c>true</c> if the x- and y-coordinates are equal;
            the Z coordinates do not have to be equal.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.Equals3D(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns true if other has the same values for x, y and z.
            </summary>
            <param name="b">The second ICoordiante for a 3D comparison</param>
            <returns><c>true</c> if <c>other</c> is a <c>ICoordinate</c> with the same values for x, y and z.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.HyperDistance(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns the distance that is appropriate for N dimensions.  In otherwords, if this point is
            three dimensional, then all three dimensions will be used for calculating the distance.
            </summary>
            <param name="b">The coordinate to compare to this coordinate</param>
            <returns>A double valued distance measure that is invariant to the number of coordinates</returns>
            <exception cref="T:DotSpatial.Topology.CoordinateMismatchException">The number of dimensions does not match between the points.</exception>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.ToString">
            <summary>
            Returns a <c>string</c> of the form <I>(x, y, z)</I> .
            </summary>
            <returns><c>string</c> of the form <I>(x, y, z)</I></returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.System#IComparable#CompareTo(System.Object)">
            <summary>
            Compares this object with the specified object for order.
            Since Coordinates are 2.5D, this routine ignores the z value when making the comparison.
            Returns
               -1 : this.x lowerthan other.x || ((this.x == other.x) AND (this.y lowerthan other.y))
               0  : this.x == other.x AND this.y = other.y
               1  : this.x greaterthan other.x || ((this.x == other.x) AND (this.y greaterthan other.y))
            </summary>
            <param name="other"><c>Coordinate</c> with which this <c>Coordinate</c> is being compared.</param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>Coordinate</c>
                    is less than, equal to, or greater than the specified <c>Coordinate</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.CompareTo(DotSpatial.Topology.Coordinate)">
            <summary>
            Compares this object with the specified object for order.
            Since Coordinates are 2.5D, this routine ignores the z value when making the comparison.
            Returns
               -1 : this.x lowerthan other.x || ((this.x == other.x) AND (this.y lowerthan other.y))
               0  : this.x == other.x AND this.y = other.y
               1  : this.x greaterthan other.x || ((this.x == other.x) AND (this.y greaterthan other.y))
            </summary>
            <param name="other"><c>Coordinate</c> with which this <c>Coordinate</c> is being compared.</param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>Coordinate</c>
                    is less than, equal to, or greater than the specified <c>Coordinate</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.IsEmpty">
            <summary>
            If either X or Y is defined as NaN, then this coordinate is considered empty.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.Clone">
            <summary>
             Duplicates this coordinate
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Equality(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Inequality(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Addition(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Overloaded + operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Addition(DotSpatial.Topology.Coordinate,System.Double)">
            <summary>
            Overloaded + operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Addition(System.Double,DotSpatial.Topology.Coordinate)">
            <summary>
            Overloaded + operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Multiply(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Overloaded * operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Multiply(DotSpatial.Topology.Coordinate,System.Double)">
            <summary>
            Overloaded * operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Multiply(System.Double,DotSpatial.Topology.Coordinate)">
            <summary>
            Overloaded * operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Subtraction(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Overloaded - operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Subtraction(DotSpatial.Topology.Coordinate,System.Double)">
            <summary>
            Overloaded - operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Subtraction(System.Double,DotSpatial.Topology.Coordinate)">
            <summary>
            Overloaded - operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Division(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Overloaded / operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Division(DotSpatial.Topology.Coordinate,System.Double)">
            <summary>
            Overloaded / operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Coordinate.op_Division(System.Double,DotSpatial.Topology.Coordinate)">
            <summary>
            Overloaded / operator.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Coordinate.Empty">
            <summary>
            Gets a pre-defined coordinate that has double.NaN for all the values.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Coordinate.Item(System.Int32)">
            <summary>
            Gets or sets the double value associated with the specified ordinate index
            </summary>
            <param name="index">The zero-based integer index of the ordinate</param>
            <returns>A double value representing a single ordinate</returns>
        </member>
        <member name="P:DotSpatial.Topology.Coordinate.NumOrdinates">
            <summary>
            This is not a true length, but simply tests the Z value.  If the Z value
            is NaN then the value is 2.  Otherwise this is 3.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.CoordinateArrays">
            <summary>
            Useful utility functions for handling Coordinate arrays.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.PointNotInList(DotSpatial.Topology.Coordinate[],DotSpatial.Topology.Coordinate[])">
            <summary>
            Finds a <see cref="T:DotSpatial.Topology.Coordinate"/> in a list of <see cref="T:DotSpatial.Topology.Coordinate"/>s
            which is not contained in another list of <see cref="T:DotSpatial.Topology.Coordinate"/>s.
            </summary>
            <param name="testPts">The <see cref="T:DotSpatial.Topology.Coordinate"/>s to test.</param>
            <param name="pts">An array of <see cref="T:DotSpatial.Topology.Coordinate"/>s to test the input points against.</param>
            <returns>
            A <see cref="T:DotSpatial.Topology.Coordinate"/> from <paramref name="testPts"/>
            which is not in <paramref name="pts"/>, or <c>null</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.Compare(DotSpatial.Topology.Coordinate[],DotSpatial.Topology.Coordinate[])">
            <summary>
            Compares two <see cref="T:DotSpatial.Topology.Coordinate"/> arrays
            in the forward direction of their coordinates,
            using lexicographic ordering.
            </summary>
            <param name="pts1"></param>
            <param name="pts2"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.IncreasingDirection(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Determines which orientation of the <see cref="T:DotSpatial.Topology.Coordinate"/> array is (overall) increasing.
            In other words, determines which end of the array is "smaller"
            (using the standard ordering on <see cref="T:DotSpatial.Topology.Coordinate"/>).
            Returns an integer indicating the increasing direction.
            If the sequence is a palindrome, it is defined to be
            oriented in a positive direction.
            </summary>
            <param name="pts">The array of Coordinates to test.</param>
            <returns>
            <c>1</c> if the array is smaller at the start or is a palindrome,
            <c>-1</c> if smaller at the end.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.IsEqualReversed(DotSpatial.Topology.Coordinate[],DotSpatial.Topology.Coordinate[])">
            <summary>
            Determines whether two <see cref="T:DotSpatial.Topology.Coordinate"/> arrays of equal length
            are equal in opposite directions.
            </summary>
            <param name="pts1"></param>
            <param name="pts2"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.CopyDeep(DotSpatial.Topology.Coordinate[])">
            <summary>
            Creates a deep copy of the argument <c>Coordinate</c> array.
            </summary>
            <param name="coordinates">Array of Coordinates.</param>
            <returns>Deep copy of the input.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.ToCoordinateArray(System.Collections.IList)">
            <summary>
            Converts the given <see cref="T:System.Collections.IList"/> of
            <see cref="T:DotSpatial.Topology.Coordinate"/>s into a <see cref="T:DotSpatial.Topology.Coordinate"/> array.
            </summary>
            <param name="coordList"><see cref="T:System.Collections.IList"/> of coordinates.</param>
            <returns></returns>
            <exception cref="T:System.InvalidCastException">
            If <paramref name="coordList"/> contains not only <see cref="T:DotSpatial.Topology.Coordinate"/>s.
            </exception>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.ToCoordinateArray(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Converts the given <see cref="T:System.Collections.IList"/> of
            <see cref="T:DotSpatial.Topology.Coordinate"/>s into a <see cref="T:DotSpatial.Topology.Coordinate"/> array.
            </summary>
            <param name="coordList"><see cref="T:System.Collections.IList"/> of coordinates.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.HasRepeatedPoints(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
            Returns whether Equals returns true for any two consecutive
            coordinates in the given array.
            </summary>
            <param name="coords">Array of Coordinates.</param>
            <returns>true if coord has repeated points; false otherwise.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.AtLeastNCoordinatesOrNothing(System.Int32,DotSpatial.Topology.Coordinate[])">
            <summary>
            Returns either the given coordinate array if its length is greater than
            the given amount, or an empty coordinate array.
            </summary>
            <param name="n">Length amount.</param>
            <param name="c">Array of Coordinates.</param>
            <returns>New Coordinate array.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.RemoveRepeatedPoints(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            If the coordinate array argument has repeated points,
            constructs a new array containing no repeated points.
            Otherwise, returns the argument.
            </summary>
            <param name="coords"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.Reverse(DotSpatial.Topology.Coordinate[])">
            <summary>
            Reverses the coordinates in an array in-place.
            </summary>
            <param name="coord">Array of Coordinates.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.Equals(DotSpatial.Topology.Coordinate[],DotSpatial.Topology.Coordinate[])">
            <summary>
            Returns <c>true</c> if the two arrays are identical, both <c>null</c>, or pointwise
            equal (as compared using Coordinate.Equals).
            </summary>
            <param name="coord1">First array of Coordinates.</param>
            <param name="coord2">Second array of Coordinates.</param>
            <returns><c>true</c> if two Coordinates array are equals; false otherwise</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.Equals(DotSpatial.Topology.Coordinate[],DotSpatial.Topology.Coordinate[],System.Collections.Generic.IComparer{DotSpatial.Topology.Coordinate[]})">
            <summary>
            Returns <c>true</c> if the two arrays are identical, both <c>null</c>, or pointwise
            equal, using a user-defined <see cref="T:System.Collections.IComparer"/>
            for <see cref="T:DotSpatial.Topology.Coordinate"/>s.
            </summary>
            <param name="coord1">An array of <see cref="T:DotSpatial.Topology.Coordinate"/>s.</param>
            <param name="coord2">Another array of <see cref="T:DotSpatial.Topology.Coordinate"/>s.</param>
            <param name="coordinateComparer">
             A <see cref="T:System.Collections.IComparer"/> for <see cref="T:DotSpatial.Topology.Coordinate"/>s.
            </param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.MinCoordinate(DotSpatial.Topology.Coordinate[])">
            <summary>
            Returns the minimum coordinate, using the usual lexicographic comparison.
            </summary>
            <param name="coordinates">Array to search.</param>
            <returns>The minimum coordinate in the array, found using <c>CompareTo</c>.</returns>
            <seeaalso cref="M:DotSpatial.Topology.Coordinate.CompareTo(DotSpatial.Topology.Coordinate)"/>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.Scroll(DotSpatial.Topology.Coordinate[],DotSpatial.Topology.Coordinate)">
            <summary>
            Shifts the positions of the coordinates until <c>firstCoordinate</c> is first.
            </summary>
            <param name="coordinates">Array to rearrange.</param>
            <param name="firstCoordinate">Coordinate to make first.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.IndexOf(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate[])">
            <summary>
            Returns the index of <paramref name="coordinate"/> in <paramref name="coordinates"/>.
            The first position is 0; the second is 1; etc.
            </summary>
            <param name="coordinate">A <see cref="T:DotSpatial.Topology.Coordinate"/> to search for.</param>
            <param name="coordinates">A <see cref="T:DotSpatial.Topology.Coordinate"/> array to search.</param>
            <returns>The position of <c>coordinate</c>, or -1 if it is not found.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.Extract(DotSpatial.Topology.Coordinate[],System.Int32,System.Int32)">
            <summary>
            Extracts a subsequence of the input <see cref="T:DotSpatial.Topology.Coordinate"/> array
            from indices <paramref name="start"/> to <paramref name="end"/> (inclusive).
            </summary>
            <param name="pts">The input array.</param>
            <param name="start">The index of the start of the subsequence to extract.</param>
            <param name="end">The index of the end of the subsequence to extract.</param>
            <returns>A subsequence of the input array.</returns>
        </member>
        <member name="T:DotSpatial.Topology.CoordinateArrays.BidirectionalComparator">
            <summary>
            A comparator for <see cref="T:DotSpatial.Topology.Coordinate"/> arrays modulo their directionality.
            E.g. if two coordinate arrays are identical but reversed
            they will compare as equal under this ordering.
            If the arrays are not equal, the ordering returned
            is the ordering in the forward direction.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.BidirectionalComparator.Compare(DotSpatial.Topology.Coordinate[],DotSpatial.Topology.Coordinate[])">
             <summary>
            
             </summary>
             <param name="pts1"></param>
             <param name="pts2"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.CoordinateArrays.ForwardComparator">
            <summary>
            Compares two <see cref="T:DotSpatial.Topology.Coordinate"/> arrays
            in the forward direction of their coordinates,
            using lexicographic ordering.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArrays.ForwardComparator.Compare(DotSpatial.Topology.Coordinate[],DotSpatial.Topology.Coordinate[])">
            <summary>
            Compares the specified <see cref="T:DotSpatial.Topology.Coordinate"/>s arrays.
            </summary>
            <param name="pts1"></param>
            <param name="pts2"></param>
            <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.CoordinateArraySequence">
            <summary>
            The <c>ICoordinateSequence</c> implementation that <c>Geometry</c>s use by default.
            In this implementation, Coordinates returned by ToArray and Coordinate are live --
            modifications to them are actually changing the
            CoordinateSequence's underlying data.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.ICoordinateSequence">
            <summary>
            The internal representation of a list of coordinates inside a Geometry.
            <para>
            There are some cases in which you might want Geometries to store their
            points using something other than the NTS Coordinate class. For example, you
            may want to experiment with another implementation, such as an array of xs
            and an array of ys. or you might want to use your own coordinate class, one
            that supports extra attributes like M-values.
            </para>
            <para>
            You can do this by implementing the ICoordinateSequence and
            ICoordinateSequenceFactory interfaces. You would then create a
            GeometryFactory parameterized by your ICoordinateSequenceFactory, and use
            this GeometryFactory to create new Geometries. All of these new Geometries
            will use your ICoordinateSequence implementation.
            An observation on performance: If your ICoordinateSequence is not based on an array
            of Coordinates, it may incur a performance penalty when its ToArray() method
            is called because the array needs to be built from scratch.
            </para>
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.ICoordinateSequence.GetOrdinate(System.Int32,DotSpatial.Topology.Ordinate)">
            <summary>
            Returns the ordinate of a coordinate in this sequence.
            Ordinate indices 0 and 1 are assumed to be X and Y.
            Ordinates indices greater than 1 have user-defined semantics
            (for instance, they may contain other dimensions or measure values).
            </summary>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinate">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.ICoordinateSequence.SetOrdinate(System.Int32,DotSpatial.Topology.Ordinate,System.Double)">
            <summary>
            Sets the value for a given ordinate of a coordinate in this sequence.
            </summary>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinate">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <param name="value">The new ordinate value.</param>
        </member>
        <member name="M:DotSpatial.Topology.ICoordinateSequence.ToCoordinateArray">
            <summary>
            Returns (possibly copies of) the Coordinates in this collection.
            Whether or not the Coordinates returned are the actual underlying
            Coordinates or merely copies depends on the implementation. Notice that
            if this implementation does not store its data as an array of Coordinates,
            this method will incur a performance penalty because the array needs to
            be built from scratch.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.ICoordinateSequence.ExpandEnvelope(DotSpatial.Topology.IEnvelope)">
            <summary>
            Expands the given Envelope to include the coordinates in the sequence.
            Does not modify the original envelope, but rather returns a copy of the
            original envelope after being modified.
            </summary>
            <param name="env">The envelope use as the starting point for expansion.  This envelope will not be modified.</param>
            <returns>The newly created envelope that is the expanded version of the original.</returns>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinateSequence.Dimension">
            <summary>
            Returns the dimension (number of ordinates in each coordinate) for this sequence.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinateSequence.Item(System.Int32)">
            <summary>
            Direct accessor to an ICoordinate
            </summary>
            <param name="index">An integer index in this array sequence</param>
            <returns>An ICoordinate for the specified index</returns>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinateSequence.VersionID">
            <summary>
            Every time a member is added to, subtracted from, or edited in the sequence,
            this VersionID is incremented.  This doesn't uniquely separate this sequence
            from other sequences, but rather acts as a way to rapidly track if changes
            have occured against a cached version.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.IncrementVersion">
            <summary>
            Increments the version with the understanding that we are using integers.  If the user
            uses too many version, it will cycle around.  The statistical odds of accidentally
            reaching the same value as a previous version should be small enough to prevent
            conflicts.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.#ctor">
            <summary>
            Creates a new array sequence dimensioned with exactly 1 coordinate that is empty.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.#ctor(DotSpatial.Topology.Coordinate)">
            <summary>
            Creates a new array sequence dimensioned with exactly 1 coordinate, which is set to the coordinate
            </summary>
            <param name="coordinate">The ICoordinate to use when constructing this sequence</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
            Creates a new CoordinateArraySequence whose members are
            </summary>
            <param name="coordinates">The existing list whose members will be copied to the array.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.#ctor(DotSpatial.Topology.Coordinate[])">
            <summary>
            Constructs a sequence based on the given array (the array is not copied).
            </summary>
            <param name="coordinates">The coordinate array that will be referenced.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.#ctor(System.Int32)">
            <summary>
            Constructs a sequence of a given size, populated with new Coordinates.
            </summary>
            <param name="size">The size of the sequence to create.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.#ctor(DotSpatial.Topology.ICoordinateSequence)">
            <summary>
            Constructs a sequence based on the given array (the array is not copied).
            </summary>
            <param name="coordSeq">The coordinate array that will be referenced.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.Add(DotSpatial.Topology.Coordinate)">
            <summary>
            Adds a single item to the array.  This is very slow for arrays because it has to
            copy all the values into a new array.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.Clear">
            <summary>
            Clears the array, reducing the measure to 1 empty coordinate.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.Contains(DotSpatial.Topology.Coordinate)">
            <summary>
            Tests to see if the array contains the specified item
            </summary>
            <param name="item">the ICoordinate to test</param>
            <returns>True if the value is in the array.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.Clone">
            <summary>
            Creates a deep copy of the object.
            </summary>
            <returns>The deep copy.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.CopyTo(DotSpatial.Topology.Coordinate[],System.Int32)">
            <summary>
            Copies all of the members from this sequence into the specifeid array.
            </summary>
            <param name="array">The array of Icoordinates to copy values to.</param>
            <param name="arrayIndex">The starting index</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.ExpandEnvelope(DotSpatial.Topology.IEnvelope)">
            <summary>
            Expands the given Envelope to include the coordinates in the sequence.
            Does not modify the original envelope, but rather returns a copy of the
            original envelope after being modified.
            </summary>
            <param name="env">The envelope use as the starting point for expansion.  This envelope will not be modified.</param>
            <returns>The newly created envelope that is the expanded version of the original.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.GetEnumerator">
            <summary>
            Returns an enumerator object for cycling through each of the various members of the array.
            BEWARE!  This will bypass the VersionID code.  Since ICoordinateSequence does not contain
            the GetEnumerator methods, using an ICoordinateSequence should safely advance the version
            during changes.
            </summary>
            <returns>An Enumerator for this array.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.GetOrdinate(System.Int32,DotSpatial.Topology.Ordinate)">
            <summary>
            Returns the ordinate of a coordinate in this sequence.
            Ordinate indices 0 and 1 are assumed to be X and Y.
            Ordinates indices greater than 1 have user-defined semantics
            (for instance, they may contain other dimensions or measure values).
            </summary>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinate">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.Remove(DotSpatial.Topology.Coordinate)">
            <summary>
            For arrays, this is very inneficient.  This will copy all the members
            except for the item to a new array.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>Boolean, true if a match was found and an item was removed, false otherwise.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.SetOrdinate(System.Int32,DotSpatial.Topology.Ordinate,System.Double)">
            <summary>
            Sets the value for a given ordinate of a coordinate in this sequence.
            </summary>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinate">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <param name="value">The new ordinate value.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.ToCoordinateArray">
             <summary>
            This method exposes the internal Array of Coordinate Objects.
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.ToString">
            <summary>
            Returns the string representation of the coordinate array.
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateArraySequence.Count">
            <summary>
            Returns the length of the coordinate sequence.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateArraySequence.Dimension">
            <summary>
            Returns the dimension (number of ordinates in each coordinate) for this sequence.
            </summary>
            <value></value>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateArraySequence.IsReadOnly">
            <summary>
            CoordinateArraySequences are not ReadOnly
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateArraySequence.Item(System.Int32)">
            <summary>
            Direct accessor to an ICoordinate
            </summary>
            <param name="index">An integer index in this array sequence</param>
            <returns>An ICoordinate for the specified index</returns>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateArraySequence.VersionID">
            <summary>
            Every time a member is added to, subtracted from, or edited in the sequence,
            this VersionID is incremented.  This doesn't uniquely separate this sequence
            from other sequences, but rather acts as a way to rapidly track if changes
            have occured against a cached version.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.CoordinateArraySequence.Enumerator">
            <summary>
            CoordinateArraySequenceEnumerator
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.Enumerator.#ctor(System.Collections.IEnumerator)">
            <summary>
            Creates a new instance of CoordinateArraySequenceEnumerator
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.Enumerator.Dispose">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next member
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateArraySequence.Enumerator.Reset">
            <summary>
            Resets the enumerator to the original position
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateArraySequence.Enumerator.Current">
            <summary>
            Gets the current member
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.CoordinateArraySequenceFactory">
            <summary>
            Creates CoordinateSequences represented as an array of Coordinates.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.ICoordinateSequenceFactory">
            <summary>
            An object that knows how to build a particular implementation of
            <c>ICoordinateSequence</c> from an array of Coordinates.
            </summary>
            <seealso cref="T:DotSpatial.Topology.ICoordinateSequence"/>
        </member>
        <member name="M:DotSpatial.Topology.ICoordinateSequenceFactory.Create(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
            Returns a CoordinateSequence based on the given array; whether or not the
            array is copied is implementation-dependent.
            </summary>
            <param name="coordinates">Coordinates array, which may not be null nor contain null elements</param>
        </member>
        <member name="M:DotSpatial.Topology.ICoordinateSequenceFactory.Create(DotSpatial.Topology.Coordinate)">
            <summary>
            Constructs a new coordinate sequence using a single coordinate.
            </summary>
            <param name="coord">A single coordinate to be used in a coordinate sequence factory.</param>
            <returns>A valid ICoordinateSequence.</returns>
        </member>
        <member name="M:DotSpatial.Topology.ICoordinateSequenceFactory.Create">
            <summary>
            Constructs either an array with 1 member or an empty list, depending on the implementation.
            </summary>
            <returns>A new seqeunce</returns>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.CoordinateArraySequenceFactory.Instance">
            <summary>
            This appears to be part of a singleton for a coordinate array sequence factory
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.CoordinateArraySequenceFactory.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.CoordinateArraySequenceFactory.Create(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
             Returns a CoordinateArraySequence based on the given array (the array is not copied).
            </summary>
            <param name="coordinates">the coordinates, which may not be null nor contain null elements.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.CoordinateArraySequenceFactory.Create(DotSpatial.Topology.Coordinate)">
            <summary>
            Constructs a new coordinate sequence using a single coordinate.
            </summary>
            <param name="coord">A single coordinate to be used in a coordinate sequence factory.</param>
            <returns>A valid ICoordinateSequence.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.CoordinateArraySequenceFactory.Create">
            <summary>
            Constructs either an array with 1 member or an empty list, depending on the implementation.
            </summary>
            <returns>A new seqeunce</returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.CoordinateArraySequenceFactory.Create(DotSpatial.Topology.ICoordinateSequence)">
             <summary>
            
             </summary>
             <param name="coordSeq"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.CoordinateF">
            <summary>
            A lightweight class used to store coordinates
            on the 2-dimensional Cartesian plane.
            It is distinct from <c>Point</c>, which is a subclass of <c>Geometry</c>.
            Unlike objects of type <c>Point</c> (which contain additional
            information such as an envelope, a precision model, and spatial reference
            system information), a <c>Coordinate</c> only contains ordinate values
            and accessor methods.
            <c>Coordinate</c>s are two-dimensional points, with an additional
            z-ordinate. NTS does not support any operations on the z-ordinate except
            the basic accessor functions. Constructed coordinates will have a
            z-ordinate of <c>NaN</c>.  The standard comparison functions will ignore
            the z-ordinate.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.#ctor(DotSpatial.Topology.FloatVector3)">
            <summary>
            Creates a CoordinateF by using the X, Y and Z terms of a FloatVector
            </summary>
            <param name="floatVector"></param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs a <c>Coordinate</c> at (x, y, z).
            </summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
            <param name="z">Z value.</param>
            <param name="m">Measure value.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Constructs a <c>Coordinate</c> at (x, y, z).
            </summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
            <param name="z">Z value.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.#ctor(DotSpatial.Topology.Coordinate)">
            <summary>
            Creates a Coordinate from any ICoordinate Interface
            </summary>
            <param name="coordinate">The Vector.IPoint interface to construct a coordinate from</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.#ctor">
            <summary>
             Constructs a <c>Coordinate</c> at (0, 0, NaN).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.#ctor(System.Single,System.Single)">
            <summary>
            Constructs a <c>Coordinate</c> at (x, y, NaN).
            </summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.Equals2D(DotSpatial.Topology.CoordinateF)">
             <summary>
             Returns whether the planar projections of the two <i>Coordinate</i>s are equal.
            </summary>
             <param name="coordinate"><i>ICoordinate</i> with which to do the 2D comparison.</param>
             <returns>
             <c>true</c> if the x- and y-coordinates are equal;
             the Z coordinates do not have to be equal.
             </returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <c>other</c> has the same values for the x and y ordinates.
            Since Coordinates are 2.5D, this routine ignores the z value when making the comparison.
            </summary>
            <param name="other"><c>Coordinate</c> with which to do the comparison.</param>
            <returns><c>true</c> if <c>other</c> is a <c>Coordinate</c> with the same values for the x and y ordinates.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Equality(DotSpatial.Topology.CoordinateF,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Inequality(DotSpatial.Topology.CoordinateF,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.CompareTo(System.Object)">
            <summary>
            Compares this object with the specified object for order.
            Since Coordinates are 2.5D, this routine ignores the z value when making the comparison.
            Returns
               -1 : this.x lowerthan other.x || ((this.x == other.x) AND (this.y lowerthan other.y))
               0  : this.x == other.x AND this.y = other.y
               1  : this.x greaterthan other.x || ((this.x == other.x) AND (this.y greaterthan other.y))
            </summary>
            <param name="other"><c>Coordinate</c> with which this <c>Coordinate</c> is being compared.</param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>Coordinate</c>
                    is less than, equal to, or greater than the specified <c>Coordinate</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.Equals3D(DotSpatial.Topology.CoordinateF)">
            <summary>
            Returns true if other has the same values for x, y and z.
            </summary>
            <param name="other"><i>ICoordinate</i> with which to do the 3D comparison.</param>
            <returns><c>true</c> if <c>other</c> is a <c>ICoordinate</c> with the same values for x, y and z.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.ToString">
            <summary>
            Returns a <c>string</c> of the form <I>(x, y, z)</I> .
            </summary>
            <returns><c>string</c> of the form <I>(x, y, z)</I></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.Clone">
            <summary>
            Create a new object as copy of this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.Copy">
            <summary>
            Creates a new ICoordinate copy of this instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.Distance(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns Euclidean 2D distance from ICoordinate p.
            </summary>
            <param name="coordinate"><i>ICoordinate</i> with which to do the distance comparison.</param>
            <returns>Double, the distance between the two locations.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.HyperDistance(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns the distance that is appropriate for N dimensions.  In otherwords, if this point is
            three dimensional, then all three dimensions will be used for calculating the distance.
            </summary>
            <param name="coordinate">The coordinate to compare to this coordinate</param>
            <returns>A double valued distance measure that is invariant to the number of coordinates</returns>
            <exception cref="T:DotSpatial.Topology.CoordinateMismatchException">The number of dimensions does not match between the points.</exception>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.GetHashCode">
            <summary>
            Return HashCode.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.GetHashCode(System.Double)">
            <summary>
            Return HashCode.
            </summary>
            <param name="x">Value from HashCode computation.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Addition(DotSpatial.Topology.CoordinateF,DotSpatial.Topology.Coordinate)">
            <summary>
            Overloaded + operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Addition(DotSpatial.Topology.CoordinateF,System.Single)">
            <summary>
            Overloaded + operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Addition(System.Single,DotSpatial.Topology.CoordinateF)">
            <summary>
            Overloaded + operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Multiply(DotSpatial.Topology.CoordinateF,DotSpatial.Topology.Coordinate)">
            <summary>
            Overloaded * operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Multiply(DotSpatial.Topology.CoordinateF,System.Single)">
            <summary>
            Overloaded * operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Multiply(System.Single,DotSpatial.Topology.CoordinateF)">
            <summary>
            Overloaded * operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Subtraction(DotSpatial.Topology.CoordinateF,DotSpatial.Topology.Coordinate)">
            <summary>
            Overloaded - operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Subtraction(DotSpatial.Topology.CoordinateF,System.Single)">
            <summary>
            Overloaded - operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Subtraction(System.Single,DotSpatial.Topology.CoordinateF)">
            <summary>
            Overloaded - operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Division(DotSpatial.Topology.CoordinateF,DotSpatial.Topology.Coordinate)">
            <summary>
            Overloaded / operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Division(DotSpatial.Topology.CoordinateF,System.Single)">
            <summary>
            Overloaded / operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.op_Division(System.Single,DotSpatial.Topology.CoordinateF)">
            <summary>
            Overloaded / operator.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateF.ToArray">
            <summary>
            Gets an array of double values for each of the ordinates
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateF.X">
            <summary>
            Direct access to the coordinate works as a float.  If you only have the interface,
            it must involve conversions to and from a float.  This may cause errors if the
            value being set is outside the range of the float values.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateF.Y">
            <summary>
            Direct access to the Y coordinate as a float
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateF.Z">
            <summary>
            Z coordinate.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateF.M">
            <summary>
            A Measure coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateF.CoordinateValue">
            <summary>
            Gets/Sets <c>Coordinate</c>s (x, y, z) values.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateF.Item(System.Int32)">
            <summary>
            Gets or sets the double value corresponding to the specific ordinate
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateF.NumOrdinates">
            <summary>
             For now this is 3D
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateF.Values">
            <summary>
            Gets or sets the values of this CoordinateF using an array of double values
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.CoordinateList">
            <summary>
            A list of Coordinates, which may
            be set to prevent repeated coordinates from occuring in the list.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateList.#ctor">
            <summary>
            Creates a new instance of a coordiante list
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateList.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
            The basic constructor for a CoordinateArray allows repeated points
            (i.e produces a CoordinateList with exactly the same set of points).
            </summary>
            <param name="coords">Initial coordinates</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateList.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate},System.Boolean)">
            <summary>
            Constructs a new list from an array of Coordinates,
            allowing caller to specify if repeated points are to be removed.
            </summary>
            <param name="coords">Array of coordinates to load into the list.</param>
            <param name="allowRepeated">If <c>false</c>, repeated points are removed.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateList.Clone">
            <summary>
            Returns a deep copy of this collection.
            </summary>
            <returns>The copied object.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateList.Add(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate},System.Boolean,System.Boolean)">
            <summary>
            Add an array of coordinates.
            </summary>
            <param name="coords">Coordinates to be inserted.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
            <param name="direction">If false, the array is added in reverse order.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateList.Add(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate},System.Boolean)">
            <summary>
            Add an array of coordinates.
            </summary>
            <param name="coord">Coordinates to be inserted.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateList.Add(DotSpatial.Topology.Coordinate,System.Boolean)">
            <summary>
            Add a coordinate.
            </summary>
            <param name="coord">Coordinate to be inserted.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateList.DoAdd(DotSpatial.Topology.Coordinate,System.Boolean)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <param name="allowRepeated"></param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateList.DoAddRange(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate},System.Boolean)">
            <summary>
            Adds the entire range of coordinates, preventing coordinates with the identical 2D signiture from
            being added immediately after it's duplicate.
            </summary>
            <param name="coords"></param>
            <param name="allowRepeated"></param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateList.CloseRing">
            <summary>
            Ensure this coordList is a ring, by adding the start point if necessary.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateList.ToCoordinateArray">
            <summary>
            Returns the Coordinates in this collection.
            </summary>
            <returns>Coordinater as <c>Coordinate[]</c> array.</returns>
        </member>
        <member name="T:DotSpatial.Topology.CoordinateListSequence">
            <summary>
            An ICoordinateSequence based on a list instead of an array.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.#ctor(DotSpatial.Topology.Coordinate)">
            <summary>
            Creates a new instance of a CoordinateListSequence
            </summary>
            <param name="coordinate"></param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.#ctor">
            <summary>
            Creates a new instance of a CoordinateListSequence
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
            Creates a new instance of a CoordinateListSequence
            </summary>
            <param name="coordinates">If this is a List of ICoordinates, the sequence will be a shallow list.
            Otherwise, a List is created and shallow copies of each coordinate is added.</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.#ctor(DotSpatial.Topology.ICoordinateSequence)">
            <summary>
            Creates a new instance of CoordinateListSequence
            </summary>
            <param name="sequence">The sequence to use</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.Add(DotSpatial.Topology.Coordinate)">
            <summary>
            Adds an item to the end of the CoordinateList
            </summary>
            <param name="item">An ICoordinate to add</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.Clear">
            <summary>
            Clears the list entirely.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.Clone">
            <summary>
            Creates a deep copy of this object
            </summary>
            <returns>CoordinateListSequence</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.Contains(DotSpatial.Topology.Coordinate)">
            <summary>
            Tests wheather or not the specified ICoordinate is contained in the list.
            </summary>
            <param name="item">An ICoordinate to test</param>
            <returns>Boolean, true if the list contains the item.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.CopyTo(DotSpatial.Topology.Coordinate[],System.Int32)">
            <summary>
            Copies all the members of this list into the specified array.
            </summary>
            <param name="array">The array to copy values to.</param>
            <param name="arrayIndex">The 0 based integer index in the array at which copying begins</param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.ExpandEnvelope(DotSpatial.Topology.IEnvelope)">
            <summary>
            Expands the given Envelope to include the coordinates in the sequence.
            Does not modify the original envelope, but rather returns a copy of the
            original envelope after being modified.
            </summary>
            <param name="env">The envelope use as the starting point for expansion.  This envelope will not be modified.</param>
            <returns>The newly created envelope that is the expanded version of the original.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.GetEnumerator">
            <summary>
            Obtains an enumerator for cycling through the list.  BEWARE!  This
            will return an underlying list enumerator, and so code that uses
            a foreach process or an enumerator will bypass the Version incrementing code.
            </summary>
            <returns>An Enumerator object for cycling through the list.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.GetOrdinate(System.Int32,DotSpatial.Topology.Ordinate)">
            <summary>
            Gets a specific X, Y or Z value depending on the index specified and the ordinate specified
            </summary>
            <param name="index"></param>
            <param name="ordinate"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.Remove(DotSpatial.Topology.Coordinate)">
            <summary>
            Removes the specified ICoordinate from the list.
            </summary>
            <param name="item">An ICoordinate that should be removed from the list</param>
            <returns>Boolean, true if the item was successfully removed.</returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.SetOrdinate(System.Int32,DotSpatial.Topology.Ordinate,System.Double)">
            <summary>
            Sets a specific X, Y or Z value depending on the index specified and the ordinate specified
            </summary>
            <param name="index"></param>
            <param name="ordinate"></param>
            <param name="value"></param>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.ToCoordinateArray">
            <summary>
            Copies all the members to an ICoordiante[]
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateListSequence.IncrementVersion">
            <summary>
            Increments the version with the understanding that we are using integers.  If the user
            uses too many version, it will cycle around.  The statistical odds of accidentally
            reaching the same value as a previous version should be small enough to prevent
            conflicts.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateListSequence.Count">
            <summary>
            Gets an integer representing the number of ICoordinates currently stored in this list
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateListSequence.Dimension">
            <summary>
            This always returns 0
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateListSequence.IsReadOnly">
            <summary>
            The CoordinateListSequence is not readonly
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateListSequence.Item(System.Int32)">
            <summary>
            Direct accessor to an ICoordinate
            </summary>
            <param name="index">An integer index in this array sequence</param>
            <returns>An ICoordinate for the specified index</returns>
        </member>
        <member name="P:DotSpatial.Topology.CoordinateListSequence.VersionID">
            <summary>
            This only works as long as an enumeration is not used on the CoordinateListSequence.
            Since ICoordinateSequence does not support a GetEnumerator object, as long as you
            are using an ICoordinateSequence interface, VersionID should work.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.CoordinateListSequenceFactory">
            <summary>
            Creates CoordinateSequences represented as an array of Coordinates.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.CoordinateListSequenceFactory.Instance">
            <summary>
            Creates an instance of the CoordinateListSequenceFactory
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.CoordinateListSequenceFactory.Create(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
             Returns a CoordinateArraySequence based on the given array (the array is not copied).
            </summary>
            <param name="coordinates">the coordinates, which may not be null nor contain null elements.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.CoordinateListSequenceFactory.Create">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.CoordinateListSequenceFactory.Create(DotSpatial.Topology.Coordinate)">
            <summary>
            Creates a new CoordinateListSequence and populates it with a single coordinate.
            </summary>
            <param name="coordinate"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.CoordinateListSequenceFactory.Create(DotSpatial.Topology.ICoordinateSequence)">
             <summary>
            
             </summary>
             <param name="coordSeq"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.CoordinateMismatchException">
            <summary>
            CoordinateMismatchException
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.CoordinateMismatchException.#ctor">
            <summary>
            Creates a new instance of CoordinateMismatchException
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Dimension">
            <summary>
            Class containing static methods for conversions
            between Dimension values and characters.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Dimension.ToDimensionSymbol(DotSpatial.Topology.DimensionType)">
            <summary>
            Converts the dimension value to a dimension symbol,
            for example, <c>True => 'T'</c>
            </summary>
            <param name="dimensionValue">Number that can be stored in the <c>IntersectionMatrix</c>.
            Possible values are <c>True, False, Dontcare, 0, 1, 2</c>.</param>
            <returns>Character for use in the string representation of an <c>IntersectionMatrix</c>.
            Possible values are <c>T, F, *, 0, 1, 2</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Dimension.ToDimensionValue(System.Char)">
            <summary>
            Converts the dimension symbol to a dimension value,
            for example, <c>'*' => Dontcare</c>
            </summary>
            <param name="dimensionSymbol">Character for use in the string representation of an <c>IntersectionMatrix</c>.
            Possible values are <c>T, F, *, 0, 1, 2</c>.</param>
            <returns>Number that can be stored in the <c>IntersectionMatrix</c>.
            Possible values are <c>True, False, Dontcare, 0, 1, 2</c>.</returns>
        </member>
        <member name="T:DotSpatial.Topology.GeometryType">
            <summary>
            This is enumerates not only the specific types, but very specifically
            that the types are the Topology variety, and not simply the vector variety
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryType.Envelope">
            <summary>
            A non-geometry rectangle that strictly shows extents
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryType.GeometryCollection">
            <summary>
            A collective group of geometries
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryType.LinearRing">
            <summary>
            A closed linestring that doesn't self intersect
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryType.LineString">
            <summary>
            Any linear collection of points joined by line segments
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryType.MultiLineString">
            <summary>
            A collection of independant LineStrings that are not connected
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryType.MultiPoint">
            <summary>
            A Grouping of points
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryType.MultiPolygon">
            <summary>
            A Collection of unconnected polygons
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryType.Point">
            <summary>
            A single coordinate location
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryType.Polygon">
            <summary>
            At least one Linear Ring shell with any number of linear ring "holes"
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryType.Unknown">
            <summary>
            Any other type
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.ShapeGeometryType">
            <summary>
            Shapefile Shape types enumeration
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.NullShape">
            <summary>
            Null Shape
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.Point">
            <summary>
            Point
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.LineString">
            <summary>
            LineString
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.Polygon">
            <summary>
            Polygon
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.MultiPoint">
            <summary>
            MultiPoint
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.PointZM">
            <summary>
            PointMZ
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.LineStringZM">
            <summary>
            PolyLineMZ
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.PolygonZM">
            <summary>
            PolygonMZ
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.MultiPointZM">
            <summary>
            MultiPointMZ
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.PointM">
            <summary>
            PointM
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.LineStringM">
            <summary>
            LineStringM
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.PolygonM">
            <summary>
            PolygonM
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.MultiPointM">
            <summary>
            MultiPointM
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.MultiPatch">
            <summary>
            MultiPatch
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.PointZ">
            <summary>
            PointZ
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.LineStringZ">
            <summary>
            LineStringZ
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.PolygonZ">
            <summary>
            PolygonZ
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.ShapeGeometryType.MultiPointZ">
            <summary>
            MultiPointZ
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.VectorFieldType">
            <summary>
            Field Types
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.OFTInteger">
            <summary>
            Integer
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.OFTIntegerList">
            <summary>
            Integer List
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.OFTReal">
            <summary>
            Real
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.OFTRealList">
            <summary>
            Real List
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.OFTString">
            <summary>
            String
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.OFTStringList">
            <summary>
            String List
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.OFTWideString">
            <summary>
            Wide String
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.OFTWideStringList">
            <summary>
            Side String List
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.OFTBinary">
            <summary>
            Binary
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.OFTDate">
            <summary>
            Date
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.OFTTime">
            <summary>
            Time
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.OFTDateTime">
            <summary>
            DateTime
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorFieldType.Invalid">
            <summary>
            Invalid
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.VectorGeometryType">
            <summary>
            Vector Geometry Types
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbUnknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbPoint">
            <summary>
            Well Known Binary Point
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbLineString">
            <summary>
            Well Known Binary LineString
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbPolygon">
            <summary>
            Well Known Binary Polygon
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbMultiPoint">
            <summary>
            Well Known Binary MultiPoint
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbMultiLineString">
            <summary>
            Well Known Binary MultiLineString
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbMultiPolygon">
            <summary>
            Well Known Binary MultiPolygon
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbGeometryCollection">
            <summary>
            Well Known Binary Geometry Collection
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbLinearRing">
            <summary>
            Well Known Binary Linear Ring
            /* non-standard, just for createGeometry() */
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbPoint25D">
            <summary>
            Well Known Binary Point with Z value
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbLineString25D">
            <summary>
            Well Known Binary Line String with Z values
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbPolygon25D">
            <summary>
            Well Known Binary Polygon with Z values
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbMultiPoint25D">
            <summary>
            Well Known Binary MultiPoint with Z values
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbMultiLineString25D">
            <summary>
            Well Known Binary LineString with z values
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.VectorGeometryType.wkbMultiPolygon25D">
            <summary>
            Well Known Binary MultiPolygon with z values
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Envelope">
            <summary>
            Defines a rectangular region of the 2D coordinate plane.
            It is often used to represent the bounding box of a <c>Geometry</c>,
            e.g. the minimum and maximum x and y values of the <c>Coordinate</c>s.
            Notice that Envelopes support infinite or half-infinite regions, by using the values of
            <c>Double.PositiveInfinity</c> and <c>Double.NegativeInfinity</c>.
            When Envelope objects are created or initialized,
            the supplies extent values are automatically sorted into the correct order.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IEnvelope">
            <summary>
            Defines a rectangular region of the 2D coordinate plane.
            It is often used to represent the bounding box of a <c>Geometry</c>,
            e.g. the minimum and maximum x and y values of the <c>Coordinate</c>s.
            Notice that Envelopes support infinite or half-infinite regions, by using the values of
            <c>Double.PositiveInfinity</c> and <c>Double.NegativeInfinity</c>.
            When Envelope objects are created or initialized,
            the supplies extent values are automatically sorted into the correct order.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IRectangle">
            <summary>
            An IRectangle is not as specific to being a geometry, and can apply to anything as long as it is willing
            to support a double valued height, width, X and Y value.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IRectangle.Height">
            <summary>
            Gets or sets the difference between the maximum and minimum y values.
            Setting this will change only the minimum Y value, leaving the Top alone
            </summary>
            <returns>max y - min y, or 0 if this is a null <c>Envelope</c>.</returns>
        </member>
        <member name="P:DotSpatial.Topology.IRectangle.Width">
            <summary>
            Gets or Sets the difference between the maximum and minimum x values.
            Setting this will change only the Maximum X value, and leave the minimum X alone
            </summary>
            <returns>max x - min x, or 0 if this is a null <c>Envelope</c>.</returns>
        </member>
        <member name="P:DotSpatial.Topology.IRectangle.X">
            <summary>
            In the precedent set by controls, envelopes support an X value and a width.
            The X value represents the Minimum.X coordinate for this envelope.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IRectangle.Y">
            <summary>
            In the precedent set by controls, envelopes support a Y value and a height.
            the Y value represents the Top of the envelope, (Maximum.Y) and the Height
            represents the span between Maximum and Minimum Y.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IEnvelope.Copy">
            <summary>
            Creates a copy of the current envelope.
            </summary>
            <returns>An IEnvelope Interface that is a duplicate of this envelope</returns>
        </member>
        <member name="M:DotSpatial.Topology.IEnvelope.SetToNull">
            <summary>
            Sets maxx to a value less than minx
            usually, maxx = -1 and minx = 0, maxy = -1 and miny = 0
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IEnvelope.HasM">
            <summary>
            True only if the M coordinates are not NaN and the max is greater than the min.
            </summary>
            <returns>Boolean</returns>
        </member>
        <member name="M:DotSpatial.Topology.IEnvelope.HasZ">
            <summary>
            True only of the Z ordinates are not NaN and the max is greater than the min.
            </summary>
            <returns>Boolean</returns>
        </member>
        <member name="M:DotSpatial.Topology.IEnvelope.Init(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Because the envelope class attempts to protect users from accidentally manipulating
            the minimum/maximum conditions in an undesirable way, the init method should effectively
            initialize the existing envelope based on the new coordinates.  This is how values
            are "Set" for the envelope.  It is expected that this method will do a check
            to prevent larger values from being assigned to "maximum".
            </summary>
            <param name="p1">The first coordinate to test</param>
            <param name="p2">the second coordinate to test</param>
        </member>
        <member name="P:DotSpatial.Topology.IEnvelope.Minimum">
            <summary>
            This is a coordinate defining the minimum bound in any number of dimensions
            as controlled by NumOrdinates.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IEnvelope.Maximum">
            <summary>
            This is a coordinate defining the maximum bound in any number of dimensions
            as controlled by NumOrdinates.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IEnvelope.NumOrdinates">
            <summary>
            Gets the number of ordinates that define both coordinates of this envelope.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IEnvelope.IsNull">
            <summary>
            Returns <c>true</c> if this <c>Envelope</c> is a "null" envelope.
            </summary>
            <returns>
            <c>true</c> if this <c>Envelope</c> is uninitialized
            or is the envelope of the empty point.  This is usually defined
            as having a maxx less than a minx, like maxx = -1 and minx = 0.
            </returns>
        </member>
        <member name="E:DotSpatial.Topology.IEnvelope.EnvelopeChanged">
            <summary>
            Occurs when there is a basic change in the envelope.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.#ctor">
            <summary>
            Creates a null <c>Envelope</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by maximum and minimum values.
            </summary>
            <param name="x1">The first x-value.</param>
            <param name="x2">The second x-value.</param>
            <param name="y1">The first y-value.</param>
            <param name="y2">The second y-value.</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by maximum and minimum values.
            </summary>
            <param name="x1">The first x-value.</param>
            <param name="x2">The second x-value.</param>
            <param name="y1">The first y-value.</param>
            <param name="y2">The second y-value.</param>
            <param name="z1">The first z-value.</param>
            <param name="z2">The second z-value.</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.#ctor(DotSpatial.Topology.IEnvelope)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by an Vector.IEnvelope
            </summary>
            <param name="inEnvelope">The IEnvelope to create an envelope from</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.#ctor(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by two Coordinates.
            </summary>
            <param name="p1">The first Coordinate.</param>
            <param name="p2">The second Coordinate.</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.#ctor(DotSpatial.Topology.Coordinate)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by a single Coordinate.
            </summary>
            <param name="p">The Coordinate.</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.#ctor(System.Double[],System.Double,System.Double)">
            <summary>
            This is a special constructor.  This will not fire the OnEnvelopeChanged
            event, and expects values to be ordered as:
            XMin, XMax, YMin, YMax, ZMin, ZMax, higher dimenions...
            This constructor.
            </summary>
            <param name="extents">The ordinal extents.</param>
            <param name="mMin">The minimum m value.</param>
            <param name="mMax">The max M value.</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.#ctor(System.Double[])">
            <summary>
            This is a special constructor.  This will not fire the OnEnvelopeChanged
            event, and expects values to be ordered as:
            XMin, XMax, YMin, YMax, ZMin, ZMax, higher dimenions...
            This constructor sets M bounds to be 0.
            </summary>
            <param name="extents">The ordinal extents.</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.Init(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Initialize an Envelope of any dimension for a region defined by two Coordinates.
            The number of ordinates (dimension) of the coordinates must match.  M values
            will also be considered.
            </summary>
            <param name="p1">The first Coordinate.</param>
            <param name="p2">The second Coordinate.</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.DoInit">
            <summary>
            This initializes the values without passing any coordinates and creates the default, 2D null envelope.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.DoInit(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            This is an internal method forcing assignments to the internal coordinates
            </summary>
            <param name="min">The coordinate to use for the minimum in X, Y, Z etc.</param>
            <param name="max">The coordinate to use for the maximum in X, Y, Z etc.</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.Init">
            <summary>
            Initialize to a null <c>Envelope</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.Init(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialize an <c>Envelope</c> for a region defined by maximum and minimum values.
            </summary>
            <param name="x1">The first x-value.</param>
            <param name="x2">The second x-value.</param>
            <param name="y1">The first y-value.</param>
            <param name="y2">The second y-value.</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.Init(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            This will set all 3 dimensions.  Be warned, the Z dimensions are just place holders
            for any topology opperations and do not have any true functionality.  Whichever
            is smaller becomes the minimum and whichever is larger becomes the maximum.
            </summary>
            <param name="x1">An X coordinate </param>
            <param name="x2">Another X coordinate</param>
            <param name="y1">A Y coordinate</param>
            <param name="y2">Another Y coordinate</param>
            <param name="z1">A Z coordinate</param>
            <param name="z2">Another Z coordinate</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.Init(DotSpatial.Topology.Coordinate)">
            <summary>
            Initialize an <c>Envelope</c> for a region defined by a single Coordinate.
            </summary>
            <param name="p">The Coordinate.</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.Init(DotSpatial.Topology.IEnvelope)">
            <summary>
            Initialize an <c>Envelope</c> from an existing Envelope.
            </summary>
            <param name="env">The Envelope to initialize from.</param>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.HasM">
            <summary>
            True only if the M coordinates are not NaN and the max is greater than the min.
            </summary>
            <returns>Boolean</returns>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.HasZ">
            <summary>
            True only of the Z ordinates are not NaN and the max is greater than the min.
            </summary>
            <returns>Boolean</returns>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.Clone">
            <summary>
            Creates a copy of the current envelope.
            </summary>
            <returns>An object satisfying ICloneable</returns>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.SetToNull">
            <summary>
            Makes this <c>Envelope</c> a "null" envelope.
            </summary>
            <remarks>Internaly, envelopes that vioate that sacred criteria of min being less than max
            will be counted as a null case</remarks>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.Copy">
            <summary>
            Creates a copy of the current envelope.
            </summary>
            <returns>An IEnvelope Interface that is a duplicate of this envelope</returns>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.Intersects(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Test the point q to see whether it intersects the Envelope
            defined by p1-p2.
            </summary>
            <param name="p1">One extremal point of the envelope.</param>
            <param name="p2">Another extremal point of the envelope.</param>
            <param name="q">Point to test for intersection.</param>
            <returns><c>true</c> if q intersects the envelope p1-p2.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.Intersects(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Test the envelope defined by p1-p2 for intersection
            with the envelope defined by q1-q2
            </summary>
            <param name="p1">One extremal point of the envelope Point.</param>
            <param name="p2">Another extremal point of the envelope Point.</param>
            <param name="q1">One extremal point of the envelope Q.</param>
            <param name="q2">Another extremal point of the envelope Q.</param>
            <returns><c>true</c> if Q intersects Point</returns>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.ToString">
            <summary>
            Generates a string form of this envelope.
            </summary>
            <returns></returns>
            <remarks>This should not be an extension method because it overrides ToString.</remarks>
        </member>
        <member name="M:DotSpatial.Topology.Envelope.OnEnvelopeChanged">
            <summary>
            Fires the EnvelopeChanged event
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Envelope.GeometryType">
            <summary>
            Specifies that this is in fact an envelope
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Envelope.BoundsX">
            <summary>
            Gets the Horizontal boundaries in geographic coordinates
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Envelope.BoundsY">
            <summary>
            Gets the vertical boundaries in geographic coordinates
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Envelope.Minimum">
            <summary>
            Gets the minimum coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Envelope.Maximum">
            <summary>
            Gets the maximum coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Envelope.NumOrdinates">
            <summary>
            Gets the number of ordinates for this envelope.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Envelope.IsNull">
            <summary>
            Returns <c>true</c> if this <c>Envelope</c> is a "null" envelope.
            </summary>
            <returns>
            <c>true</c> if this <c>Envelope</c> is uninitialized
            or is the envelope of the empty point.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.Envelope.Height">
            <summary>
            Gets or sets the difference between the maximum and minimum y values.
            Setting this will only change the _yMin value (leaving the top alone)
            </summary>
            <returns>max y - min y, or 0 if this is a null <c>Envelope</c>.</returns>
            <remarks>To resemble the precedent set by the dot net framework controls, this is left as a property</remarks>
        </member>
        <member name="P:DotSpatial.Topology.Envelope.Width">
            <summary>
            Gets or Sets the difference between the maximum and minimum x values.
            Setting this will change only the Maximum X value, and leave the minimum X alone
            </summary>
            <returns>max x - min x, or 0 if this is a null <c>Envelope</c>.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Envelope.X">
            <summary>
            Gets or sets the Left extent of the envelope, keeping the width the same.
            In the precedent set by controls, envelopes support an X value and a width.
            The X value represents the Minimum.X coordinate for this envelope.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Envelope.Y">
            <summary>
            Gets or sets the Y coordinate for the top of the envelope.  (YMax)
            In the precedent set by controls, envelopes support a Y value and a height.
            the Y value represents the Top of the envelope, (Maximum.Y) and the Height
            represents the span between Maximum and Minimum Y.
            </summary>
        </member>
        <member name="E:DotSpatial.Topology.Envelope.EnvelopeChanged">
            <summary>
            Occurs when there is a basic change in the envelope.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.EnvelopeExt">
            <summary>
            My concept for the Envelope is that there are several methods that are derived calculations.  These are
            so straight forward that it is unlikey that "new" implementations of those derived values will be needed
            or wanted.  However, we want lots of different kinds of things to be able to "become" an envelope
            with a minimum of fuss.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Area(DotSpatial.Topology.IEnvelope)">
            <summary>
            Calculates the area of this envelope.  Because the word Area,
            like Volume, is dimension specific, this method only looks
            at the X and Y ordinates, and requires at least 2 ordinates.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <returns>The 2D area as a double value.</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Border(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets a linear ring built clockwise around the border, starting from the TopLeft.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.BorderSegments(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets an array of 4 line segments working clockwise from the top segment.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Bottom(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets the minY, which is Y - Height.
            </summary>
            <param name="self">The <c>IEnvelope</c> that this calculation is for.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.BottomBorder(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets an ILineSegment from the top right corner to the bottom right corner
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.BottomLeft(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets the bottom left corner of this rectangle as a 2D coordinate.
            </summary>
            <param name="self">The <c>IEnvelope</c> that this calculation is for.</param>
            <returns>An <c>ICoordinate</c> at the lower left corner of this rectangle</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.BottomRight(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets the bottom right corner of this rectangle as a 2D coordinate
            </summary>
            <param name="self">The <c>IEnvelope</c> that this calculation is for.</param>
            <returns>An <c>ICoordinate</c> at the lower right corner of this rectangle</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Center(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets the coordinate defining the center of this envelope
            in all of the dimensions of this envelope.
            </summary>
            <param name="self">The <c>IEnvelope</c> to find the center for</param>
            <returns>An ICoordinate</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Left(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets the left value for this rectangle.  This should be the
            X coordinate, but is added for clarity.
            </summary>
            <param name="self">The <c>IEnvelope</c> that this calculation is for.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.LeftBorder(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets an ILineSegment from the bottom left to the top left corners
            </summary>
            <param name="self">The <c>IEnvelope</c> that is being extended by this method</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Right(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets the right value, which is X + Width.
            </summary>
            <param name="self">The <c>IEnvelope</c> that this calculation is for.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.RightBorder(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets an ILineSegment from the bottom right corner to the bottom left corner
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.ToLinearRing(DotSpatial.Topology.IEnvelope)">
            <summary>
            Converts this envelope into a linear ring.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <returns>A Linear ring describing the border of this envelope.</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.TopBorder(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets an ILineSegment from the top left to the top right corners
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.TopLeft(DotSpatial.Topology.IEnvelope)">
            <summary>
            Calculates the TopLeft 2D coordinate from this envelope.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.ToPolygon(DotSpatial.Topology.IEnvelope)">
            <summary>
            Technically an Evelope object is not actually a geometry.
            This creates a polygon from the extents.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <returns>A Polygon, which technically qualifies as an IGeometry</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.TopRight(DotSpatial.Topology.IEnvelope)">
            <summary>
            Calcualte the TopRight 2D Coordinate from this envelope
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <returns>An ICoordinate in the position of maximum X, Maximum Y</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Zoom(DotSpatial.Topology.IEnvelope,System.Double)">
            <summary>
            Changes the envelope extent by the specified amount relative
            to it's current extent in that dimension (preserving the aspect ratio).
            So Zoom(10) on a 100 unit wide envelope creates a 110 unit wide envlope,
            while Zoom(-10) on a 100 unit wide envelope creates a 90 unit wide envelope.
            Zoom(-100) on an envelope makes it 100% smaller, or effectively a point.
            Tragically, a point cannot be "zoomed" back in, so a check should be used
            to ensure that the envelope is not currently a point before attempting
            to zoom in.
            </summary>
            <param name="self">The IEnvelope that this zoom method modifies</param>
            <param name="percent">
            Positive 50 makes the envelope 50% larger
            Negative 50 makes the envelope 50% smaller
            </param>
            <example>
             perCent = -50 compact the envelope a 50% (make it smaller).
             perCent = 200 enlarge envelope by 2.
            </example>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Union(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Coordinate)">
            <summary>
            Returns a new envelope that is a copy of this envelope, but modified
            to include the specified coordinate.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Union(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.IEnvelope)">
            <summary>
            Calculates the union of the current box and the given box.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.SetCenter(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Coordinate)">
            <summary>
            Moves the envelope to the indicated coordinate.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <param name="center">The new center coordinate.</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.SetCenter(DotSpatial.Topology.IEnvelope,System.Double,System.Double)">
            <summary>
            Resizes the envelope to the indicated point.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <param name="width">The new width.</param>
            <param name="height">The new height.</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.SetCenter(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Coordinate,System.Double,System.Double)">
            <summary>
            Moves and resizes the current envelope.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <param name="center">The new centre coordinate.</param>
            <param name="width">The new width.</param>
            <param name="height">The new height.</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.SetCenter(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            This handles setting the center and scale in N dimensions.  The size is equivalent to the
            span in each dimension, while the center is the central position in each dimension.  The
            envelope will have values in each dimension where either the existing envelope or both the
            specified center and size values have been specified.  If only the existing envelope
            and a size is specified for dimension 3, for example, the existing center will be used.
            </summary>
            <param name="self">The envelope to modify</param>
            <param name="center">The center position.  This can also be null.</param>
            <param name="size">The size (or span) in each dimension.  This can also be null.</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.SetExtents(DotSpatial.Topology.IEnvelope,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Despite the naming of the extents, this will force the larger of the two x values
            to become Xmax etc.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <param name="minX">An X coordinate</param>
            <param name="minY">A Y coordinate</param>
            <param name="minZ">A Z coordinate</param>
            <param name="maxX">Another X coordinate</param>
            <param name="maxY">Another Y coordinate</param>
            <param name="maxZ">Another Z coordinate</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.SetExtents(DotSpatial.Topology.IEnvelope,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            The two dimensional overload for consistency with other code.
            Despite the names, this will force the smallest X coordinate given
            to become maxX.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <param name="minX">An X coordinate</param>
            <param name="minY">A Y coordinate</param>
            <param name="maxX">Another X coordinate</param>
            <param name="maxY">Another Y coordinate</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Top(DotSpatial.Topology.IEnvelope)">
            <summary>
            Gets the maxY value, which should be Y.
            </summary>
            <param name="self">The <c>IEnvelope</c> that this calculation is for.</param>
            <returns>The double value representing the Max Y value of this rectangle</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Translate(DotSpatial.Topology.IEnvelope,System.Double,System.Double)">
            <summary>
            Translates this envelope by given amounts in the X and Y direction.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <param name="shiftX">The amount to translate along the X axis.</param>
            <param name="shiftY">The amount to translate along the Y axis.</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Translate(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Coordinate)">
            <summary>
            Translates the envelope by given amounts up to the minimum dimension between
            the envelope and the shift coordinate.  (e.g., A 2D envelope will only
            be shifted in 2 dimensions because it has no Z, while a 2D coordinate
            can only shift a cube based on the X and Y positions, leaving the Z
            info alone.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <param name="shift"></param>
            <remarks>This does nothing to a "NULL" envelope</remarks>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Overlaps(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.IEnvelope)">
            <summary>
            Overlaps is defined as intersecting, but having some part of each envelope that is also outside
            of the other envelope.  Therefore it would amount to saying "Intersects And Not Contains And Not Within"
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Overlaps(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Coordinate)">
            <summary>
            For a point, or coordinate, this is a degenerate case and
            will simply perform an intersection test instead.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Overlaps(DotSpatial.Topology.IEnvelope,System.Double,System.Double)">
            <summary>
            For a point, or coordinate, this is a degenerate case and
            will simply perform an intersection test instead.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <param name="x">The x coordinate</param>
            <param name="y">The y coordinate</param>
            <returns>Boolean, true if the specified point intersects with this envelope</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Contains(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Coordinate)">
            <summary>
            Evaluates if the specified coordinate is found inside or on the border.
            This will test all the dimensions shared by both the envelope and point.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Contains(DotSpatial.Topology.IEnvelope,System.Double,System.Double)">
            <summary>
            Returns <c>true</c> if the given point lies in or on the envelope.
            </summary>
            <param name="self">The IEnvelope that this is for</param>
            <param name="x"> the x-coordinate of the point which this <c>Envelope</c> is
            being checked for containing.</param>
            <param name="y"> the y-coordinate of the point which this <c>Envelope</c> is
            being checked for containing.</param>
            <returns><c>true</c> if <c>(x, y)</c> lies in the interior or
            on the boundary of this <c>Envelope</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Contains(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.IEnvelope)">
            <summary>
            Returns true if the other <c>IEnvelope</c> is within this envelope in all dimensions.
            If the boundaries touch, this will true.  This will test the number of
            dimensions that is the smallest dimensionality.  This will ignore M values.
            </summary>
            <param name="envelope">The first envelope (this object when extending)</param>
            <param name="other"> the <c>Envelope</c> which this <c>Envelope</c> is being checked for containing.</param>
            <returns><c>true</c> if <c>other</c> is contained in this <c>Envelope</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Distance(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.IEnvelope)">
            <summary>
            Computes the distance between this and another Envelope.
            The distance between overlapping Envelopes is 0.  Otherwise, the
            distance is the hyper Euclidean distance between the closest points.
            M values are ignored, but every dimension is considered, up to
            the minimum of the number of ordinates between the two envelopes.
            Use Distance with a dimension specified to force 2D distance calculations.
            </summary>
            <param name="self">The first envelope (this object when extending)</param>
            <param name="other">The other envelope to calculate the distance to</param>
            <returns>The distance between this and another <c>Envelope</c>.</returns>
            <remarks>Null cases produce a distance of -1</remarks>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Distance2D(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.IEnvelope)">
            <summary>
            Sometimes only two dimensions are important, and the full dimensionality is not needed.
            The Distance 2D performs the same distance check but only in X and Y, regardless
            of how many dimensions exist in the envelopes.  Both envelopes should have at least
            two ordinates however.  (Not a criteria of the Distance() method)
            </summary>
            <param name="self">The first envelope (this object when extending)</param>
            <param name="other">The other envelope to calculate the distance to</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Distance3D(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.IEnvelope)">
            <summary>
            Calculates the distance specifically in 3D, even if the envelope
            exists in higher dimensions.  The NumOrdinates of both envelopes
            must be at least 3.
            </summary>
            <param name="self">The first envelope (this object when extending)</param>
            <param name="other">The other envelope to calculate the distance to</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.ExpandBy(DotSpatial.Topology.IEnvelope,System.Double)">
            <summary>
            Uses the specified distance to expand the envelope by that amount in all dimensions.
            </summary>
            <param name="self"></param>
            <param name="distance"></param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.ExpandBy(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Coordinate)">
            <summary>
            Uses the dimensions of the specified distances coordinate to
            specify the amount to expand the envelopes in each ordinate.
            This will apply the method to the minimum dimensions between
            the distances coordinate and this envelope.  (eg. A 2D
            distances coordinate will not affect Z values in the envelope).
            </summary>
            <param name="self">The first envelope (this object when extending)</param>
            <param name="distances">The distance to expand the envelope.</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.ExpandBy(DotSpatial.Topology.IEnvelope,System.Double,System.Double)">
            <summary>
            Expands this envelope by a given distance in all directions.
            Both positive and negative distances are supported.
            </summary>
            <param name="self">The first envelope (this object when extending)</param>
            <param name="deltaX">The distance to expand the envelope along the the X axis.</param>
            <param name="deltaY">The distance to expand the envelope along the the Y axis.</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.ExpandToInclude(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Coordinate)">
            <summary>
            Enlarges the boundary of the <c>Envelope</c> so that it contains (p).
            Does nothing if (p) is already on or within the boundaries.
            This executes to the minimum of dimensions between p and this envelope.
            </summary>
            <param name="self">The first envelope (this object when extending)</param>
            <param name="p">The Coordinate.</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.ExpandToInclude(DotSpatial.Topology.IEnvelope,System.Double,System.Double)">
            <summary>
            Enlarges the boundary of the <c>Envelope</c> so that it contains
            (x, y). Does nothing if (x, y) is already on or within the boundaries.
            </summary>
            <param name="self">The first envelope (this object when extending)</param>
            <param name="x">The value to lower the minimum x to or to raise the maximum x to.</param>
            <param name="y">The value to lower the minimum y to or to raise the maximum y to.</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.ExpandToInclude(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.IEnvelope)">
            <summary>
            Enlarges the boundary of the <c>Envelope</c> so that it contains
            <c>other</c>. Does nothing if <c>other</c> is wholly on or
            within the boundaries.
            </summary>
            <param name="self">The first envelope (this object when extending)</param>
            <param name="other">the <c>Envelope</c> to merge with.</param>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Intersection(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.ILineSegment)">
            <summary>
            Returns the intersection of the specified segment with this bounding box.  If there is no intersection,
            then this returns null.  If the intersection is a corner, then the LineSegment will be degenerate,
            that is both the coordinates will be the same.  Otherwise, the segment will be returned so that the
            direction is the same as the original segment.
            </summary>
            <param name="self">The IEnvelope to use with this method</param>
            <param name="segment">The LineSegment to intersect.</param>
            <returns>An ILineSegment that is cropped to fit within the bounding box.</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Intersection(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.IEnvelope)">
            <summary>
            Finds an envelope that represents the intersection between this
            envelope and the specified <c>IEnvelope</c>.  The number of dimensions of the
            returned envelope is the maximum of the NumOrdinates between the two envelopes,
            since a 2D envelope will only constrain a cube in 2 dimensions, and allow the
            z bounds to remain unaltered.
            </summary>
            <param name="self">The <c>IEnvelope</c> that is being extended by this method</param>
            <param name="env">An <c>IEnvelope</c> to compare against</param>
            <returns>an <c>IEnvelope</c> that bounds the intersection area</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Intersection(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.IBasicGeometry)">
            <summary>
            Using an envelope intersection has some optimizations by checking against the envelope
            of the geometry.  In the worst case scenario, the envelope crops the geometry, and a new geometry is created.
            This will be much faster if the envelope contains the geometries envelope, however, simply returning
            the original geometry.
            </summary>
            <param name="self">The <c>IEnvelope</c> that is being extended by this method</param>
            <param name="geom">A geometric intersection against the area of this envelope</param>
            <returns>A geometry, cropped to the space of this envelope if necessary.</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Intersects(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Coordinate)">
            <summary>
            Check if the point <c>p</c> overlaps (lies inside) the region of this <c>Envelope</c>.
            </summary>
            <param name="self">The <c>IEnvelope</c> that is being extended by this method</param>
            <param name="p"> the <c>Coordinate</c> to be tested.</param>
            <returns><c>true</c> if the point overlaps this <c>Envelope</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Intersects(DotSpatial.Topology.IEnvelope,System.Double,System.Double)">
            <summary>
            Check if the point <c>(x, y)</c> overlaps (lies inside) the region of this <c>Envelope</c>.
            </summary>
            <param name="self">The <c>IEnvelope</c> that is being extended by this method</param>
            <param name="x"> the x-ordinate of the point.</param>
            <param name="y"> the y-ordinate of the point.</param>
            <returns><c>true</c> if the point overlaps this <c>Envelope</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Intersects(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.ILineSegment)">
            <summary>
            This should only be used if the Intersection is not actually required because it uses the Intersection method
            and returns false if the return value is null.
            </summary>
            <param name="self">The <c>IEnvelope</c> that is being extended by this method</param>
            <param name="segment">The segment to be tested against this envelope.</param>
            <returns>The line segment to compare against.</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnvelopeExt.Intersects(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.IEnvelope)">
            <summary>
            Tests for intersection (any overlap) between the two envelopes.  In cases of unequal
            dimensions, the smaller dimension is used (e.g., if a 2D rectangle doesn't intersect
            a cube in its own plane, this would return false.)
            </summary>
            <param name="self">The <c>IEnvelope</c> that is being extended by this method</param>
            <param name="other"> the <c>Envelope</c> which this <c>Envelope</c> is
            being checked for overlapping.
            </param>
            <returns>
            <c>true</c> if the <c>Envelope</c>s overlap.
            </returns>
        </member>
        <member name="T:DotSpatial.Topology.EnumerableExt">
            <summary>
            EnumerableEM
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.EnumerableExt.CloneList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            cycles through any strong typed collection where the type implements ICLoneable
            and clones each member, inserting that member into the new list.
            </summary>
            <typeparam name="T">The type of the values in the list.</typeparam>
            <param name="original">The original enumerable collection of type T.</param>
            <returns>A deep copy of the list.</returns>
        </member>
        <member name="M:DotSpatial.Topology.EnumerableExt.SafeCastTo``1(System.Object)">
            <summary>
            A Generic Safe Casting method that should simply exist as part of the core framework
            </summary>
            <typeparam name="T">The type of the member to attempt to cast to.</typeparam>
            <param name="obj">The original object to attempt to System.Convert.</param>
            <returns>An output variable of type T.</returns>
        </member>
        <member name="T:DotSpatial.Topology.InsufficientDimensionsException">
            <summary>
            InsufficientDimensionsException
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.InsufficientDimensionsException.#ctor">
            <summary>
            Creates a new instance of InsufficientDimensionsException
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.InsufficientDimensionsException.#ctor(System.String)">
            <summary>
            Creates a new instance of InsufficientDimesionsException, but specifies the name of the argument,
            or a similar string like "both envelopes".
            </summary>
            <param name="argumentName">The string name of the argument to introduce in to exception message</param>
        </member>
        <member name="T:DotSpatial.Topology.FloatVector3">
            <summary>
            IFloatVector3
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.FloatVector3.X">
            <summary>
            X
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.FloatVector3.Y">
            <summary>
            Y
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.FloatVector3.Z">
            <summary>
            Z
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.#ctor(DotSpatial.Topology.CoordinateF)">
            <summary>
            Copies the X, Y and Z values from the CoordinateF without doing a conversion.
            </summary>
            <param name="coord">X, Y Z</param>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates a new FloatVector3 with the specified values
            </summary>
            <param name="xValue">X</param>
            <param name="yValue">Y</param>
            <param name="zValue">Z</param>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.#ctor(DotSpatial.Topology.Coordinate)">
            <summary>
            Uses the X, Y and Z values from the coordinate to create a new FloatVector3
            </summary>
            <param name="coord">The coordinate to obtain X, Y and Z values from</param>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.Equals(System.Object)">
            <summary>
            tests to see if the specified object has the same X, Y and Z values
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.GetHashCode">
            <summary>
            Not sure what I should be doing here since Int can't really contain this much info very well
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.Add(DotSpatial.Topology.FloatVector3,DotSpatial.Topology.FloatVector3)">
            <summary>
            Adds all the scalar members of the the two vectors
            </summary>
            <param name="lhs">Left hand side</param>
            <param name="rhs">Right hand side</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.Add(DotSpatial.Topology.FloatVector3)">
            <summary>
            Adds the specified v
            </summary>
            <param name="vector">A FloatVector3 to add to this vector</param>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.Subtract(DotSpatial.Topology.FloatVector3,DotSpatial.Topology.FloatVector3)">
            <summary>
            Subtracts all the scalar members of the the two vectors
            </summary>
            <param name="lhs">Left hand side</param>
            <param name="rhs">Right hand side</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.Subtract(DotSpatial.Topology.FloatVector3)">
            <summary>
            Subtracts the specified value
            </summary>
            <param name="vector">A FloatVector3</param>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.CrossProduct(DotSpatial.Topology.FloatVector3,DotSpatial.Topology.FloatVector3)">
            <summary>
            Returns the Cross Product of two vectors lhs and V
            </summary>
            <param name="lhs">Vector, the first input vector</param>
            <param name="rhs">Vector, the second input vector</param>
            <returns>A FloatVector3 containing the cross product of lhs and V</returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.Dot(DotSpatial.Topology.FloatVector3,DotSpatial.Topology.FloatVector3)">
            <summary>
            Multiplies all the scalar members of the the two vectors
            </summary>
            <param name="lhs">Left hand side</param>
            <param name="rhs">Right hand side</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.Multiply(DotSpatial.Topology.FloatVector3,System.Single)">
            <summary>
            Multiplies the source vector by a scalar.
            </summary>
            <param name="source"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.Multiply(System.Single)">
            <summary>
            Multiplies this vector by a scalar value.
            </summary>
            <param name="scalar">The scalar to multiply by</param>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.Normalize">
            <summary>
             Normalizes the vectors
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.op_Addition(DotSpatial.Topology.FloatVector3,DotSpatial.Topology.FloatVector3)">
            <summary>
            Adds the vectors lhs and V using vector addition, which adds the corresponding components
            </summary>
            <param name="lhs">One vector to be added</param>
            <param name="rhs">A second vector to be added</param>
            <returns>The sum of the vectors</returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.op_Equality(DotSpatial.Topology.FloatVector3,DotSpatial.Topology.FloatVector3)">
            <summary>
            Tests two float vectors for equality.
            </summary>
            <param name="lhs">The left hand side FloatVector3 to test.</param>
            <param name="rhs">The right hand side FloatVector3 to test.</param>
            <returns>Returns true if X, Y and Z are all equal.</returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.op_Inequality(DotSpatial.Topology.FloatVector3,DotSpatial.Topology.FloatVector3)">
            <summary>
            Tests two float vectors for inequality.
            </summary>
            <param name="lhs">The left hand side FloatVector3 to test.</param>
            <param name="rhs">The right hand side FloatVector3 to test.</param>
            <returns>Returns true if any of X, Y and Z are unequal.</returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.op_ExclusiveOr(DotSpatial.Topology.FloatVector3,DotSpatial.Topology.FloatVector3)">
            <summary>
            Returns the Cross Product of two vectors lhs and rhs
            </summary>
            <param name="lhs">Vector, the first input vector</param>
            <param name="rhs">Vector, the second input vector</param>
            <returns>A FloatVector3 containing the cross product of lhs and V</returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.op_Division(DotSpatial.Topology.FloatVector3,DotSpatial.Topology.FloatVector3)">
            <summary>
            Divides the components of vector lhs by the respective components
            ov vector V and returns the resulting vector.
            </summary>
            <param name="lhs">FloatVector3 Dividend (Numbers to be divided)</param>
            <param name="rhs">FloatVector3 Divisor (Numbers to divide by)</param>
            <returns>A FloatVector3 quotient of lhs and V</returns>
            <remarks>To prevent divide by 0, if a 0 is in V, it will return 0 in the result</remarks>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.op_Division(DotSpatial.Topology.FloatVector3,System.Single)">
            <summary>
            Multiplies each component of vector lhs by the Scalar value
            </summary>
            <param name="lhs">A vector representing the vector to be multiplied</param>
            <param name="scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A FloatVector3 representing the vector product of vector lhs and the Scalar</returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.op_Multiply(DotSpatial.Topology.FloatVector3,DotSpatial.Topology.FloatVector3)">
            <summary>
            Returns the Inner Product also known as the dot product of two vectors, lhs and V
            </summary>
            <param name="lhs">The input vector</param>
            <param name="rhs">The vector to take the inner product against lhs</param>
            <returns>a Double containing the dot product of lhs and V</returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.op_Multiply(System.Single,DotSpatial.Topology.FloatVector3)">
            <summary>
            Multiplies the vectors lhs and V using vector multiplication,
            which adds the corresponding components
            </summary>
            <param name="scalar">A scalar to multpy to the vector</param>
            <param name="rhs">A vector to be multiplied</param>
            <returns>The scalar product for the vectors</returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.op_Multiply(DotSpatial.Topology.FloatVector3,System.Single)">
            <summary>
            Multiplies each component of vector lhs by the Scalar value
            </summary>
            <param name="lhs">A vector representing the vector to be multiplied</param>
            <param name="scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A FloatVector3 representing the vector product of vector lhs and the Scalar</returns>
        </member>
        <member name="M:DotSpatial.Topology.FloatVector3.op_Subtraction(DotSpatial.Topology.FloatVector3,DotSpatial.Topology.FloatVector3)">
            <summary>
            Subtracts FloatVector3 V from FloatVector3 lhs
            </summary>
            <param name="lhs">A FloatVector3 to subtract from</param>
            <param name="rhs">A FloatVector3 to subtract</param>
            <returns>The FloatVector3 difference lhs - V</returns>
        </member>
        <member name="P:DotSpatial.Topology.FloatVector3.Length">
            <summary>
            Gets the length of the vector
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.FloatVector3.LengthSq">
            <summary>
            Gets the square of length of this vector
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.WkbReader">
            <summary>
            Converts a Well-Known Binary byte data to a <c>Geometry</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.#ctor">
            <summary>
            Initialize reader with a standard <c>GeometryFactory</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.#ctor(DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Initialize reader with the given <c>GeometryFactory</c>.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.Read(System.Byte[])">
             <summary>
            
             </summary>
             <param name="data"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.Read(System.IO.Stream)">
             <summary>
            
             </summary>
             <param name="stream"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.Read(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.ReadByteOrder(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.ReadCoordinate(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.ReadRing(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.ReadPoint(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.ReadLineString(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.ReadPolygon(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.ReadMultiPoint(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.ReadMultiLineString(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.ReadMultiPolygon(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbReader.ReadGeometryCollection(System.IO.BinaryReader)">
             <summary>
            
             </summary>
             <param name="reader"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Utilities.WkbReader.Factory">
            <summary>
            <c>Geometry</c> builder.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Geometry">
            <summary>
            Basic implementation of <c>Geometry</c>.
            <c>Clone</c> returns a deep copy of the object.
            <para>
            Binary Predicates:
            Because it is not clear at this time what semantics for spatial
            analysis methods involving <c>GeometryCollection</c>s would be useful,
            <c>GeometryCollection</c>s are not supported as arguments to binary
            predicates (other than <c>ConvexHull</c>) or the <c>Relate</c> method.
            </para>
            <para>
            Set-Theoretic Methods:
            The spatial analysis methods will
            return the most specific class possible to represent the result. If the
            result is homogeneous, a <c>Point</c>, <c>LineString</c>, or
            <c>Polygon</c> will be returned if the result contains a single
            element; otherwise, a <c>MultiPoint</c>, <c>MultiLineString</c>,
            or <c>MultiPolygon</c> will be returned. If the result is
            heterogeneous a <c>GeometryCollection</c> will be returned.
            </para>
            <para>
            Representation of Computed Geometries:
            The SFS states that the result
            of a set-theoretic method is the "point-set" result of the usual
            set-theoretic definition of the operation (SFS 3.2.21.1). However, there are
            sometimes many ways of representing a point set as a <c>Geometry</c>.
            The SFS does not specify an unambiguous representation of a given point set
            returned from a spatial analysis method. One goal of NTS is to make this
            specification precise and unambiguous. NTS will use a canonical form for
            <c>Geometry</c>s returned from spatial analysis methods. The canonical
            form is a <c>Geometry</c> which is simple and noded:
            Simple means that the Geometry returned will be simple according to
            the NTS definition of <c>IsSimple</c>.
            Noded applies only to overlays involving <c>LineString</c>s. It
            means that all intersection points on <c>LineString</c>s will be
            present as endpoints of <c>LineString</c>s in the result.
            This definition implies that non-simple geometries which are arguments to
            spatial analysis methods must be subjected to a line-dissolve process to
            ensure that the results are simple.
            </para>
            <para>
            Constructed Points And The Precision Model:
            The results computed by the set-theoretic methods may
            contain constructed points which are not present in the input <c>Geometry</c>
            s. These new points arise from intersections between line segments in the
            edges of the input <c>Geometry</c>s. In the general case it is not
            possible to represent constructed points exactly. This is due to the fact
            that the coordinates of an intersection point may contain twice as many bits
            of precision as the coordinates of the input line segments. In order to
            represent these constructed points explicitly, NTS must truncate them to fit
            the <c>PrecisionModel</c>.
            Unfortunately, truncating coordinates moves them slightly. Line segments
            which would not be coincident in the exact result may become coincident in
            the truncated representation. This in turn leads to "topology collapses" --
            situations where a computed element has a lower dimension than it would in
            the exact result.
            When NTS detects topology collapses during the computation of spatial
            analysis methods, it will throw an exception. If possible the exception will
            report the location of the collapse.
            </para>
            </summary>
            <remarks>
            <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/> are not overridden, so that when two
            topologically equal Geometries are added to Collections and Dictionaries, they
            remain distinct. This behaviour is desired in many cases.
            </remarks>
        </member>
        <member name="T:DotSpatial.Topology.IGeometry">
            <summary>
            This has the methods and properties associated with any topology
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IRelate">
            <summary>
            Supports the specific methods associated with relationships, usually
            returning a boolean style test if the relationship is true.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IRelate.Contains(DotSpatial.Topology.IGeometry)">
            Contains
            <summary>
            Returns true if other.within(this) returns true.
            </summary>
            <param name="geom">The Geometry with which to compare this Geometry.</param>
            <returns>true if this Geometry contains other.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IRelate.CoveredBy(DotSpatial.Topology.IGeometry)">
            CoveredBy
            <summary>
            Returns <c>true</c> if this geometry is covered by the specified geometry.
            <para>
            The <c>CoveredBy</c> predicate has the following equivalent definitions:
                - Every point of this geometry is a point of the other geometry.
                - The DE-9IM Intersection Matrix for the two geometries is <c>T*F**F***</c> or <c>*TF**F***</c> or <c>**FT*F***</c> or <c>**F*TF***</c>.
                - <c>g.Covers(this)</c> (<c>CoveredBy</c> is the inverse of <c>Covers</c>).
            </para>
            Notice the difference between <c>CoveredBy</c> and <c>Within</c>: <c>CoveredBy</c> is a more inclusive relation.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>.
            <returns><c>true</c> if this <c>Geometry</c> is covered by <paramref name="geom" />.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IRelate.Covers(DotSpatial.Topology.IGeometry)">
            Covers
            <summary>
            Returns <c>true</c> if this geometry covers the specified geometry.
            <para>
            The <c>Covers</c> predicate has the following equivalent definitions:
                - Every point of the other geometry is a point of this geometry.
                - The DE-9IM Intersection Matrix for the two geometries is <c>T*****FF*</c> or <c>*T****FF*</c> or <c>***T**FF*</c> or <c>****T*FF*</c>.
                - <c>g.CoveredBy(this)</c> (<c>Covers</c> is the inverse of <c>CoveredBy</c>).
            </para>
            Notice the difference between <c>Covers</c> and <c>Contains</c>: <c>Covers</c> is a more inclusive relation.
            In particular, unlike <c>Contains</c> it does not distinguish between
            points in the boundary and in the interior of geometries.
            </summary>
            <remarks>
            For most situations, <c>Covers</c> should be used in preference to <c>Contains</c>.
            As an added benefit, <c>Covers</c> is more amenable to optimization, and hence should be more performant.
            </remarks>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns><c>true</c> if this <c>Geometry</c> covers <paramref name="geom" /></returns>
        </member>
        <member name="M:DotSpatial.Topology.IRelate.Crosses(DotSpatial.Topology.IGeometry)">
            Crosses
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is
             T*T****** (for a point and a curve, a point and an area or a line
            and an area) 0******** (for two curves).
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s cross.
            For this function to return <c>true</c>, the <c>Geometry</c>
            s must be a point and a curve; a point and a surface; two curves; or a
            curve and a surface.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IRelate.Disjoint(DotSpatial.Topology.IGeometry)">
            Disjoint
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is  DE-9IM: FF*FF****.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if the two <c>Geometry</c>s are disjoint.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IRelate.Intersects(DotSpatial.Topology.IGeometry)">
            Intersects
            <summary>
            Returns <c>true</c> if <c>disjoint</c> returns false.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if the two <c>Geometry</c>s intersect.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IRelate.Overlaps(DotSpatial.Topology.IGeometry)">
            Overlaps
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is
             T*T***T** (for two points or two surfaces)
             1*T***T** (for two curves).
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s overlap.
            For this function to return <c>true</c>, the <c>Geometry</c>
            s must be two points, two curves or two surfaces.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IRelate.Relate(DotSpatial.Topology.IGeometry,System.String)">
             Relate
             <summary>
             Returns <c>true</c> if the elements in the DE-9IM intersection
             matrix for the two <c>Geometry</c>s match the elements in <c>intersectionPattern</c>
            , which may be:
              0
              1
              2
              T ( = 0, 1 or 2)
              F ( = -1)
              * ( = -1, 0, 1 or 2)
             For more information on the DE-9IM, see the OpenGIS Simple Features
             Specification.
             </summary>
             <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
             <param name="intersectionPattern">The pattern against which to check the intersection matrix for the two <c>Geometry</c>s.</param>
             <returns><c>true</c> if the DE-9IM intersection matrix for the two <c>Geometry</c>s match <c>intersectionPattern</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IRelate.Relate(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns the DE-9IM intersection matrix for the two <c>Geometry</c>s.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns>
            A matrix describing the intersections of the interiors,
            boundaries and exteriors of the two <c>Geometry</c>s.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IRelate.Touches(DotSpatial.Topology.IGeometry)">
            Touches
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is FT*******, F**T***** or F***T****.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s touch;
            Returns false if both <c>Geometry</c>s are points.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IRelate.Within(DotSpatial.Topology.IGeometry)">
            Within
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is T*F**F***.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if this <c>Geometry</c> is within <c>other</c>.</returns>
        </member>
        <member name="T:DotSpatial.Topology.IOverlay">
            <summary>
            An interface for supporting the functions specific to geometry overlay opperations
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IOverlay.Difference(DotSpatial.Topology.IGeometry)">
            Difference
            <summary>
            Returns a <c>Geometry</c> representing the points making up this
            <c>Geometry</c> that do not make up <c>other</c>. This method
            returns the closure of the resultant <c>Geometry</c>.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compute the difference.</param>
            <returns>The point set difference of this <c>Geometry</c> with <c>other</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IOverlay.Intersection(DotSpatial.Topology.IGeometry)">
            Intersection
            <summary>
            Returns a <c>Geometry</c> representing the points shared by this
            <c>Geometry</c> and <c>other</c>.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compute the intersection.</param>
            <returns>The points common to the two <c>Geometry</c>s.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IOverlay.SymmetricDifference(DotSpatial.Topology.IGeometry)">
            SymmetricDifference
            <summary>
            Returns a set combining the points in this <c>Geometry</c> not in
            <c>other</c>, and the points in <c>other</c> not in this
            <c>Geometry</c>. This method returns the closure of the resultant
            <c>Geometry</c>.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compute the symmetric difference.</param>
            <returns>The point set symmetric difference of this <c>Geometry</c> with <c>other</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IOverlay.Union(DotSpatial.Topology.IGeometry)">
            Union
            <summary>
            Returns a <c>Geometry</c> representing all the points in this <c>Geometry</c>
            and <c>other</c>.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compute the union.</param>
            <returns>A set combining the points of this <c>Geometry</c> and the points of <c>other</c>.</returns>
        </member>
        <member name="T:DotSpatial.Topology.IBasicGeometry">
            <summary>
            This is a lightweight version of the components that represent the strictly data related
            commands.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IBasicGeometry.GetBasicGeometryN(System.Int32)">
            <summary>
            This returns the index'th BasicGeometry where index is between 0 and NumGeometries - 1.
            If there is only one geometry, this will return this object.
            </summary>
            <param name="index">An integer index between 0 and NumGeometries - 1 specifying the basic geometry</param>
            <returns>A BasicGeometry representing only the specific sub-geometry specified</returns>
        </member>
        <member name="M:DotSpatial.Topology.IBasicGeometry.ExportToGml">
            <summary>
            Returns the string that is the valid GML markup string.
            </summary>
            <returns>A String containing the valid GML</returns>
        </member>
        <member name="M:DotSpatial.Topology.IBasicGeometry.ToBinary">
            <summary>
            Returns the Well-known Binary representation of this <c>Geometry</c>.
            For a definition of the Well-known Binary format, see the OpenGIS Simple
            Features Specification.
            </summary>
            <returns>The Well-known Binary representation of this <c>Geometry</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IBasicGeometry.ToString">
            ToString
            <summary>
            Returns the Well-known Text representation of this <c>Geometry</c>.
            For a definition of the Well-known Text format, see the OpenGIS Simple
            Features Specification.
            </summary>
            <returns>
            The Well-known Text representation of this <c>Geometry</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IBasicGeometry.UpdateEnvelope">
            <summary>
            Forces the cached envelope to be re-calculated using the coordinates.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IBasicGeometry.Coordinates">
            Coordinates
            <summary>
            Using an IList guarantees that we can access indexed coordinates, but the actual implementation
            can be either in the form of an array or a list.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IBasicGeometry.Envelope">
            <summary>
            Returns this Geometry's bounding box. If this Geometry is the empty point,
            returns an empty Point. If the Geometry is a point, returns a non-empty Point.
            Otherwise, returns a Polygon whose points are (minx, miny), (maxx, miny),
            (maxx, maxy), (minx, maxy), (minx, miny).
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IBasicGeometry.NumGeometries">
            NumGeometries
            <summary>
            Returns the number of Geometries in a Geometry Collection, or 1, if the geometry is not a collection
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IBasicGeometry.NumPoints">
            NumPoints
            <summary>
            Returns the count of this geometry's vertices.  The geometries contained by
            composite geometries must be geometries.  That is, they must implement NumPoints.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IBasicGeometry.GeometryType">
            <summary>
            Clarifies the subtype of geometry in string format in accordance with
            OGC convenction, but most internal identification simply uses
            the type identification.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IBasicGeometry.FeatureType">
            <summary>
            Specifies either a Point, Line, Polygon or Empty feature type for simple flow control
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.Apply(DotSpatial.Topology.ICoordinateFilter)">
            <summary>
            Performs an operation with or on this <c>Geometry</c>'s
            coordinates. If you are using this method to modify the point, be sure
            to call GeometryChanged() afterwards. Notice that you cannot use this
            method to
            modify this Geometry if its underlying CoordinateSequence's Get method
            returns a copy of the Coordinate, rather than the actual Coordinate stored
            (if it even stores Coordinates at all).
            </summary>
            <param name="filter">The filter to apply to this <c>Geometry</c>'s coordinates</param>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.Apply(DotSpatial.Topology.IGeometryFilter)">
            <summary>
            Performs an operation with or on this <c>Geometry</c> and its
            subelement <c>Geometry</c>s (if any).
            Only GeometryCollections and subclasses
            have subelement Geometry's.
            </summary>
            <param name="filter">
            The filter to apply to this <c>Geometry</c> (and
            its children, if it is a <c>GeometryCollection</c>).
            </param>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.Apply(DotSpatial.Topology.IGeometryComponentFilter)">
            <summary>
            Performs an operation with or on this Geometry and its
            component Geometry's. Only GeometryCollections and
            Polygons have component Geometry's; for Polygons they are the LinearRings
            of the shell and holes.
            </summary>
            <param name="filter">The filter to apply to this <c>Geometry</c>.</param>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.Buffer(System.Double)">
            <summary>
            Returns a buffer region around this <c>Geometry</c> having the given width.
            The buffer of a Geometry is the Minkowski sum or difference of the Geometry with a disc of radius <c>distance</c>.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <returns>
            All points whose distance from this <c>Geometry</c>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.Buffer(System.Double,DotSpatial.Topology.BufferStyle)">
            Buffer
            <summary>
            Returns a buffer region around this <c>Geometry</c> having the given width.
            The buffer of a Geometry is the Minkowski sum or difference of the Geometry with a disc of radius <c>distance</c>.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>
            All points whose distance from this <c>Geometry</c>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.Buffer(System.Double,System.Int32)">
            Buffer
            <summary>
            Returns a buffer region around this <c>Geometry</c> having the given
            width and with a specified number of segments used to approximate curves.
            The buffer of a Geometry is the Minkowski sum of the Geometry with
            a disc of radius <c>distance</c>.  Curves in the buffer polygon are
            approximated with line segments.  This method allows specifying the
            accuracy of that approximation.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="quadrantSegments">The number of segments to use to approximate a quadrant of a circle.</param>
            <returns>
            All points whose distance from this <c>Geometry</c>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.Buffer(System.Double,System.Int32,DotSpatial.Topology.BufferStyle)">
            Buffer
            <summary>
            Returns a buffer region around this <c>Geometry</c> having the given
            width and with a specified number of segments used to approximate curves.
            The buffer of a Geometry is the Minkowski sum of the Geometry with
            a disc of radius <c>distance</c>.  Curves in the buffer polygon are
            approximated with line segments.  This method allows specifying the
            accuracy of that approximation.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="quadrantSegments">The number of segments to use to approximate a quadrant of a circle.</param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>
            All points whose distance from this <c>Geometry</c>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.ClearEnvelope">
            <summary>
            Clears any cached envelopes
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.ClosestPoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Given the specified test point, this returns the closest point in this geometry.
            </summary>
            <param name="testPoint"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.ConvexHull">
            ConvexHull
            <summary>
            Returns the smallest convex Polygon that contains all the points in the Geometry. This obviously applies only to Geometry s which contain 3 or more points.
            </summary>
            <returns>the minimum-area convex polygon containing this Geometry's points.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.CompareToSameClass(System.Object)">
            <summary>
            Returns whether this <c>Geometry</c> is greater than, equal to,
            or less than another <c>Geometry</c> having the same class.
            </summary>
            <param name="o">A <c>Geometry</c> having the same class as this <c>Geometry</c>.</param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <c>o</c>, as
            defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.Distance(DotSpatial.Topology.IGeometry)">
            Distance
            <summary>
            Returns the minimum distance between this <c>Geometry</c>
            and the <c>Geometry</c> g.
            </summary>
            <param name="geom">The <c>Geometry</c> from which to compute the distance.</param>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.Equals(DotSpatial.Topology.IGeometry)">
            Equals
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is T*F**FFF*.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if the two <c>Geometry</c>s are equal.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.EqualsExact(DotSpatial.Topology.IGeometry,System.Double)">
            EqualsExact
            <summary>
            Returns true if the two <c>Geometry</c>s are exactly equal,
            up to a specified tolerance.
            Two Geometries are exactly within a tolerance equal iff:
            they have the same class,
            they have the same values of Coordinates,
            within the given tolerance distance, in their internal
            Coordinate lists, in exactly the same order.
            If this and the other <c>Geometry</c>s are
            composites and any children are not <c>Geometry</c>s, returns
            false.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <param name="tolerance">Distance at or below which two Coordinates will be considered equal.</param>
            <returns>
            <c>true</c> if this and the other <c>Geometry</c>
            are of the same class and have equal internal data.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.EqualsExact(DotSpatial.Topology.IGeometry)">
            EqualsExact
            <summary>
            Returns true if the two <c>Geometry</c>s are exactly equal.
            Two Geometries are exactly equal iff:
            they have the same class,
            they have the same values of Coordinates in their internal
            Coordinate lists, in exactly the same order.
            If this and the other <c>Geometry</c>s are
            composites and any children are not <c>Geometry</c>s, returns
            false.
            This provides a stricter test of equality than <c>equals</c>.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if this and the other <c>Geometry</c>
            are of the same class and have equal internal data.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.GeometryChangedAction">
            <summary>
            Notifies this Geometry that its Coordinates have been changed by an external
            party. When GeometryChanged is called, this method will be called for
            this Geometry and its component Geometries.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.GeometryChanged">
            <summary>
            Notifies this Geometry that its Coordinates have been changed by an external
            party (using a CoordinateFilter, for example). The Geometry will flush
            and/or update any information it has cached (such as its Envelope).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.GetGeometryN(System.Int32)">
            GetGeometryN
            <summary>
            Returns an element Geometry from a GeometryCollection,
            or <code>this</code>, if the geometry is not a collection.
            </summary>
            <param name="n">The index of the geometry element.</param>
            <returns>The n'th geometry contained in this geometry.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.IsWithinDistance(DotSpatial.Topology.IGeometry,System.Double)">
            IsWithinDistance
            <summary>
            Tests whether the distance from this <c>Geometry</c>
            to another is less than or equal to a specified value.
            </summary>
            <param name="geom">the Geometry to check the distance to.</param>
            <param name="distance">the distance value to compare.</param>
            <returns><c>true</c> if the geometries are less than <c>distance</c> apart.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.Normalize">
            Normalize
            <summary>
            Converts this <c>Geometry</c> to normal form (or
            canonical form ). Normal form is a unique representation for <c>Geometry</c>
            s. It can be used to test whether two <c>Geometry</c>s are equal
            in a way that is independent of the ordering of the coordinates within
            them. Normal form equality is a stronger condition than topological
            equality, but weaker than pointwise equality. The definitions for normal
            form use the standard lexicographical ordering for coordinates. "Sorted in
            order of coordinates" means the obvious extension of this ordering to
            sequences of coordinates.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IGeometry.ToGmlFeature">
            <summary>
            Returns the feature representation as GML 2.1.1 XML document.
            This XML document is based on <c>Geometry.xsd</c> schema.
            NO features or XLink are implemented here!
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.Area">
            Area
            <summary>
            Returns the area of this Geometry.
            Areal Geometries have a non-zero area.
            They override this function to compute the area.
            Others return 0.0
            </summary>
            <returns>The area of the Geometry.</returns>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.Boundary">
            Boundary
            <summary>
            Returns the boundary, or the empty point if this <c>Geometry</c>
            is empty. For a discussion of this function, see the OpenGIS Simple
            Features Specification. As stated in SFS Section 2.1.13.1, "the boundary
            of a Geometry is a set of Geometries of the next lower dimension."
            </summary>
            <returns>The closure of the combinatorial boundary of this <c>Geometry</c>.</returns>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.BoundaryDimension">
            <summary>
            Returns the dimension of this <c>Geometry</c>s inherent boundary.
            </summary>
            <returns>
            The dimension of the boundary of the class implementing this
            interface, whether or not this object is the empty point. Returns
            <c>Dimension.False</c> if the boundary is the empty point.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.Centroid">
            Centroid
            <summary>
            Computes the centroid of this Geometry.
            The centroid is equal to the centroid of the set of component Geometries of highest
            dimension (since the lower-dimension geometries contribute zero "weight" to the centroid).
            </summary>
            <returns>A Point which is the centroid of this Geometry.</returns>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.Coordinate">
            Coordinate
            <summary>
            Returns a vertex of this Geometry
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.Dimension">
            Dimension
            <summary>
            Gets or sets the DotSpatial.Geometries.Dimensions of this Geometry.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.EnvelopeInternal">
            EnvelopeInternal
            <summary>
            Returns the interior geometry
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.Factory">
            Factory
            <summary>
            Gets the factory which contains the context in whcih this geometry was created
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.InteriorPoint">
            InteriorPoint
            <summary>
            Computes an interior point of this Geometry.  An interior point is guaranteed
            to lie in the interior of the Geometry, if it possible to calculate such a point
            exactly. Otherwise, the point may lie on the boundary of the point.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.IsEmpty">
            IsEmpty
            <summary>
            Returns whether or not the set of points in this geometry is empty
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.IsRectangle">
            IsRectangle
            <summary>
            Essentially is false for anything other than a polygon, which
            does a check to see if the polygon in question is a rectangle.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.IsSimple">
            IsSimple
            <summary>
            Returns false if the Geometry not simple.  Subclasses provide their own definition
            of "simple". If this Geometry is empty, returns true. In general, the SFS specifications
            of simplicity seem to follow the following rule: A Geometry is simple if the only
            self-intersections are at boundary points.  For all empty Geometrys, IsSimple==true.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.IsValid">
            IsValid
            <summary>
            Tests the validity of this Geometry.  Subclasses provide their own definition of "valid"
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.Length">
            Length
            <summary>
            Returns the length of this Geometry.  Linear geometries return their length.
            Areal geometries return their perimeter.  Others return 0.0
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.PrecisionModel">
            <summary>
            There used to be a class for precision model stuff, but for Interface purposes, this will be
            communicated as a an enumeration which can later be converted into a full fledged PrecisionModel.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.Srid">
            SRID
            <summary>
            Gets/Sets the ID of the Spatial Reference System used by the Geometry. NTS supports Spatial Reference
            System information in the simple way defined in the SFS. A Spatial Reference System ID (SRID) is present
            in each Geometry object. Geometry provides basic accessor operations for this field, but no others. The SRID
            is represented as an integer.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometry.UserData">
            UserData
            <summary>
            Gets/Sets the user data object for this point, if any.  A simple scheme for applications to add their own custom
            data to a Geometry.  An example use might be to add an object representing a Coordinate Reference System.
            Notice that user data objects are not present in geometries created by construction methods.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.#ctor">
            <summary>
            Creates a sort of default geometry object from the default geometry factory, or creates
            a new one if one doesn't exist yet.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.#ctor(DotSpatial.Topology.IGeometryFactory)">
             <summary>
            
             </summary>
             <param name="factory"></param>
        </member>
        <member name="F:DotSpatial.Topology.Geometry.SortedClasses">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Geometry.DefaultFactory">
            <summary>
            A predefined <see cref="T:DotSpatial.Topology.GeometryFactory"/> with <see cref="P:DotSpatial.Topology.Geometry.PrecisionModel"/> <c> == </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.Fixed"/>.
            </summary>
            <seealso cref="P:DotSpatial.Topology.GeometryFactory.Default"/>
            <seealso cref="P:DotSpatial.Topology.GeometryFactory.Fixed"/>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.GetGeometryN(System.Int32)">
            <summary>
            Returns an element Geometry from a GeometryCollection,
            or <code>this</code>, if the geometry is not a collection.
            </summary>
            <param name="n">The index of the geometry element.</param>
            <returns>The n'th geometry contained in this geometry.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.GetBasicGeometryN(System.Int32)">
            <summary>
            This returns the index'th BasicGeometry where index is between 0 and NumGeometries - 1.
            If there is only one geometry, this will return this object.
            </summary>
            <param name="index">An integer index between 0 and NumGeometries - 1 specifying the basic geometry</param>
            <returns>A BasicGeometry representing only the specific sub-geometry specified</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Distance(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns the minimum distance between this <c>Geometry</c>
            and the <c>Geometry</c> g.
            </summary>
            <param name="g">The <c>Geometry</c> from which to compute the distance.</param>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.IsWithinDistance(DotSpatial.Topology.IGeometry,System.Double)">
            <summary>
            Tests whether the distance from this <c>Geometry</c>
            to another is less than or equal to a specified value.
            </summary>
            <param name="geom">the Geometry to check the distance to.</param>
            <param name="distance">the distance value to compare.</param>
            <returns><c>true</c> if the geometries are less than <c>distance</c> apart.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.ClosestPoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Given the specified test point, this returns the closest point in this geometry.
            </summary>
            <param name="testPoint"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.GeometryChanged">
            <summary>
            Notifies this Geometry that its Coordinates have been changed by an external
            party (using a CoordinateFilter, for example). The Geometry will flush
            and/or update any information it has cached (such as its Envelope).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.GeometryChangedAction">
            <summary>
            Notifies this Geometry that its Coordinates have been changed by an external
            party. When GeometryChanged is called, this method will be called for
            this Geometry and its component Geometries.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Disjoint(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is FF*FF****.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if the two <c>Geometry</c>s are disjoint.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Touches(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is FT*******, F**T***** or F***T****.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s touch;
            Returns false if both <c>Geometry</c>s are points.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Intersects(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns <c>true</c> if <c>disjoint</c> returns false.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if the two <c>Geometry</c>s intersect.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Crosses(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is
             T*T****** (for a point and a curve, a point and an area or a line
            and an area) 0******** (for two curves).
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s cross.
            For this function to return <c>true</c>, the <c>Geometry</c>
            s must be a point and a curve; a point and a surface; two curves; or a
            curve and a surface.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Within(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is T*F**F***.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if this <c>Geometry</c> is within <c>other</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Overlaps(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is
             T*T***T** (for two points or two surfaces)
             1*T***T** (for two curves).
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s overlap.
            For this function to return <c>true</c>, the <c>Geometry</c>
            s must be two points, two curves or two surfaces.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Covers(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns <c>true</c> if this geometry covers the specified geometry.
            <para>
            The <c>Covers</c> predicate has the following equivalent definitions:
                - Every point of the other geometry is a point of this geometry.
                - The DE-9IM Intersection Matrix for the two geometries is <c>T*****FF*</c> or <c>*T****FF*</c> or <c>***T**FF*</c> or <c>****T*FF*</c>.
                - <c>g.CoveredBy(this)</c> (<c>Covers</c> is the inverse of <c>CoveredBy</c>).
            </para>
            Notice the difference between <c>Covers</c> and <c>Contains</c>: <c>Covers</c> is a more inclusive relation.
            In particular, unlike <c>Contains</c> it does not distinguish between
            points in the boundary and in the interior of geometries.
            </summary>
            <remarks>
            For most situations, <c>Covers</c> should be used in preference to <c>Contains</c>.
            As an added benefit, <c>Covers</c> is more amenable to optimization, and hence should be more performant.
            </remarks>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns><c>true</c> if this <c>Geometry</c> covers <paramref name="g"/></returns>
            <seealso cref="M:DotSpatial.Topology.Geometry.Contains(DotSpatial.Topology.IGeometry)"/>
            <seealso cref="M:DotSpatial.Topology.Geometry.CoveredBy(DotSpatial.Topology.IGeometry)"/>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.CoveredBy(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns <c>true</c> if this geometry is covered by the specified geometry.
            <para>
            The <c>CoveredBy</c> predicate has the following equivalent definitions:
                - Every point of this geometry is a point of the other geometry.
                - The DE-9IM Intersection Matrix for the two geometries is <c>T*F**F***</c> or <c>*TF**F***</c> or <c>**FT*F***</c> or <c>**F*TF***</c>.
                - <c>g.Covers(this)</c> (<c>CoveredBy</c> is the inverse of <c>Covers</c>).
            </para>
            Notice the difference between <c>CoveredBy</c> and <c>Within</c>: <c>CoveredBy</c> is a more inclusive relation.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>.
            <returns><c>true</c> if this <c>Geometry</c> is covered by <paramref name="g"/>.</returns>
            <seealso cref="M:DotSpatial.Topology.Geometry.Within(DotSpatial.Topology.IGeometry)"/>
            <seealso cref="M:DotSpatial.Topology.Geometry.Covers(DotSpatial.Topology.IGeometry)"/>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Relate(DotSpatial.Topology.IGeometry,System.String)">
             <summary>
             Returns <c>true</c> if the elements in the DE-9IM intersection
             matrix for the two <c>Geometry</c>s match the elements in <c>intersectionPattern</c>
            , which may be:
              0
              1
              2
              T ( = 0, 1 or 2)
              F ( = -1)
              * ( = -1, 0, 1 or 2)
             For more information on the DE-9IM, see the OpenGIS Simple Features
             Specification.
             </summary>
             <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
             <param name="intersectionPattern">The pattern against which to check the intersection matrix for the two <c>Geometry</c>s.</param>
             <returns><c>true</c> if the DE-9IM intersection matrix for the two <c>Geometry</c>s match <c>intersectionPattern</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Relate(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns the DE-9IM intersection matrix for the two <c>Geometry</c>s.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns>
            A matrix describing the intersections of the interiors,
            boundaries and exteriors of the two <c>Geometry</c>s.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Equals(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is T*F**FFF*.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if the two <c>Geometry</c>s are equal.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.ToString">
            <summary>
            Returns the Well-known Text representation of this <c>Geometry</c>.
            For a definition of the Well-known Text format, see the OpenGIS Simple
            Features Specification.
            </summary>
            <returns>
            The Well-known Text representation of this <c>Geometry</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.ToBinary">
            <summary>
            Returns the Well-known Binary representation of this <c>Geometry</c>.
            For a definition of the Well-known Binary format, see the OpenGIS Simple
            Features Specification.
            </summary>
            <returns>The Well-known Binary representation of this <c>Geometry</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.ToGmlFeature">
            <summary>
            Returns the feature representation as GML 2.1.1 XML document.
            This XML document is based on <c>Geometry.xsd</c> schema.
            NO features or XLink are implemented here!
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.ExportToGml">
            <summary>
            Returns a GML string for this geometry
            </summary>
            <returns>A String with the GML</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.ConvexHull">
            <summary>
            Returns the smallest convex <c>Polygon</c> that contains all the
            points in the <c>Geometry</c>. This obviously applies only to <c>Geometry</c>
            s which contain 3 or more points.
            </summary>
            <returns>the minimum-area convex polygon containing this <c>Geometry</c>'s points.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Intersection(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns a <c>Geometry</c> representing the points shared by this
            <c>Geometry</c> and <c>other</c>.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compute the intersection.</param>
            <returns>The points common to the two <c>Geometry</c>s.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.UpdateEnvelope">
            <summary>
            Forces the cached envelope to be re-calculated using the coordinates.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.ClearEnvelope">
            <summary>
            Clears any cached envelopes
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Union(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns a <c>Geometry</c> representing all the points in this <c>Geometry</c>
            and <c>other</c>.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compute the union.</param>
            <returns>A set combining the points of this <c>Geometry</c> and the points of <c>other</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Difference(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns a <c>Geometry</c> representing the points making up this
            <c>Geometry</c> that do not make up <c>other</c>. This method
            returns the closure of the resultant <c>Geometry</c>.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compute the difference.</param>
            <returns>The point set difference of this <c>Geometry</c> with <c>other</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.SymmetricDifference(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns a set combining the points in this <c>Geometry</c> not in
            <c>other</c>, and the points in <c>other</c> not in this
            <c>Geometry</c>. This method returns the closure of the resultant
            <c>Geometry</c>.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compute the symmetric difference.</param>
            <returns>The point set symmetric difference of this <c>Geometry</c> with <c>other</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.EqualsExact(DotSpatial.Topology.IGeometry,System.Double)">
            <summary>
            Returns true if the two <c>Geometry</c>s are exactly equal,
            up to a specified tolerance.
            Two Geometries are exactly within a tolerance equal iff:
            they have the same class,
            they have the same values of Coordinates,
            within the given tolerance distance, in their internal
            Coordinate lists, in exactly the same order.
            If this and the other <c>Geometry</c>s are
            composites and any children are not <c>Geometry</c>s, returns
            false.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <param name="tolerance">Distance at or below which two Coordinates will be considered equal.</param>
            <returns>
            <c>true</c> if this and the other <c>Geometry</c>
            are of the same class and have equal internal data.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.EqualsExact(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns true if the two <c>Geometry</c>s are exactly equal.
            Two Geometries are exactly equal iff:
            they have the same class,
            they have the same values of Coordinates in their internal
            Coordinate lists, in exactly the same order.
            If this and the other <c>Geometry</c>s are
            composites and any children are not <c>Geometry</c>s, returns
            false.
            This provides a stricter test of equality than <c>equals</c>.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if this and the other <c>Geometry</c>
            are of the same class and have equal internal data.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Apply(DotSpatial.Topology.ICoordinateFilter)">
            <summary>
            Performs an operation with or on this <c>Geometry</c>'s
            coordinates. If you are using this method to modify the point, be sure
            to call GeometryChanged() afterwards. Notice that you cannot use this
            method to
            modify this Geometry if its underlying CoordinateSequence's Get method
            returns a copy of the Coordinate, rather than the actual Coordinate stored
            (if it even stores Coordinates at all).
            </summary>
            <param name="filter">The filter to apply to this <c>Geometry</c>'s coordinates</param>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Apply(DotSpatial.Topology.IGeometryFilter)">
            <summary>
            Performs an operation with or on this <c>Geometry</c> and its
            subelement <c>Geometry</c>s (if any).
            Only GeometryCollections and subclasses
            have subelement Geometry's.
            </summary>
            <param name="filter">
            The filter to apply to this <c>Geometry</c> (and
            its children, if it is a <c>GeometryCollection</c>).
            </param>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Apply(DotSpatial.Topology.IGeometryComponentFilter)">
            <summary>
            Performs an operation with or on this Geometry and its
            component Geometry's. Only GeometryCollections and
            Polygons have component Geometry's; for Polygons they are the LinearRings
            of the shell and holes.
            </summary>
            <param name="filter">The filter to apply to this <c>Geometry</c>.</param>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.System#ICloneable#Clone">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Normalize">
            <summary>
            Converts this <c>Geometry</c> to normal form (or
            canonical form ). Normal form is a unique representation for <c>Geometry</c>
            s. It can be used to test whether two <c>Geometry</c>s are equal
            in a way that is independent of the ordering of the coordinates within
            them. Normal form equality is a stronger condition than topological
            equality, but weaker than pointwise equality. The definitions for normal
            form use the standard lexicographical ordering for coordinates. "Sorted in
            order of coordinates" means the obvious extension of this ordering to
            sequences of coordinates.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.CompareTo(System.Object)">
            <summary>
            Returns whether this <c>Geometry</c> is greater than, equal to,
            or less than another <c>Geometry</c>.
            If their classes are different, they are compared using the following
            ordering:
                Point (lowest),
                MultiPoint,
                LineString,
                LinearRing,
                MultiLineString,
                Polygon,
                MultiPolygon,
                GeometryCollection (highest).
            If the two <c>Geometry</c>s have the same class, their first
            elements are compared. If those are the same, the second elements are
            compared, etc.
            </summary>
            <param name="o">A <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <c>o</c>, as
            defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.CompareToSameClass(System.Object)">
            <summary>
            Returns whether this <c>Geometry</c> is greater than, equal to,
            or less than another <c>Geometry</c> having the same class.
            </summary>
            <param name="o">A <c>Geometry</c> having the same class as this <c>Geometry</c>.</param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <c>o</c>, as
            defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Buffer(System.Double,System.Int32,DotSpatial.Topology.BufferStyle)">
            <summary>
            Returns a buffer region around this <c>Geometry</c> having the given
            width and with a specified number of segments used to approximate curves.
            The buffer of a Geometry is the Minkowski sum of the Geometry with
            a disc of radius <c>distance</c>.  Curves in the buffer polygon are
            approximated with line segments.  This method allows specifying the
            accuracy of that approximation.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="quadrantSegments">The number of segments to use to approximate a quadrant of a circle.</param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>
            All points whose distance from this <c>Geometry</c>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Buffer(System.Double,System.Int32)">
            <summary>
            Returns a buffer region around this <c>Geometry</c> having the given
            width and with a specified number of segments used to approximate curves.
            The buffer of a Geometry is the Minkowski sum of the Geometry with
            a disc of radius <c>distance</c>.  Curves in the buffer polygon are
            approximated with line segments.  This method allows specifying the
            accuracy of that approximation.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="quadrantSegments">The number of segments to use to approximate a quadrant of a circle.</param>
            <returns>
            All points whose distance from this <c>Geometry</c>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Buffer(System.Double,DotSpatial.Topology.BufferStyle)">
            <summary>
            Returns a buffer region around this <c>Geometry</c> having the given width.
            The buffer of a Geometry is the Minkowski sum or difference of the Geometry with a disc of radius <c>distance</c>.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>
            All points whose distance from this <c>Geometry</c>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Buffer(System.Double)">
            <summary>
            Returns a buffer region around this <c>Geometry</c> having the given width.
            The buffer of a Geometry is the Minkowski sum or difference of the Geometry with a disc of radius <c>distance</c>.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <returns>
            All points whose distance from this <c>Geometry</c>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Contains(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns <c>true</c> if <c>other.within(this)</c> returns <c>true</c>.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if this <c>Geometry</c> contains <c>other</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.FromBasicGeometry(DotSpatial.Topology.IBasicGeometry)">
            <summary>
            This is convenient for casting troublesome basic geometries into fully fledged geometries
            without having to parse them each time.  It uses the constructors, and effectively the default factory.
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.HasNonEmptyElements(DotSpatial.Topology.IGeometry[])">
            <summary>
            Returns true if the array contains any non-empty <c>Geometry</c>s.
            </summary>
            <param name="geometries"> an array of <c>Geometry</c>s; no elements may be <c>null</c></param>
            <returns>
            <c>true</c> if any of the <c>Geometry</c>s
            <c>IsEmpty</c> methods return <c>false</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.HasNullElements(System.Collections.Generic.IEnumerable{DotSpatial.Topology.IBasicGeometry})">
            <summary>
            Returns true if the array contains any <c>null</c> elements.
            </summary>
            <param name="array"> an array to validate.</param>
            <returns><c>true</c> if any of <c>array</c>s elements are <c>null</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.ToText">
            <summary>
            Returns the Well-known Text representation of this <c>Geometry</c>.
            For a definition of the Well-known Text format, see the OpenGIS Simple
            Features Specification.
            </summary>
            <returns>
            The Well-known Text representation of this <c>Geometry</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.OnCopy(DotSpatial.Topology.Geometry)">
            <summary>
            Allows each geometry to control any custom behavior that cannot be solved with MemberwiseClone.
            The Coordinates of the geometry are already duplicated.
            </summary>
            <param name="copy"></param>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.IsEquivalentClass(DotSpatial.Topology.IGeometry)">
             <summary>
             Returns whether the two <c>Geometry</c>s are equal, from the point
             of view of the <c>EqualsExact</c> method. Called by <c>EqualsExact</c>
             . In general, two <c>Geometry</c> classes are considered to be
             "equivalent" only if they are the same class. An exception is <c>LineString</c>
            , which is considered to be equivalent to its subclasses.
             </summary>
             <param name="other">The <c>Geometry</c> with which to compare this <c>Geometry</c> for equality.</param>
             <returns>
             <c>true</c> if the classes of the two <c>Geometry</c>
             s are considered to be equal by the <c>equalsExact</c> method.
             </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.CheckNotGeometryCollection(DotSpatial.Topology.IGeometry)">
            <summary>
            Throws an exception if <c>g</c>'s class is <c>GeometryCollection</c>.
            (Its subclasses do not trigger an exception).
            </summary>
            <param name="g">
            The <c>Geometry</c> to check;
            throws  ArgumentException  if <c>g</c> is a <c>GeometryCollection</c>
            but not one of its subclasses.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.ComputeEnvelopeInternal">
             <summary>
             Returns the minimum and maximum x and y values in this <c>Geometry</c>
            , or a null <c>Envelope</c> if this <c>Geometry</c> is empty.
             Unlike <c>EnvelopeInternal</c>, this method calculates the <c>Envelope</c>
             each time it is called; <c>EnvelopeInternal</c> caches the result
             of this method.
             </summary>
             <returns>
             This <c>Geometry</c>s bounding box; if the <c>Geometry</c>
             is empty, <c>Envelope.IsNull</c> will return <c>true</c>.
             </returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Compare(System.Collections.ArrayList,System.Collections.ArrayList)">
            <summary>
            Returns the first non-zero result of <c>CompareTo</c> encountered as
            the two <c>Collection</c>s are iterated over. If, by the time one of
            the iterations is complete, no non-zero result has been encountered,
            returns 0 if the other iteration is also complete. If <c>b</c>
            completes before <c>a</c>, a positive number is returned; if a
            before b, a negative number.
            </summary>
            <param name="a">The left hand side ArrayList to compare.</param>
            <param name="b">The right hand side ArrayList to compare.</param>
            <returns>The first non-zero <c>compareTo</c> result, if any; otherwise, zero.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Equal(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,System.Double)">
             <summary>
            
             </summary>
             <param name="a"></param>
             <param name="b"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.CreatePointFromInternalCoord(DotSpatial.Topology.Coordinate,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <param name="exemplar"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Intersects(DotSpatial.Topology.IEnvelope)">
            <summary>
            Tests the specified IEnvelope for an intersection with this Geometry
            </summary>
            <param name="env">The IEnvelope to test</param>
            <returns>True if the envelope intersects this geometry</returns>
        </member>
        <member name="M:DotSpatial.Topology.Geometry.Intersects(System.Double,System.Double)">
            <summary>
            Tests the specified location to see if it intersects with this geometry
            </summary>
            <param name="x">The double X coordinate to test</param>
            <param name="y">The double Y coordinate to test</param>
            <returns>Boolean, true if the specified coordinates intersect this geometry</returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.EnvelopeAsGeometry">
            <summary>
            Returns this <c>Geometry</c>s bounding box. If this <c>Geometry</c>
            is the empty point, returns an empty <c>Point</c>. If the <c>Geometry</c>
            is a point, returns a non-empty <c>Point</c>. Otherwise, returns a
            <c>Polygon</c> whose points are (minx, miny), (maxx, miny), (maxx,
            maxy), (minx, maxy), (minx, miny).
            </summary>
            <returns>
            An empty <c>Point</c> (for empty <c>Geometry</c>s), a
            <c>Point</c> (for <c>Point</c>s) or a <c>Polygon</c>
            (in all other cases).
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.ClassSortIndex">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.Factory">
            <summary>
            Gets the factory which contains the context in which this point was created.
            </summary>
            <returns>The factory for this point.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.UserData">
            <summary>
            Gets/Sets the user data object for this point, if any.
            A simple scheme for applications to add their own custom data to a Geometry.
            An example use might be to add an object representing a Coordinate Reference System.
            notice that user data objects are not present in geometries created by
            construction methods.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.Srid">
            <summary>
            Gets/Sets the ID of the Spatial Reference System used by the <c>Geometry</c>.
            NTS supports Spatial Reference System information in the simple way
            defined in the SFS. A Spatial Reference System ID (SRID) is present in
            each <c>Geometry</c> object. <c>Geometry</c> provides basic
            accessor operations for this field, but no others. The SRID is represented
            as an integer.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.GeometryType">
            <summary>
            Clarifies which subtype of geometry we are working with
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.PrecisionModel">
            <summary>
            Returns the <c>PrecisionModel</c> used by the <c>Geometry</c>.
            </summary>
            <returns>
            the specification of the grid of allowable points, for this
            <c>Geometry</c> and all other <c>Geometry</c>s.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.Coordinate">
            <summary>
            Returns a vertex of this <c>Geometry</c>.
            </summary>
            <returns>
            a Coordinate which is a vertex of this <c>Geometry</c>.
            Returns <c>null</c> if this Geometry is empty.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.Coordinates">
            <summary>
            Returns this <c>Geometry</c> s vertices. If you modify the coordinates
            in this array, be sure to call GeometryChanged afterwards.
            The <c>Geometry</c>s contained by composite <c>Geometry</c>s
            must be Geometry's; that is, they must implement <c>Coordinates</c>.
            </summary>
            <returns>The vertices of this <c>Geometry</c>.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.NumPoints">
            <summary>
            Returns the count of this <c>Geometry</c>s vertices. The <c>Geometry</c>
            s contained by composite <c>Geometry</c>s must be
            Geometry's; that is, they must implement <c>NumPoints</c>.
            </summary>
            <returns>The number of vertices in this <c>Geometry</c>.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.NumGeometries">
            <summary>
            Returns the number of Geometryes in a GeometryCollection,
            or 1, if the geometry is not a collection.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.IsSimple">
            <summary>
            Returns false if the <c>Geometry</c> not simple.
            Subclasses provide their own definition of "simple". If
            this <c>Geometry</c> is empty, returns <c>true</c>.
            In general, the SFS specifications of simplicity seem to follow the
            following rule:
             A Geometry is simple if the only self-intersections are at boundary points.
            For all empty <c>Geometry</c>s, <c>IsSimple==true</c>.
            </summary>
            <returns>
            <c>true</c> if this <c>Geometry</c> has any points of
            self-tangency, self-intersection or other anomalous points.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.IsValid">
            <summary>
            Tests the validity of this <c>Geometry</c>.
            Subclasses provide their own definition of "valid".
            </summary>
            <returns><c>true</c> if this <c>Geometry</c> is valid.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.IsEmpty">
            <summary>
            Returns whether or not the set of points in this <c>Geometry</c> is empty.
            </summary>
            <returns><c>true</c> if this <c>Geometry</c> equals the empty point.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.Area">
            <summary>
            Returns the area of this <c>Geometry</c>.
            Areal Geometries have a non-zero area.
            They override this function to compute the area.
            Others return 0.0
            </summary>
            <returns>The area of the Geometry.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.Length">
            <summary>
            Returns the length of this <c>Geometry</c>.
            Linear geometries return their length.
            Areal geometries return their perimeter.
            They override this function to compute the length.
            Others return 0.0
            </summary>
            <returns>The length of the Geometry.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.InteriorPoint">
            <summary>
            Computes an interior point of this <c>Geometry</c>.
            An interior point is guaranteed to lie in the interior of the Geometry,
            if it possible to calculate such a point exactly. Otherwise,
            the point may lie on the boundary of the point.
            </summary>
            <returns>A <c>Point</c> which is in the interior of this Geometry.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.Dimension">
            <summary>
            Returns the dimension of this <c>Geometry</c>.
            </summary>
            <returns>
            The dimension of the class implementing this interface, whether
            or not this object is the empty point.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.BoundaryDimension">
            <summary>
            Returns the dimension of this <c>Geometry</c>s inherent boundary.
            </summary>
            <returns>
            The dimension of the boundary of the class implementing this
            interface, whether or not this object is the empty point. Returns
            <c>Dimension.False</c> if the boundary is the empty point.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.EnvelopeInternal">
             <summary>
             Returns the minimum and maximum x and y values in this <c>Geometry</c>
            , or a null <c>Envelope</c> if this <c>Geometry</c> is empty.
             </summary>
             <returns>
             This <c>Geometry</c>s bounding box; if the <c>Geometry</c>
             is empty, <c>Envelope.IsNull</c> will return <c>true</c>.
             </returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.Envelope">
            <summary>
            Gets the IEnvelope that contains this geometry
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.IsRectangle">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.Boundary">
            <summary>
            Returns the boundary, or the empty point if this <c>Geometry</c>
            is empty. For a discussion of this function, see the OpenGIS Simple
            Features Specification. As stated in SFS Section 2.1.13.1, "the boundary
            of a Geometry is a set of Geometries of the next lower dimension."
            </summary>
            <returns>The closure of the combinatorial boundary of this <c>Geometry</c>.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.Centroid">
            <summary>
            Computes the centroid of this <c>Geometry</c>.
            The centroid is equal to the centroid of the set of component Geometries of highest
            dimension (since the lower-dimension geometries contribute zero "weight" to the centroid).
            </summary>
            <returns>A Point which is the centroid of this Geometry.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Geometry.FeatureType">
            <summary>
            This will be overridden by the specific feature type since this is abstract
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IGeometryComponentFilter">
            <summary>
            <c>Geometry</c> classes support the concept of applying
            an <c>IGeometryComponentFilter</c> filter to the <c>Geometry</c>.
            The filter is applied to every component of the <c>Geometry</c>
            which is itself a <c>Geometry</c>.
            (For instance, all the LinearRings in Polygons are visited.)
            An <c>IGeometryComponentFilter</c> filter can either
            record information about the <c>Geometry</c>
            or change the <c>Geometry</c> in some way.
            <c>IGeometryComponentFilter</c> is an example of the Gang-of-Four Visitor pattern.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryComponentFilter.Filter(DotSpatial.Topology.IGeometry)">
            <summary>
            Performs an operation with or on <c>geom</c>.
            </summary>
            <param name="geom">A <c>Geometry</c> to which the filter is applied.</param>
        </member>
        <member name="T:DotSpatial.Topology.GeometryCollection">
            <summary>
            Basic implementation of <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IGeometryCollection">
            <summary>
            Specific topology functions for Mutigeometry code
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometryCollection.Count">
            <summary>
            Returns the number of geometries contained by this <see cref="T:DotSpatial.Topology.IGeometryCollection"/>.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometryCollection.Item(System.Int32)">
            <summary>
            Returns the iTh <see cref="T:DotSpatial.Topology.IGeometry"/> element in the collection.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.IGeometryCollection.IsHomogeneous">
            <summary>
            Return <c>true</c> if all features in collection are of the same type.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometryCollection.Geometries">
            <summary>
            Gets a System.Array of all the geometries in this collection
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryCollection.Empty">
            <summary>
            Represents an empty <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryCollection._geometries">
            <summary>
            Internal representation of this <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.#ctor(DotSpatial.Topology.IGeometry[])">
             <summary>
            
             </summary>
             <param name="inGeometries">
             The <c>Geometry</c>s for this <c>GeometryCollection</c>,
             or <c>null</c> or an empty array to create the empty
             point. Elements may be empty <c>Geometry</c>s,
             but not <c>null</c>s.
             </param>
             <remarks>
             For create this <see cref="T:DotSpatial.Topology.Geometry"/> is used a standard <see cref="T:DotSpatial.Topology.GeometryFactory"/>
             with <see cref="T:DotSpatial.Topology.PrecisionModel"/> <c> == </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.Floating"/>.
             </remarks>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.#ctor">
            <summary>
            This should only be used by derived classes because it does not actually set the geometries
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.#ctor(DotSpatial.Topology.IGeometryFactory)">
            <summary>
            This should only be used by derived classes because it does not actually set the geometries
            </summary>
            <param name="factory">Specifies the factory that should be used when creating shapes in this multigeometry</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.#ctor(DotSpatial.Topology.IGeometry[],DotSpatial.Topology.IGeometryFactory)">
             <summary>
            
             </summary>
             <param name="inGeometries">
             The <c>Geometry</c>s for this <c>GeometryCollection</c>,
             or <c>null</c> or an empty array to create the empty
             point. Elements may be empty <c>Geometry</c>s,
             but not <c>null</c>s.
             </param>
             <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.#ctor(DotSpatial.Topology.IBasicGeometry,DotSpatial.Topology.IGeometryFactory)">
            <summary>
            If the input geometry is a singular basic geometry, this will become a collection of 1 geometry.
            If the input geometry is a multi- basic geometry, this will simply ensure that each member
            is upgraded to a full geometry.
            </summary>
            <param name="inGeometry"></param>
            <param name="inFactory"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.IBasicGeometry},DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Creates a new Geometry Collection
            </summary>
            <param name="baseGeometries"></param>
            <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.ClosestPoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Given the specified test point, this checks each segment, and will
            return the closest point on the specified segment.
            </summary>
            <param name="testPoint">The point to test.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.GetGeometryN(System.Int32)">
             <summary>
            
             </summary>
             <param name="n"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.GetBasicGeometryN(System.Int32)">
            <summary>
            This returns the index'th BasicGeometry where index is between 0 and NumGeometries - 1.
            If there is only one geometry, this will return this object.
            </summary>
            <param name="index">An integer index between 0 and NumGeometries - 1 specifying the basic geometry</param>
            <returns>A BasicGeometry representing only the specific sub-geometry specified</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.EqualsExact(DotSpatial.Topology.IGeometry,System.Double)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.Apply(DotSpatial.Topology.ICoordinateFilter)">
             <summary>
            
             </summary>
             <param name="filter"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.Apply(DotSpatial.Topology.IGeometryFilter)">
             <summary>
            
             </summary>
             <param name="filter"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.Apply(DotSpatial.Topology.IGeometryComponentFilter)">
             <summary>
            
             </summary>
             <param name="filter"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.Normalize">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.CompareToSameClass(System.Object)">
             <summary>
            
             </summary>
             <param name="o"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.GetEnumerator">
            <summary>
            Returns a <c>GeometryCollectionEnumerator</c>:
            this IEnumerator returns the parent geometry as first element.
            In most cases is more useful the code
            <c>geometryCollectionInstance.Geometries.GetEnumerator()</c>:
            this returns an IEnumerator over geometries composing GeometryCollection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.OnCopy(DotSpatial.Topology.Geometry)">
            <summary>
            Handles the duplication process for geometry collections
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.ComputeEnvelopeInternal">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.Coordinates">
            <summary>
            Collects all coordinates of all subgeometries into an Array.
            Notice that while changes to the coordinate objects themselves
            may modify the Geometries in place, the returned Array as such
            is only a temporary container which is not synchronized back.
            </summary>
            <returns>The collected coordinates.</returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.IsEmpty">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.Dimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.BoundaryDimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.NumGeometries">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.Geometries">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.NumPoints">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.GeometryType">
            <summary>
            Uses an Enumeration to clarify the type of geometry
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.IsSimple">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.Boundary">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.Area">
            <summary>
            Returns the area of this <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.Length">
            <summary>
            Returns the length of this <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.IsHomogeneous">
            <summary>
            Return <c>true</c> if all features in collection are of the same type.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.Item(System.Int32)">
            <summary>
            Returns the iTh element in the collection.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.Count">
            <summary>
            Returns the number of geometries contained by this <see cref="T:DotSpatial.Topology.GeometryCollection"/>.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.Envelope">
            <summary>
            Gets the Envelope that envelops this GeometryCollection
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometryCollection.Enumerator">
            <summary>
            Iterates over all <c>Geometry</c>'s in a <c>GeometryCollection</c>.
            Implements a pre-order depth-first traversal of the <c>GeometryCollection</c>
            (which may be nested). The original <c>GeometryCollection</c> is
            returned as well (as the first object), as are all sub-collections. It is
            simple to ignore the <c>GeometryCollection</c> objects if they are not
            needed.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryCollection.Enumerator._max">
            <summary>
            The number of <c>Geometry</c>s in the the <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryCollection.Enumerator._parent">
            <summary>
            The <c>GeometryCollection</c> being iterated over.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryCollection.Enumerator._atStart">
            <summary>
            Indicates whether or not the first element (the <c>GeometryCollection</c>
            ) has been returned.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryCollection.Enumerator._index">
            <summary>
            The index of the <c>Geometry</c> that will be returned when <c>next</c>
            is called.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryCollection.Enumerator._subcollectionEnumerator">
            <summary>
            The iterator over a nested <c>GeometryCollection</c>, or <c>null</c>
            if this <c>GeometryCollectionIterator</c> is not currently iterating
            over a nested <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.Enumerator.#ctor(DotSpatial.Topology.IGeometryCollection)">
            <summary>
            Constructs an iterator over the given <c>GeometryCollection</c>.
            </summary>
            <param name="parent">
            The collection over which to iterate; also, the first
            element returned by the iterator.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.Enumerator.MoveNext">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollection.Enumerator.Reset">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryCollection.Enumerator.Current">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometryCollectionNotSupportedException">
            <summary>
            A GeometryCollectionNotSupportedException Class
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometryCollectionNotSupportedException.#ctor">
            <summary>
            Creates a new instance of GeometryCollectionNotSupportedException
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometryFactory">
            <summary>
            Supplies a set of utility methods for building Geometry objects from lists
            of Coordinates.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IGeometryFactory">
            <summary>
            Factory for Geometry stuff
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryFactory.BuildGeometry(System.Collections.IList)">
            <summary>
            Generic constructor that parses a list and tries to form a working
            object that implements MapWindow.Interfaces.IGeometry
            </summary>
            <param name="geomList">some list of things</param>
            <returns>An object that implements DotSpatial.Geometries.IGeometry</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryFactory.CreatePoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Method to produce a point given a coordinate
            </summary>
            <param name="coord">An object that implements DotSpatial.Geometries.ICoordinate</param>
            <returns>An object that implements DotSpatial.Geometries.IPoint</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryFactory.CreateMultiLineString(DotSpatial.Topology.IBasicLineString[])">
            <summary>
            Creates a new object that implements DotSpatial.Geometries.MultiLineString
            given an array of objects that implement DotSpatial.Geometries.ILineStringBase
            </summary>
            <param name="lineStrings">The Array of objects that implement DotSpatial.Geometries.IlineStringBase </param>
            <returns>A new MultiLineString that implements IMultiLineString</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryFactory.CreateGeometryCollection(DotSpatial.Topology.IGeometry[])">
            <summary>
            Creates an object that implements DotSpatial.Geometries.IGeometryCollection
            from an array of objects that implement DotSpatial.Geometries.IGeometry
            </summary>
            <param name="geometries">An array of objects that implement DotSpatial.Geometries.IGeometry</param>
            <returns>A new object that implements DotSpatial.Geometries.IGeometryCollection</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryFactory.CreateMultiPolygon(DotSpatial.Topology.IPolygon[])">
            <summary>
            Creates an object that implements DotSpatial.Geometries.IMultiPolygon from an array of
            objects that implement DotSpatial.Geometries.IPolygon
            </summary>
            <param name="polygons">An Array of objects that implement DotSpatial.Geometries.IPolygon</param>
            <returns>An object that implements DotSpatial.Geometries.IMultiPolygon</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryFactory.CreateLinearRing(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Creates an object that implements DotSpatial.Geometries.ILinearRing from an array of DotSpatial.Geometries.ICoordinates
            </summary>
            <param name="coordinates">An array of objects that implement ICoordinate</param>
            <returns>An object that implements DotSpatial.Geometries.ILinearRing</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryFactory.CreateMultiPoint(System.Collections.Generic.IEnumerable{DotSpatial.Topology.ICoordinate})">
            <summary>
            Creates an object that implements DotSpatial.Geometries.IMultiPoint from an array of objects that implement DotSpatial.Geometries.ICoordinate
            </summary>
            <param name="coordinates">An array of objects that implement DotSpatial.Geometries.ICoordinate</param>
            <returns>An object that implements DotSpatial.Geometries.IMultiPoint</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryFactory.CreateMultiPoint(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
            Creates an object that implements DotSpatial.Geometries.IMultiPoint from an array of objects that implement DotSpatial.Geometries.ICoordinate
            </summary>
            <param name="coordinates">An array of objects that implement DotSpatial.Geometries.ICoordinate</param>
            <returns>An object that implements DotSpatial.Geometries.IMultiPoint</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryFactory.CreateLineString(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Creates an object that implements DotSpatial.Geometries.ILineString from an array of objects that implement DotSpatial.Geometries.ICoordinate
            </summary>
            <param name="coordinates">An array of objects that implement DotSpatial.Geometries.ICoordinate</param>
            <returns>A DotSpatial.Geometries.ILineString</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryFactory.CreateGeometry(DotSpatial.Topology.IGeometry)">
            <summary>
            Creates an object that implements DotSpatial.Geometries.IGeometry that is a copy
            of the specified object that implements DotSpatial.Geometries.IGeometry
            </summary>
            <param name="g">An object that implements DotSpatial.Geometries.IGeometry</param>
            <returns>An copy of the original object that implements DotSpatial.Geometries.IGeometry</returns>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryFactory.CreatePolygon(DotSpatial.Topology.ILinearRing,DotSpatial.Topology.ILinearRing[])">
            <summary>
            Creates an object that implements DotSpatial.Geometries.IPolygon given a specified
            DotSpatial.Geometries.ILinearRing shell and an array of
            DotSpatial.Geometries.ILinearRing that represent the holes
            </summary>
            <param name="shell">The outer perimeter of the polygon, represented by an object that implements DotSpatial.Geometries.ILinearRing</param>
            <param name="holes">The interior holes in the polygon, represented by an array of objects that implements DotSpatial.Geometries.ILinearRing</param>
            <returns>An object that implements DotSpatial.Geometries.IPolygon</returns>
        </member>
        <member name="P:DotSpatial.Topology.IGeometryFactory.Floating">
            <summary>
            Floating reference
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometryFactory.FloatingSingle">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometryFactory.Srid">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometryFactory.PrecisionModel">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.IGeometryFactory.CoordinateSequenceFactory">
            <summary>
            CoordinateSequenceFactory that can manufacture a coordinate sequence
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryFactory._default">
            <summary>
            A predefined <see cref="T:DotSpatial.Topology.GeometryFactory"/> with <see cref="P:DotSpatial.Topology.GeometryFactory.PrecisionModel"/> <c> == </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.Floating"/>.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryFactory._floating">
            <summary>
            A predefined <see cref="T:DotSpatial.Topology.GeometryFactory"/> with <see cref="P:DotSpatial.Topology.GeometryFactory.PrecisionModel"/>
            <c> == </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.Floating"/>.
            </summary>
            <remarks>A shortcut for <see cref="P:DotSpatial.Topology.GeometryFactory.Default"/>.</remarks>
        </member>
        <member name="F:DotSpatial.Topology.GeometryFactory._floatingSingle">
            <summary>
            A predefined <see cref="T:DotSpatial.Topology.GeometryFactory"/> with <see cref="P:DotSpatial.Topology.GeometryFactory.PrecisionModel"/>
            <c> == </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.FloatingSingle"/>.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometryFactory._fixed">
            <summary>
            A predefined <see cref="T:DotSpatial.Topology.GeometryFactory"/> with <see cref="P:DotSpatial.Topology.GeometryFactory.PrecisionModel"/>
            <c> == </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.Fixed"/>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.#ctor(DotSpatial.Topology.PrecisionModel,System.Int32,DotSpatial.Topology.ICoordinateSequenceFactory)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            PrecisionModel, spatial-reference ID, and CoordinateSequence implementation.
            </summary>
            <param name="precisionModel"></param>
            <param name="srid"></param>
            <param name="coordinateSequenceFactory"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.#ctor(DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Constructs a GeometryFactory object from any valid IGeometryFactory interface
            </summary>
            <param name="gf"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.#ctor(DotSpatial.Topology.IGeometryFactory,DotSpatial.Topology.ICoordinateSequenceFactory)">
            <summary>
            Constructs a GeometryFactory pertaining to a specific _coordinateSequenceFactory
            using any valid IGeometryFactory and ICoordinateSequenceFactory interface
            </summary>
            <param name="gf">An IGeometryFactory Interface</param>
            <param name="coordinateSequenceFactory">An ICoordianteSequenceFactory interface</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.#ctor(DotSpatial.Topology.ICoordinateSequenceFactory)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            CoordinateSequence implementation, a double-precision floating PrecisionModel and a
            spatial-reference ID of 0.
            </summary>
            <param name="coordinateSequenceFactory"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.#ctor(DotSpatial.Topology.PrecisionModel)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            {PrecisionModel} and the default CoordinateSequence
            implementation.
            </summary>
            <param name="precisionModel">The PrecisionModel to use.</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.#ctor(DotSpatial.Topology.PrecisionModel,System.Int32)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            <c>PrecisionModel</c> and spatial-reference ID, and the default CoordinateSequence
            implementation.
            </summary>
            <param name="precisionModel">The PrecisionModel to use.</param>
            <param name="srid">The SRID to use.</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.#ctor">
            <summary>
            Constructs a GeometryFactory that generates Geometries having a floating
            PrecisionModel and a spatial-reference ID of 0.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.CreatePoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Creates a Point using the given Coordinate; a null Coordinate will create
            an empty Geometry.
            </summary>
            <param name="coordinate"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.CreateMultiLineString(DotSpatial.Topology.IBasicLineString[])">
            <summary>
            Creates a <c>MultiLineString</c> using the given <c>LineStrings</c>; a null or empty
            array will create an empty MultiLineString.
            </summary>
            <param name="lineStrings">LineStrings, each of which may be empty but not null-</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.CreateGeometryCollection(DotSpatial.Topology.IGeometry[])">
            <summary>
            Creates a <c>GeometryCollection</c> using the given <c>Geometries</c>; a null or empty
            array will create an empty GeometryCollection.
            </summary>
            <param name="geometries">Geometries, each of which may be empty but not null.</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.CreateMultiPolygon(DotSpatial.Topology.IPolygon[])">
            <summary>
            Creates a <c>MultiPolygon</c> using the given <c>Polygons</c>; a null or empty array
            will create an empty Polygon. The polygons must conform to the
            assertions specified in the <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features
            Specification for SQL.
            </summary>
            <param name="polygons">Polygons, each of which may be empty but not null.</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.CreateLinearRing(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Creates a <c>LinearRing</c> using the given <c>Coordinates</c>; a null or empty array will
            create an empty LinearRing. The points must form a closed and simple
            linestring. Consecutive points must not be equal.
            </summary>
            <param name="coordinates">An array without null elements, or an empty array, or null.</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.CreateMultiPoint(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
            Creates a MultiPoint using the given Points; a null or empty array will
            create an empty MultiPoint.
            </summary>
            <param name="point">An array without null elements, or an empty array, or null.</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.CreateMultiPoint(System.Collections.Generic.IEnumerable{DotSpatial.Topology.ICoordinate})">
            <summary>
            Creates an object that implements DotSpatial.Geometries.IMultiPoint from an array of objects that implement DotSpatial.Geometries.ICoordinate
            </summary>
            <param name="coordinates">An array of objects that implement DotSpatial.Geometries.ICoordinate</param>
            <returns>An object that implements DotSpatial.Geometries.IMultiPoint</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.CreatePolygon(DotSpatial.Topology.ILinearRing,DotSpatial.Topology.ILinearRing[])">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary and
            interior boundaries.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>, or
            <c>null</c> or an empty <c>LinearRing</c> if
            the empty point is to be created.
            </param>
            <param name="holes">
            The inner boundaries of the new <c>Polygon</c>, or
            <c>null</c> or empty <c>LinearRing</c> s if
            the empty point is to be created.
            </param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.BuildGeometry(System.Collections.IList)">
            <summary>
            Build an appropriate <c>Geometry</c>, <c>MultiGeometry</c>, or
            <c>GeometryCollection</c> to contain the <c>Geometry</c>s in
            it.
            <example>
             If <c>geomList</c> contains a single <c>Polygon</c>,
            the <c>Polygon</c> is returned.
             If <c>geomList</c> contains several <c>Polygon</c>s, a
            <c>MultiPolygon</c> is returned.
             If <c>geomList</c> contains some <c>Polygon</c>s and
            some <c>LineString</c>s, a <c>GeometryCollection</c> is
            returned.
             If <c>geomList</c> is empty, an empty <c>GeometryCollection</c>
            is returned.
            Notice that this method does not "flatten" Geometries in the input, and hence if
            any MultiGeometries are contained in the input a GeometryCollection containing
            them will be returned.
            </example>
            </summary>
            <param name="geomList">The <c>Geometry</c>s to combine.</param>
            <returns>A <c>Geometry</c> of the "smallest", "most type-specific" class that can contain the elements of <c>geomList</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.CreateLineString(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Creates a LineString using the given Coordinates; a null or empty array will
            create an empty LineString. Consecutive points must not be equal.
            </summary>
            <param name="coordinates">An array without null elements, or an empty array, or null.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.CreateGeometry(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
             <returns>
             A clone of g based on a CoordinateSequence created by this
             GeometryFactory's CoordinateSequenceFactory.
             </returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.CreatePointFromInternalCoord(DotSpatial.Topology.Coordinate,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <param name="exemplar"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.ToPointArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="points">The <c>List</c> of Points to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.ToGeometryArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="geometries">The list of <c>Geometry's</c> to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.ToLinearRingArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="linearRings">The <c>List</c> of LinearRings to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.ToLineStringArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="lineStrings">The <c>List</c> of LineStrings to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.ToPolygonArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="polygons">The <c>List</c> of Polygons to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.ToMultiPolygonArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="multiPolygons">The <c>List</c> of MultiPolygons to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.ToMultiLineStringArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="multiLineStrings">The <c>List</c> of MultiLineStrings to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.ToMultiPointArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="multiPoints">The <c>List</c> of MultiPoints to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.ToGeometry(DotSpatial.Topology.IEnvelope)">
            <summary>
            If the <c>Envelope</c> is a null <c>Envelope</c>, returns an
            empty <c>Point</c>. If the <c>Envelope</c> is a point, returns
            a non-empty <c>Point</c>. If the <c>Envelope</c> is a
            rectangle, returns a <c>Polygon</c> whose points are (minx, miny),
            (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny).
            </summary>
            <param name="envelope">The <c>Envelope</c> to convert to a <c>Geometry</c>.</param>
            <returns>
            An empty <c>Point</c> (for null <c>Envelope</c>
            s), a <c>Point</c> (when min x = max x and min y = max y) or a
            <c>Polygon</c> (in all other cases)
            throws a <c>TopologyException</c> if <c>coordinates</c>
            is not a closed linestring, that is, if the first and last coordinates
            are not equal.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.CreateMultiPoint(DotSpatial.Topology.ICoordinateSequence)">
            <summary>
            Creates a MultiPoint using the given CoordinateSequence; a null or empty CoordinateSequence will
            create an empty MultiPoint.
            </summary>
            <param name="coordinates">A CoordinateSequence possibly empty, or null.</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometryFactory.GetDefaultCoordinateSequenceFactory">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometryFactory.Default">
            <summary>
            A default IGeometryFactory.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryFactory.Fixed">
            <summary>
            Returns the Fixed geometry factory
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryFactory.Floating">
            <summary>
            The floating IGeometryFactory
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryFactory.FloatingSingle">
            <summary>
            A floating Single IGeometryFactory
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryFactory.PrecisionModel">
            <summary>
            Returns the PrecisionModel that Geometries created by this factory
            will be associated with.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryFactory.CoordinateSequenceFactory">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometryFactory.Srid">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.GeometryEditor.CoordinateOperation">
            <summary>
            A GeometryEditorOperation which modifies the coordinate list of a <c>Geometry</c>.
            Operates on Geometry subclasses which contains a single coordinate list.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.GeometryEditor.IGeometryEditorOperation">
            <summary>
            A interface which specifies an edit operation for Geometries.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.GeometryEditor">
            <summary>
            Supports creating a new <c>Geometry</c> which is a modification of an existing one.
            Geometry objects are intended to be treated as immutable.
            This class allows you to "modify" a Geometry
            by traversing it and creating a new Geometry with the same overall structure but
            possibly modified components.
            The following kinds of modifications can be made:
            <para>
            The values of the coordinates may be changed.
            Changing coordinate values may make the result Geometry invalid;
            this is not checked by the GeometryEditor.
            </para>
            <para>The coordinate lists may be changed
            (e.g. by adding or deleting coordinates).
            The modifed coordinate lists must be consistent with their original parent component
            (e.g. a LinearRing must always have at least 4 coordinates, and the first and last
            coordinate must be equal).
            </para>
            <para>Components of the original point may be deleted
            (e.g. holes may be removed from a Polygon, or LineStrings removed from a MultiLineString).
            Deletions will be propagated up the component tree appropriately.
            </para>
            Notice that all changes must be consistent with the original Geometry's structure
            (e.g. a Polygon cannot be collapsed into a LineString).
            The resulting Geometry is not checked for validity.
            If validity needs to be enforced, the new Geometry's IsValid should be checked.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.GeometryEditor._factory">
            <summary>
            The factory used to create the modified Geometry.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryEditor.#ctor">
            <summary>
            Creates a new GeometryEditor object which will create
            an edited <c>Geometry</c> with the same {GeometryFactory} as the input Geometry.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryEditor.#ctor(DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Creates a new GeometryEditor object which will create
            the edited Geometry with the given GeometryFactory.
            </summary>
            <param name="factory">The GeometryFactory to create the edited Geometry with.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryEditor.Edit(DotSpatial.Topology.IGeometry,DotSpatial.Topology.Utilities.GeometryEditor.IGeometryEditorOperation)">
            <summary>
            Edit the input <c>Geometry</c> with the given edit operation.
            Clients will create subclasses of GeometryEditorOperation or
            CoordinateOperation to perform required modifications.
            </summary>
            <param name="geometry">The Geometry to edit.</param>
            <param name="operation">The edit operation to carry out.</param>
            <returns>A new <c>Geometry</c> which is the result of the editing.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryEditor.EditPolygon(DotSpatial.Topology.IGeometry,DotSpatial.Topology.Utilities.GeometryEditor.IGeometryEditorOperation)">
             <summary>
            
             </summary>
             <param name="polygon"></param>
             <param name="operation"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryEditor.EditGeometryCollection(DotSpatial.Topology.IGeometry,DotSpatial.Topology.Utilities.GeometryEditor.IGeometryEditorOperation)">
             <summary>
            
             </summary>
             <param name="collection"></param>
             <param name="operation"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.GeometryEditor.CoordinateOperation">
            <summary>
            A GeometryEditorOperation which modifies the coordinate list of a <c>Geometry</c>.
            Operates on Geometry subclasses which contains a single coordinate list.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.GeometryEditor.IGeometryEditorOperation">
            <summary>
            A interface which specifies an edit operation for Geometries.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryEditor.IGeometryEditorOperation.Edit(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Edits a Geometry by returning a new Geometry with a modification.
            The returned Geometry might be the same as the Geometry passed in.
            </summary>
            <param name="geometry">The Geometry to modify.</param>
            <param name="factory">
            The factory with which to construct the modified Geometry
            (may be different to the factory of the input point).
            </param>
            <returns>A new Geometry which is a modification of the input Geometry.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryEditor.CoordinateOperation.Edit(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometryFactory)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <param name="factory"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryEditor.CoordinateOperation.Edit(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},DotSpatial.Topology.IGeometry)">
            <summary>
            Edits the array of <c>Coordinate</c>s from a <c>Geometry</c>.
            </summary>
            <param name="coordinates">The coordinate array to operate on.</param>
            <param name="geometry">The point containing the coordinate list.</param>
            <returns>An edited coordinate array (which may be the same as the input).</returns>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.GmlWriter">
            <summary>
            Writes the GML representation of the features of Topology model.
            Uses GML 2.1.1 <c>Geometry.xsd</c> schema for base for features.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns an <c>XmlReader</c> with feature informations.
            Use <c>XmlDocument.Load(XmlReader)</c> for obtain a <c>XmlDocument</c> to work.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(DotSpatial.Topology.IGeometry,System.IO.Stream)">
            <summary>
            Writes a GML feature into a generic <c>Stream</c>, such a <c>FileStream</c> or other streams.
            </summary>
            <param name="geometry"></param>
            <param name="stream"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(DotSpatial.Topology.Coordinate,System.Xml.XmlTextWriter)">
             <summary>
            
             </summary>
             <param name="coordinate"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Xml.XmlTextWriter)">
             <summary>
            
             </summary>
             <param name="coordinates"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(DotSpatial.Topology.IGeometry,System.Xml.XmlTextWriter)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(DotSpatial.Topology.IPoint,System.Xml.XmlTextWriter)">
             <summary>
            
             </summary>
             <param name="point"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(DotSpatial.Topology.LineString,System.Xml.XmlTextWriter)">
             <summary>
            
             </summary>
             <param name="lineString"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(DotSpatial.Topology.LinearRing,System.Xml.XmlTextWriter)">
             <summary>
            
             </summary>
             <param name="linearRing"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(DotSpatial.Topology.Polygon,System.Xml.XmlTextWriter)">
             <summary>
            
             </summary>
             <param name="polygon"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(DotSpatial.Topology.MultiPoint,System.Xml.XmlTextWriter)">
             <summary>
            
             </summary>
             <param name="multiPoint"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(DotSpatial.Topology.MultiLineString,System.Xml.XmlTextWriter)">
             <summary>
            
             </summary>
             <param name="multiLineString"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(DotSpatial.Topology.MultiPolygon,System.Xml.XmlTextWriter)">
             <summary>
            
             </summary>
             <param name="multiPolygon"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.Write(DotSpatial.Topology.GeometryCollection,System.Xml.XmlTextWriter)">
             <summary>
            
             </summary>
             <param name="geometryCollection"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.GetBytes(DotSpatial.Topology.IGeometry)">
            <summary>
            Sets corrent length for Byte Stream.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.SetByteStreamLength(DotSpatial.Topology.Geometry)">
            <summary>
            Sets corrent length for Byte Stream.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.SetByteStreamLength(DotSpatial.Topology.GeometryCollection)">
             <summary>
            
             </summary>
             <param name="geometryCollection"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.SetByteStreamLength(DotSpatial.Topology.MultiPolygon)">
             <summary>
            
             </summary>
             <param name="multiPolygon"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.SetByteStreamLength(DotSpatial.Topology.MultiLineString)">
             <summary>
            
             </summary>
             <param name="multiLineString"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.SetByteStreamLength(DotSpatial.Topology.MultiPoint)">
             <summary>
            
             </summary>
             <param name="multiPoint"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.SetByteStreamLength(DotSpatial.Topology.Polygon)">
             <summary>
            
             </summary>
             <param name="polygon"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.SetByteStreamLength(DotSpatial.Topology.LineString)">
             <summary>
            
             </summary>
             <param name="lineString"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GmlWriter.SetByteStreamLength(DotSpatial.Topology.Point)">
             <summary>
            
             </summary>
             <param name="point"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Utilities.GmlWriter.NumberFormatter">
            <summary>
            Formatter for double values of coordinates
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IBasicLineString">
            <summary>
            This is the simpler interface to implement
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IBasicPoint">
            <summary>
            This is a BasicGeometry that contains information about a specific point.
            The easier way to do this is have the IPoint inherit the IBasicGeometry
            and the store implementations for ICoordinate.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.ICoordinate">
            <summary>
            Adds any topology functions to the basic Vector ICoordinate
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.ICoordinate.GetHashCode">
            <summary>
            Return HashCode.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinate.M">
            <summary>
            A Measure coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinate.NumOrdinates">
            <summary>
            A 1D coordinate only has a valid X.  A 2D coordinate has X and Y, while a 3D coordinate
            has X, Y, and Z.  Presumably this is open ended and could support higher coordinates,
            but this coordinate is not responsible for storing values beyond its dimension and
            may cause exceptions if a value higher than the dimension is used.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinate.Item(System.Int32)">
            <summary>
            Gets a double value for the specified zero based ordinate.
            </summary>
            <param name="index">The zero based integer ordinate.</param>
            <returns>A double value.</returns>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinate.Values">
            <summary>
            Gets or sets the values as a one dimensional array of doubles.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinate.X">
            <summary>
            The X coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinate.Y">
            <summary>
            The Y coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinate.Z">
            <summary>
            The Z coordinate
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IBasicPolygon">
            <summary>
            This supports some of the basic data-related capabilities of a polygon, but no topology functions.
            Each of these uses the specifically different nomenclature so that the parallel concepts in a
            full Polygon can return the appropriate datatype.  Since Polygon will Implement IPolygonBase, it
            is the responsibility of the developer to perform the necessary casts when returning this
            set from the more complete topology classes.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IBasicPolygon.Holes">
            <summary>
            Gets the list of Interior Rings in the form of ILineStringBase objects
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IBasicPolygon.Shell">
            <summary>
            Gets the exterior ring of the polygon as an ILineStringBase.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IBasicPolygon.NumHoles">
            <summary>
            Gets the count of holes or interior rings
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.ICoordinateF">
            <summary>
            ICoordinateF
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinateF.Xf">
            <summary>
            Gets or sets the X coordinate using a single precision floating point
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinateF.Yf">
            <summary>
            Gets or sets the Y coordinate using a single precision floating point value
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ICoordinateF.Zf">
            <summary>
            Gets or sets the Z coordinate using a single precision floating point value
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.ICoordinateFilter">
            <summary>
            <c>Geometry</c> classes support the concept of applying a
            coordinate filter to every coordinate in the <c>Geometry</c>. A
            coordinate filter can either record information about each coordinate or
            change the coordinate in some way. Coordinate filters implement the
            interface <c>ICoordinateFilter</c>.
            <c>ICoordinateFilter</c> is an example of the Gang-of-Four Visitor pattern.
            Coordinate filters can be
            used to implement such things as coordinate transformations, centroid and
            envelope computation, and many other functions.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.ICoordinateFilter.Filter(DotSpatial.Topology.Coordinate)">
            <summary>
            Performs an operation with or on <c>coord</c>.
            </summary>
            <param name="coord"><c>Coordinate</c> to which the filter is applied.</param>
        </member>
        <member name="T:DotSpatial.Topology.IGeometryFilter">
            <summary>
            <c>GeometryCollection</c> classes support the concept of
            applying a <c>IGeometryFilter</c> to the <c>Geometry</c>.
            The filter is applied to every element <c>Geometry</c>.
            A <c>IGeometryFilter</c> can either record information about the <c>Geometry</c>
            or change the <c>Geometry</c> in some way.
            <c>IGeometryFilter</c> is an example of the Gang-of-Four Visitor pattern.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IGeometryFilter.Filter(DotSpatial.Topology.IGeometry)">
            <summary>
            Performs an operation with or on <c>geom</c>.
            </summary>
            <param name="geom">A <c>Geometry</c> to which the filter is applied.</param>
        </member>
        <member name="T:DotSpatial.Topology.IIntersectionMatrix">
            <summary>
            A Dimensionally Extended Nine-Intersection Model (DE-9IM) matrix. This class
            can used to represent both computed DE-9IM's (like 212FF1FF2) as well as
            patterns for matching them (like T*T******).
            Methods are provided to:
            Set and query the elements of the matrix in a convenient fashion
            convert to and from the standard string representation (specified in
            SFS Section 2.1.13.2).
            Test to see if a matrix matches a given pattern string.
            For a description of the DE-9IM, see the <see href="http://www.opengis.org/techno/specs.htm"/>OpenGIS Simple Features
            Specification for SQL.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.Add(DotSpatial.Topology.IIntersectionMatrix)">
            <summary>
            Adds one matrix to another.
            Addition is defined by taking the maximum dimension value of each position
            in the summand matrices.
            </summary>
            <param name="im">The matrix to add.</param>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.Set(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType,DotSpatial.Topology.DimensionType)">
            <summary>
            Changes the value of one of this <c>IntersectionMatrix</c>s
            elements.
            </summary>
            <param name="row">
            The row of this <c>IntersectionMatrix</c>,
            indicating the interior, boundary or exterior of the first <c>Geometry</c>
            </param>
            <param name="column">
            The column of this <c>IntersectionMatrix</c>,
            indicating the interior, boundary or exterior of the second <c>Geometry</c>
            </param>
            <param name="dimensionValue">
            The new value of the element
            </param>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.Set(System.String)">
            <summary>
            Changes the elements of this <c>IntersectionMatrix</c> to the
            dimension symbols in <c>dimensionSymbols</c>.
            </summary>
            <param name="dimensionSymbols">
            Nine dimension symbols to which to set this <c>IntersectionMatrix</c>
            s elements. Possible values are <c>{T, F, *, 0, 1, 2}</c>
            </param>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.SetAtLeast(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType,DotSpatial.Topology.DimensionType)">
             <summary>
             Changes the specified element to <c>minimumDimensionValue</c> if the
             element is less.
             </summary>
             <param name="row">
             The row of this <c>IntersectionMatrix</c>
            , indicating the interior, boundary or exterior of the first <c>Geometry</c>.
             </param>
             <param name="column">
             The column of this <c>IntersectionMatrix</c>
            , indicating the interior, boundary or exterior of the second <c>Geometry</c>.
             </param>
             <param name="minimumDimensionValue">
             The dimension value with which to compare the
             element. The order of dimension values from least to greatest is
             <c>True, False, Dontcare, 0, 1, 2</c>.
             </param>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.SetAtLeastIfValid(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType,DotSpatial.Topology.DimensionType)">
            <summary>
            If row >= 0 and column >= 0, changes the specified element to <c>minimumDimensionValue</c>
            if the element is less. Does nothing if row is smaller to 0 or column is smaller to 0.
            </summary>
            <param name="row"></param>
            <param name="column"></param>
            <param name="minimumDimensionValue"></param>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.SetAtLeast(System.String)">
            <summary>
            For each element in this <c>IntersectionMatrix</c>, changes the
            element to the corresponding minimum dimension symbol if the element is
            less.
            </summary>
            <param name="minimumDimensionSymbols">
            Nine dimension symbols with which to
            compare the elements of this <c>IntersectionMatrix</c>. The
            order of dimension values from least to greatest is <c>Dontcare, True, False, 0, 1, 2</c>.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.SetAll(DotSpatial.Topology.DimensionType)">
            <summary>
            Changes the elements of this <c>IntersectionMatrix</c> to <c>dimensionValue</c>.
            </summary>
            <param name="dimensionValue">
            The dimension value to which to set this <c>IntersectionMatrix</c>
            s elements. Possible values <c>True, False, Dontcare, 0, 1, 2}</c>.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.Get(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType)">
            <summary>
            Returns the value of one of this <c>IntersectionMatrix</c>s
            elements.
            </summary>
            <param name="row">
            The row of this <c>IntersectionMatrix</c>, indicating
            the interior, boundary or exterior of the first <c>Geometry</c>.
            </param>
            <param name="column">
            The column of this <c>IntersectionMatrix</c>,
            indicating the interior, boundary or exterior of the second <c>Geometry</c>.
            </param>
            <returns>The dimension value at the given matrix position.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.IsDisjoint">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
            FF*FF****.
            </summary>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s related by
            this <c>IntersectionMatrix</c> are disjoint.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.IsIntersects">
            <summary>
            Returns <c>true</c> if <c>isDisjoint</c> returns false.
            </summary>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s related by
            this <c>IntersectionMatrix</c> intersect.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.IsTouches(DotSpatial.Topology.DimensionType,DotSpatial.Topology.DimensionType)">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
            FT*******, F**T***** or F***T****.
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <c>Geometry</c>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>
            s related by this <c>IntersectionMatrix</c> touch; Returns false
            if both <c>Geometry</c>s are points.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.IsCrosses(DotSpatial.Topology.DimensionType,DotSpatial.Topology.DimensionType)">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
             T*T****** (for a point and a curve, a point and an area or a line
            and an area) 0******** (for two curves).
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <c>Geometry</c>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>
            s related by this <c>IntersectionMatrix</c> cross. For this
            function to return <c>true</c>, the <c>Geometry</c>s must
            be a point and a curve; a point and a surface; two curves; or a curve
            and a surface.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.IsWithin">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
            T*F**F***.
            </summary>
            <returns><c>true</c> if the first <c>Geometry</c> is within the second.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.IsContains">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
            T*****FF*.
            </summary>
            <returns><c>true</c> if the first <c>Geometry</c> contains the second.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.IsCovers">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is <c>T*****FF*</c>
            or <c>*T****FF*</c> or <c>***T**FF*</c> or <c>****T*FF*</c>.
            </summary>
            <returns><c>true</c> if the first <c>Geometry</c> covers the second</returns>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.IsEquals(DotSpatial.Topology.DimensionType,DotSpatial.Topology.DimensionType)">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is T*F**FFF*.
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <c>Geometry</c>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>
            s related by this <c>IntersectionMatrix</c> are equal; the
            <c>Geometry</c>s must have the same dimension for this function
            to return <c>true</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.IsOverlaps(DotSpatial.Topology.DimensionType,DotSpatial.Topology.DimensionType)">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
             T*T***T** (for two points or two surfaces)
             1*T***T** (for two curves).
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <c>Geometry</c>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>
            s related by this <c>IntersectionMatrix</c> overlap. For this
            function to return <c>true</c>, the <c>Geometry</c>s must
            be two points, two curves or two surfaces.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.Matches(System.String)">
            <summary>
            Returns whether the elements of this <c>IntersectionMatrix</c>
            satisfies the required dimension symbols.
            </summary>
            <param name="requiredDimensionSymbols">
            Nine dimension symbols with which to
            compare the elements of this <c>IntersectionMatrix</c>. Possible
            values are <c>{T, F, *, 0, 1, 2}</c>.
            </param>
            <returns>
            <c>true</c> if this <c>IntersectionMatrix</c>
            matches the required dimension symbols.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.Transpose">
            <summary>
            Transposes this IntersectionMatrix.
            </summary>
            <returns>This <c>IntersectionMatrix</c> as a convenience,</returns>
        </member>
        <member name="M:DotSpatial.Topology.IIntersectionMatrix.ToString">
            <summary>
            Returns a nine-character <c>String</c> representation of this <c>IntersectionMatrix</c>.
            </summary>
            <returns>
            The nine dimension symbols of this <c>IntersectionMatrix</c>
            in row-major order.
            </returns>
        </member>
        <member name="T:DotSpatial.Topology.ILinearRing">
            <summary>
            A closed, non-self intersecting Linestring
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.ILineString">
            <summary>
            This adds the basic functionality of a
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.ILineString.GetPointN(System.Int32)">
            <summary>
            Retrieves a topologically complete IPoint for the n'th coordinate in the
            0 based index of point values.
            </summary>
            <param name="n">Integer index specifying the point to retrieve</param>
            <returns>IPoint to retrieve</returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineString.Reverse">
            <summary>
            Returns an ILineString that has its coordinates completely reversed
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineString.IsCoordinate(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns true if the given point is a vertex of this <c>LineString</c>.
            </summary>
            <param name="pt">The <c>Coordinate</c> to check.</param>
            <returns><c>true</c> if <c>pt</c> is one of this <c>LineString</c>'s vertices.</returns>
        </member>
        <member name="P:DotSpatial.Topology.ILineString.StartPoint">
            <summary>
            Gets a topologically complete IPoint for the first coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ILineString.EndPoint">
            <summary>
            Gets a topologically complete IPoint for the last coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ILineString.IsClosed">
            <summary>
            If the first coordinate is the same as the final coordinate, then the
            linestring is closed.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ILineString.IsRing">
            <summary>
            If the coordinates listed for the linestring are both closed and simple then
            they qualify as a linear ring.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ILineString.Angle">
            <summary>
            Returns the value of the angle between the <see cref="P:DotSpatial.Topology.ILineString.StartPoint"/>
            and the <see cref="P:DotSpatial.Topology.ILineString.EndPoint"/>.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.ILineSegment">
            <summary>
            Represents a line segment defined by two <c>Coordinate</c>s.
            Provides methods to compute various geometric properties
            and relationships of line segments.
            This class is designed to be easily mutable (to the extent of
            having its contained points public).
            This supports a common pattern of reusing a single LineSegment
            object as a way of computing segment properties on the
            segments defined by arrays or lists of <c>Coordinate</c>s.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.ILineSegmentBase">
            <summary>
            This is a low-level place holder for a linestring with only two points.
            This does not inherit geometry (Use ILineString for those features).
            The Idea is that this provides just enough information to communicate
            the definition of a LineSegment.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ILineSegmentBase.P1">
            <summary>
            The first of two coordinates that defines the segment
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ILineSegmentBase.P0">
            <summary>
            The second of two endpoints that defines the segment
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.GetCoordinate(System.Int32)">
            <summary>
            Returns an ICoordinate for the point specified by index i.
            </summary>
            <param name="i">Integer point index.  0 returns the first point, 1 returns the second.</param>
            <returns>ICoordinate</returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.SetCoordinates(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Sets the two coordinates to match the coordinates in the specified ILineSegment
            </summary>
            <param name="ls"></param>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.SetCoordinates(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Sets the two coordinates of this ILineString based on the ICoordinate
            values passed.
            </summary>
            <param name="p0">An ICoordinate that specifies the startpoint of the segment</param>
            <param name="p1">An ICoordinate that specifies the location of the endpoint of the segment</param>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.OrientationIndex(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Determines the orientation of a LineSegment relative to this segment.
            The concept of orientation is specified as follows:
            Given two line segments A and L,
            A is to the left of a segment L if A lies wholly in the
            closed half-plane lying to the left of L
            A is to the right of a segment L if A lies wholly in the
            closed half-plane lying to the right of L
            otherwise, A has indeterminate orientation relative to L. This
            happens if A is collinear with L or if A crosses the line determined by L.
            </summary>
            <param name="seg">The <c>LineSegment</c> to compare.</param>
            <returns>
            1 if <c>seg</c> is to the left of this segment,
            -1 if <c>seg</c> is to the right of this segment,
            0 if <c>seg</c> has indeterminate orientation relative to this segment.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.Reverse">
            <summary>
            Reverses the direction of the line segment.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.Normalize">
            <summary>
            Puts the line segment into a normalized form.
            This is useful for using line segments in maps and indexes when
            topological equality rather than exact equality is desired.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.Distance(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Computes the distance between this line segment and another one.
            </summary>
            <param name="ls"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.Distance(DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the distance between this line segment and a point.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.DistancePerpendicular(DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the perpendicular distance between the (infinite) line defined
            by this line segment and a point.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.ProjectionFactor(DotSpatial.Topology.Coordinate)">
            <summary>
            Compute the projection factor for the projection of the point p
            onto this <c>LineSegment</c>. The projection factor is the constant k
            by which the vector for this segment must be multiplied to
            equal the vector for the projection of p.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.Project(DotSpatial.Topology.Coordinate)">
            <summary>
            Compute the projection of a point onto the line determined
            by this line segment.
            Notice that the projected point
            may lie outside the line segment.  If this is the case,
            the projection factor will lie outside the range [0.0, 1.0].
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.Project(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Project a line segment onto this line segment and return the resulting
            line segment.  The returned line segment will be a subset of
            the target line line segment.  This subset may be null, if
            the segments are oriented in such a way that there is no projection.
            Notice that the returned line may have zero length (i.e. the same endpoints).
            This can happen for instance if the lines are perpendicular to one another.
            </summary>
            <param name="seg">The line segment to project.</param>
            <returns>The projected line segment, or <c>null</c> if there is no overlap.</returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.ClosestPoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the closest point on this line segment to another point.
            </summary>
            <param name="p">The point to find the closest point to.</param>
            <returns>
            A Coordinate which is the closest point on the line segment to the point p.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.ClosestPoints(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Computes the closest points on a line segment.
            </summary>
            <param name="line"></param>
            <returns>
            A pair of Coordinates which are the closest points on the line segments.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.Intersection(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Computes an intersection point between two segments, if there is one.
            There may be 0, 1 or many intersection points between two segments.
            If there are 0, null is returned. If there is 1 or more, a single one
            is returned (chosen at the discretion of the algorithm).  If
            more information is required about the details of the intersection,
            the {RobustLineIntersector} class should be used.
            </summary>
            <param name="line"></param>
            <returns> An intersection point, or <c>null</c> if there is none.</returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.Intersection(DotSpatial.Topology.Envelope)">
            <summary>
            Performs an intersection of this line segment with the specified envelope
            </summary>
            <param name="inEnvelope">The envelope to compare against</param>
            <returns>An ILineSegment, or null if there is no intersection.</returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.Intersects(DotSpatial.Topology.Envelope)">
            <summary>
            Determines if any portion of this segment intersects the specified extent.
            </summary>
            <param name="inEnvelope">The</param>
            <returns>Boolean, true if this line segment intersects the specified envelope</returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.EqualsTopologically(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Returns <c>true</c> if <c>other</c> is
            topologically equal to this LineSegment (e.g. irrespective
            of orientation).
            </summary>
            <param name="other">
            A <c>LineSegment</c> with which to do the comparison.
            </param>
            <returns>
            <c>true</c> if <c>other</c> is a <c>LineSegment</c>
            with the same values for the x and y ordinates.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.ILineSegment.ToString">
            <summary>
            Returns Well Known Text for a LineString with just 2 points
            </summary>
            <returns>String: Well Known Text</returns>
        </member>
        <member name="P:DotSpatial.Topology.ILineSegment.Length">
            <summary>
            Computes the length of the line segment.
            </summary>
            <returns>The length of the line segment.</returns>
        </member>
        <member name="P:DotSpatial.Topology.ILineSegment.IsHorizontal">
            <summary>
            Tests whether the segment is horizontal.
            </summary>
            <returns><c>true</c> if the segment is horizontal.</returns>
        </member>
        <member name="P:DotSpatial.Topology.ILineSegment.IsVertical">
            <summary>
            Tests whether the segment is vertical.
            </summary>
            <returns><c>true</c> if the segment is vertical.</returns>
        </member>
        <member name="P:DotSpatial.Topology.ILineSegment.Angle">
            <returns>
            The angle this segment makes with the x-axis (in radians).
            </returns>
        </member>
        <member name="T:DotSpatial.Topology.IMatrix">
            <summary>
            IMatrix
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IMatrix.Multiply(DotSpatial.Topology.IMatrix)">
            <summary>
            Performs the matrix multiplication against the specified matrix
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.IMatrix.NumRows">
            <summary>
            Gets the number of rows
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IMatrix.NumColumns">
            <summary>
            Gets the number of columns
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IMatrix4">
            <summary>
            Operations on 3D vectors can be carried out using a 4D Matrix.  This interface
            provides access to methods that are specific to 3D vector opperations.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IMatrixD">
            <summary>
            IMatrix4
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IMatrixD.Multiply(System.Double)">
            <summary>
            Multiplies every value in the specified n x m matrix by the specified double inScalar.
            </summary>
            <param name="inScalar">The double precision floating point to multiply all the members against</param>
            <returns>A new n x m matrix</returns>
        </member>
        <member name="M:DotSpatial.Topology.IMatrixD.Multiply(DotSpatial.Topology.IMatrixD)">
            <summary>
            This replaces the underlying general multiplication with a more specific type.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.IMatrixD.Values">
            <summary>
            Gets or sets the values for this matrix of double precision coordinates
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IMatrix4.RotateZ(System.Double)">
            <summary>
            Specifies amount to rotate
            </summary>
            <param name="degrees"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.IMatrix4.RotateX(System.Double)">
            <summary>
            Multiplies the current matrix by a rotation matrix corresponding
            to the specified angle to create rotation in the Z direction.
            </summary>
            <param name="degrees">The angle to rotate in degrees.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.IMatrix4.RotateY(System.Double)">
            <summary>
            Rotates the current matrix around the Y axis by multiplying the
            current matrix by a rotation matrix.
            </summary>
            <param name="degrees"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.IMatrix4.Translate(System.Double,System.Double,System.Double)">
            <summary>
            Translates the matrix by the specified amount in each of the directions
            by multiplying by a translation matrix created from the specified values.
            </summary>
            <param name="x">The translation in the X coordinate</param>
            <param name="y">The translation in the Y coordinate</param>
            <param name="z">The translation in the Z coordinate</param>
            <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.IMultiLineString">
            <summary>
            A type specific Geometry collection that deals with ILineStrings
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IMultiLineString.Item(System.Int32)">
            <summary>
            Changes the default indexer to assume that the members are ILineString instead of simply IGeometry
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.IMultiPoint">
            <summary>
            A type specific MultiGeometry that specifically uses points
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IMultiPoint.Item(System.Int32)">
            <summary>
            Gets or sets the point that resides at the specified index
            </summary>
            <param name="index">A zero-based integer index specifying the point to get or set</param>
            <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.IMultiPolygon">
            <summary>
            specifically for handling
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IntersectionMatrix">
            <summary>
            A Dimensionally Extended Nine-Intersection Model (DE-9IM) matrix. This class
            can used to represent both computed DE-9IM's (like 212FF1FF2) as well as
            patterns for matching them (like T*T******).
            Methods are provided to:
            Set and query the elements of the matrix in a convenient fashion
            convert to and from the standard string representation (specified in
            SFS Section 2.1.13.2).
            Test to see if a matrix matches a given pattern string.
            For a description of the DE-9IM, see the <see href="http://www.opengis.org/techno/specs.htm"/>OpenGIS Simple Features
            Specification for SQL.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.IntersectionMatrix._matrix">
            <summary>
            Internal representation of this <c>IntersectionMatrix</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.#ctor">
            <summary>
            Creates an <c>IntersectionMatrix</c> with <c>Null</c> location values.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.#ctor(System.String)">
            <summary>
            Creates an <c>IntersectionMatrix</c> with the given dimension
            symbols.
            </summary>
            <param name="elements">A string of nine dimension symbols in row major order.</param>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.#ctor(DotSpatial.Topology.IntersectionMatrix)">
            <summary>
            Creates an <c>IntersectionMatrix</c> with the same elements as
            <c>other</c>.
            </summary>
            <param name="other">An <c>IntersectionMatrix</c> to copy.</param>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.Add(DotSpatial.Topology.IIntersectionMatrix)">
            <summary>
            Adds one matrix to another.
            Addition is defined by taking the maximum dimension value of each position
            in the summand matrices.
            </summary>
            <param name="im">The matrix to add.</param>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.Set(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType,DotSpatial.Topology.DimensionType)">
            <summary>
            Changes the value of one of this <c>IntersectionMatrix</c>s
            elements.
            </summary>
            <param name="row">
            The row of this <c>IntersectionMatrix</c>,
            indicating the interior, boundary or exterior of the first <c>Geometry</c>
            </param>
            <param name="column">
            The column of this <c>IntersectionMatrix</c>,
            indicating the interior, boundary or exterior of the second <c>Geometry</c>
            </param>
            <param name="dimensionValue">
            The new value of the element
            </param>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.Set(System.String)">
            <summary>
            Changes the elements of this <c>IntersectionMatrix</c> to the
            dimension symbols in <c>dimensionSymbols</c>.
            </summary>
            <param name="dimensionSymbols">
            Nine dimension symbols to which to set this <c>IntersectionMatrix</c>
            s elements. Possible values are <c>{T, F, *, 0, 1, 2}</c>
            </param>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.SetAtLeast(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType,DotSpatial.Topology.DimensionType)">
             <summary>
             Changes the specified element to <c>minimumDimensionValue</c> if the
             element is less.
             </summary>
             <param name="row">
             The row of this <c>IntersectionMatrix</c>
            , indicating the interior, boundary or exterior of the first <c>Geometry</c>.
             </param>
             <param name="column">
             The column of this <c>IntersectionMatrix</c>
            , indicating the interior, boundary or exterior of the second <c>Geometry</c>.
             </param>
             <param name="minimumDimensionValue">
             The dimension value with which to compare the
             element. The order of dimension values from least to greatest is
             <c>True, False, Dontcare, 0, 1, 2</c>.
             </param>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.SetAtLeastIfValid(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType,DotSpatial.Topology.DimensionType)">
            <summary>
            If row >= 0 and column >= 0, changes the specified element to <c>minimumDimensionValue</c>
            if the element is less. Does nothing if row is smaller to 0 or column is smaller to 0.
            </summary>
            <param name="row"></param>
            <param name="column"></param>
            <param name="minimumDimensionValue"></param>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.SetAtLeast(System.String)">
            <summary>
            For each element in this <c>IntersectionMatrix</c>, changes the
            element to the corresponding minimum dimension symbol if the element is
            less.
            </summary>
            <param name="minimumDimensionSymbols">
            Nine dimension symbols with which to
            compare the elements of this <c>IntersectionMatrix</c>. The
            order of dimension values from least to greatest is <c>Dontcare, True, False, 0, 1, 2</c>.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.SetAll(DotSpatial.Topology.DimensionType)">
            <summary>
            Changes the elements of this <c>IntersectionMatrix</c> to <c>dimensionValue</c>.
            </summary>
            <param name="dimensionValue">
            The dimension value to which to set this <c>IntersectionMatrix</c>
            s elements. Possible values <c>True, False, Dontcare, 0, 1, 2}</c>.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.Get(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType)">
            <summary>
            Returns the value of one of this <c>IntersectionMatrix</c>s
            elements.
            </summary>
            <param name="row">
            The row of this <c>IntersectionMatrix</c>, indicating
            the interior, boundary or exterior of the first <c>Geometry</c>.
            </param>
            <param name="column">
            The column of this <c>IntersectionMatrix</c>,
            indicating the interior, boundary or exterior of the second <c>Geometry</c>.
            </param>
            <returns>The dimension value at the given matrix position.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.IsDisjoint">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
            FF*FF****.
            </summary>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s related by
            this <c>IntersectionMatrix</c> are disjoint.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.IsIntersects">
            <summary>
            Returns <c>true</c> if <c>isDisjoint</c> returns false.
            </summary>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s related by
            this <c>IntersectionMatrix</c> intersect.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.IsTouches(DotSpatial.Topology.DimensionType,DotSpatial.Topology.DimensionType)">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
            FT*******, F**T***** or F***T****.
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <c>Geometry</c>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>
            s related by this <c>IntersectionMatrix</c> touch; Returns false
            if both <c>Geometry</c>s are points.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.IsCrosses(DotSpatial.Topology.DimensionType,DotSpatial.Topology.DimensionType)">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
             T*T****** (for a point and a curve, a point and an area or a line
            and an area) 0******** (for two curves).
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <c>Geometry</c>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>
            s related by this <c>IntersectionMatrix</c> cross. For this
            function to return <c>true</c>, the <c>Geometry</c>s must
            be a point and a curve; a point and a surface; two curves; or a curve
            and a surface.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.IsWithin">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
            T*F**F***.
            </summary>
            <returns><c>true</c> if the first <c>Geometry</c> is within the second.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.IsContains">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
            T*****FF*.
            </summary>
            <returns><c>true</c> if the first <c>Geometry</c> contains the second.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.IsCovers">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is <c>T*****FF*</c>
            or <c>*T****FF*</c> or <c>***T**FF*</c> or <c>****T*FF*</c>.
            </summary>
            <returns><c>true</c> if the first <c>Geometry</c> covers the second</returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.IsEquals(DotSpatial.Topology.DimensionType,DotSpatial.Topology.DimensionType)">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is T*F**FFF*.
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <c>Geometry</c>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>
            s related by this <c>IntersectionMatrix</c> are equal; the
            <c>Geometry</c>s must have the same dimension for this function
            to return <c>true</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.IsOverlaps(DotSpatial.Topology.DimensionType,DotSpatial.Topology.DimensionType)">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
             T*T***T** (for two points or two surfaces)
             1*T***T** (for two curves).
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <c>Geometry</c>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>
            s related by this <c>IntersectionMatrix</c> overlap. For this
            function to return <c>true</c>, the <c>Geometry</c>s must
            be two points, two curves or two surfaces.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.Matches(System.String)">
            <summary>
            Returns whether the elements of this <c>IntersectionMatrix</c>
            satisfies the required dimension symbols.
            </summary>
            <param name="requiredDimensionSymbols">
            Nine dimension symbols with which to
            compare the elements of this <c>IntersectionMatrix</c>. Possible
            values are <c>{T, F, *, 0, 1, 2}</c>.
            </param>
            <returns>
            <c>true</c> if this <c>IntersectionMatrix</c>
            matches the required dimension symbols.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.Transpose">
            <summary>
            Transposes this IntersectionMatrix.
            </summary>
            <returns>This <c>IntersectionMatrix</c> as a convenience, </returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.ToString">
            <summary>
            Returns a nine-character <c>String</c> representation of this <c>IntersectionMatrix</c>.
            </summary>
            <returns>
            The nine dimension symbols of this <c>IntersectionMatrix</c>
            in row-major order.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.Matches(DotSpatial.Topology.DimensionType,System.Char)">
            <summary>
            Returns true if the dimension value satisfies the dimension symbol.
            </summary>
            <param name="actualDimensionValue">
            A number that can be stored in the <c>IntersectionMatrix</c>
            . Possible values are <c>True, False, Dontcare, 0, 1, 2</c>.
            </param>
            <param name="requiredDimensionSymbol">
            A character used in the string
            representation of an <c>IntersectionMatrix</c>. Possible values
            are <c>T, F, *, 0, 1, 2</c>.
            </param>
            <returns>
            True if the dimension symbol encompasses
            the dimension value.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.IntersectionMatrix.Matches(System.String,System.String)">
            <summary>
            Returns true if each of the actual dimension symbols satisfies the
            corresponding required dimension symbol.
            </summary>
            <param name="actualDimensionSymbols">
            Nine dimension symbols to validate.
            Possible values are <c>T, F, *, 0, 1, 2</c>.
            </param>
            <param name="requiredDimensionSymbols">
            Nine dimension symbols to validate
            against. Possible values are <c>T, F, *, 0, 1, 2</c>.
            </param>
            <returns>
            True if each of the required dimension
            symbols encompass the corresponding actual dimension symbol.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.IntersectionMatrix.Item(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType)">
            <summary>
            See methods Get(int, int) and Set(int, int, int value)
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IPoint">
            <summary>
            This combines the full Topology.Geometry functions to the complete Vector.IPoint set of functions.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IPolygon">
            <summary>
            Full powered topology style Polygon
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IPolygon.GetInteriorRingN(System.Int32)">
            <summary>
            Gets a specific <see cref="T:DotSpatial.Topology.ILinearRing">ILinearRing</see> identified by the 0 based index n
            </summary>
            <param name="n">A 0 based integer index enumerating the rings</param>
            <returns><see cref="T:DotSpatial.Topology.ILinearRing">ILinearRing</see> outlining the n'th hole in the polygon</returns>
        </member>
        <member name="P:DotSpatial.Topology.IPolygon.Shell">
            <summary>
            Gets the <see cref="T:DotSpatial.Topology.ILinearRing">ILinearRing</see> for the Exterior Ring.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IPolygon.Holes">
            <summary>
            Gets the System.Array of <see cref="T:DotSpatial.Topology.ILinearRing">ILinearRing</see>s that make up the holes in the polygon.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.ISize">
            <summary>
            ISize interface for expressing a length in the X, Y or Z directions
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ISize.XSize">
            <summary>
            Gets or sets the size in the x direction or longitude
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ISize.YSize">
            <summary>
            Gets or sets the size in the y direction or latitude
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.ISize.ZSize">
            <summary>
            Gets or sets the size in the z direction or altitude
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IVector">
            <summary>
            Contains a magnitude and direction
            Supports more fundamental calculations than LineSegment, rather than topological functions
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IVector.TransformCoordinate(DotSpatial.Topology.IMatrix4)">
            <summary>
            Transforms a point that has 3 dimensions by multiplying it by the
            specified 3 x 3 matrix in the upper left, but treats the
            bottom row as supplying the translation coordinates.
            </summary>
            <param name="transformMatrix"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.ToMatrix">
            <summary>
            Rotations and transformations work by applying matrix mathematics,
            so this creates a 1 x 4 version of this vector.  The 4th value
            is always 1, and allows for the translation terms to work.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.Norm2">
            <summary>
            Returns the square of the distance of the vector without taking the square root
            This is the same as doting the vector with itself
            </summary>
            <returns>Double, the square of the distance between the vectors</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.ToPoint">
            <summary>
            Assuming the vector starts at the origin of 0, 0, 0, this function returns
            a Point representing the tip of the vector.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IVector.ToCoordinate">
            <summary>
            Converts this vector to a coordinate by assuming that the X, Y and Z values
            are the X, Y and Z values of the locaiton.
            </summary>
            <returns>An ICoordinate</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.ToLineSegment">
            <summary>
            Returns a new segment from this vector, where the StartPoint is 0, 0, 0
            and the End Point is the tip of this vector
            </summary>
            <returns>An implementation of ILineSegment</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.Normalize">
            <summary>
            Normalizes the vector.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IVector.Cross(DotSpatial.Topology.IVector)">
            <summary>
            Returns the cross product of this vector with the specified vector V
            </summary>
            <param name="v">The vector to perform a cross product against</param>
            <returns>A vector result from the inner product</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.Dot(DotSpatial.Topology.IVector)">
            <summary>
            Returns the dot product of this vector with V2
            </summary>
            <param name="v">The vector to perform an inner product against</param>
            <returns>A Double result from the inner product</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.Intersects(DotSpatial.Topology.IVector)">
            <summary>
            Compares the values of each element, and if all the elements are equal, returns true.
            </summary>
            <param name="v">The vector to compare against this vector.</param>
            <returns>Boolean, true if all the elements have the same value.</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.Equals(DotSpatial.Topology.IVector)">
            <summary>
            Override  for definition of equality for vectors
            </summary>
            <param name="v">A vector to compare with</param>
            <returns>true if the X, Y, and Z coordinates are all equal</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.Subtract(DotSpatial.Topology.IVector)">
            <summary>
            Subtracts each element of V from each element of this vector
            </summary>
            <param name="v">Vector, the vector to subtract from this vector</param>
            <returns>A vector result from the subtraction</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.Add(DotSpatial.Topology.IVector)">
            <summary>
            Adds each of the elements of V to the elements of this vector
            </summary>
            <param name="v">Vector, the vector to add to this vector</param>
            <returns>A vector result from the addition</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.Multiply(System.Double)">
            <summary>
            Returns the scalar product of this vector against a scalar
            </summary>
            <param name="scalar">Double, a value to multiply against all the members of this vector</param>
            <returns>A vector multiplied by the scalar</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.RotateX(System.Double)">
            <summary>
            Rotates the vector about the X axis as though the tail of the vector were at the origin
            </summary>
            <param name="degrees">The angle in degrees to rotate counter-clockwise when looking at the origin from the positive axis.</param>
            <returns>A new IVector that has been rotated</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.RotateY(System.Double)">
            <summary>
            Rotates the vector about the Y axis as though the tail of the vector were at the origin
            </summary>
            <param name="degrees">The angle in degrees to rotate counter-clockwise when looking at the origin from the positive axis.</param>
            <returns>A new IVector that has been rotated</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVector.RotateZ(System.Double)">
            <summary>
            Rotates the vector about the Z axis as though the tail of the vector were at the origin
            </summary>
            <param name="degrees">The angle in degrees to rotate counter-clockwise when looking at the origin from the positive axis.</param>
            <returns>A new IVector that has been rotated</returns>
        </member>
        <member name="P:DotSpatial.Topology.IVector.Length">
            <summary>
            The Euclidean distance from the origin to the tip of the 3 dimensional vector
            Setting the magntiude won't change the direction.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IVector.Length2D">
            <summary>
            Returns the magnitude of the projection of the vector onto the X-Y plane
            Setting this magnitude will not affect Z, which should be adjusted separately
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IVector.Phi">
            <summary>
            Obtains the angle above the X-Y plane.  Positive towards positive Z.
            Values are in radians from -Pi/2 to Pi/2
            Setting this value when no magnitude exists results in a unit vector with angle phi in the X direction.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.IVector.Theta">
            <summary>
            Represents the angle in the X-Y plane.  0 along the positive X axis, and increasing counterclockwise
            Values are in Radians.  Setting this value when no X-Y magnitude exists results in a unit vector
            between X and Y, but does not affect Z, so you may have something other than a unit vector in 3-D.
            Set theta before phi in order to obtain a unit vector in 3-D space.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.IVectorD">
            <summary>
            Vector
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IVectorD.Add(DotSpatial.Topology.Vector)">
            <summary>
            Adds each of the elements of V to the elements of this vector
            </summary>
            <param name="v">Vector, the vector to add to this vector</param>
            <returns>A vector result from the addition</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVectorD.Cross(DotSpatial.Topology.Vector)">
            <summary>
            Returns the cross product of this vector with the specified vector V
            </summary>
            <param name="v">The vector to perform a cross product against</param>
            <returns>A vector result from the inner product</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVectorD.Dot(DotSpatial.Topology.Vector)">
            <summary>
            Returns the dot product of this vector with V2
            </summary>
            <param name="v">The vector to perform an inner product against</param>
            <returns>A Double result from the inner product</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVectorD.Multiply(System.Double)">
            <summary>
            Returns the scalar product of this vector against a scalar
            </summary>
            <param name="scalar">Double, a value to multiply against all the members of this vector</param>
            <returns>A vector multiplied by the scalar</returns>
        </member>
        <member name="M:DotSpatial.Topology.IVectorD.Normalize">
            <summary>
            Normalizes the vector.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.IVectorD.Subtract(DotSpatial.Topology.Vector)">
            <summary>
            Subtracts each element of V from each element of this vector
            </summary>
            <param name="v">Vector, the vector to subtract from this vector</param>
            <returns>A vector result from the subtraction</returns>
        </member>
        <member name="P:DotSpatial.Topology.IVectorD.Length">
            <summary>
            The Euclidean distance from the origin to the tip of the 3 dimensional vector
            Setting the magntiude won't change the direction.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Depth">
            <summary>
            A Depth object records the topological depth of the sides
            of an Edge for up to two Geometries.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.Depth.NULL">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.DepthAtLocation(DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="location"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.GetDepth(System.Int32,DotSpatial.Topology.GeometriesGraph.PositionType)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.SetDepth(System.Int32,DotSpatial.Topology.GeometriesGraph.PositionType,System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <param name="depthValue"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.GetLocation(System.Int32,DotSpatial.Topology.GeometriesGraph.PositionType)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.Add(System.Int32,DotSpatial.Topology.GeometriesGraph.PositionType,DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <param name="location"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.IsNull">
            <summary>
            A Depth object is null (has never been initialized) if all depths are null.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.IsNull(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.IsNull(System.Int32,DotSpatial.Topology.GeometriesGraph.PositionType)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.Add(DotSpatial.Topology.GeometriesGraph.Label)">
             <summary>
            
             </summary>
             <param name="lbl"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.GetDelta(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.Normalize">
            <summary>
            Normalize the depths for each point, if they are non-null.
            A normalized depth
            has depth values in the set { 0, 1 }.
            Normalizing the depths
            involves reducing the depths by the same amount so that at least
            one of them is 0.  If the remaining value is > 0, it is set to 1.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Depth.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Depth.Item(System.Int32,DotSpatial.Topology.GeometriesGraph.PositionType)">
            <summary>
            Calls GetDepth and SetDepth.
            </summary>
            <param name="geomIndex"></param>
            <param name="posIndex"></param>
            <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.DirectedEdge">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.EdgeEnd">
            <summary>
            Models the end of an edge incident on a node.
            EdgeEnds have a direction
            determined by the direction of the ray from the initial
            point to the next point.
            EdgeEnds are IComparable under the ordering
            "a has a greater angle with the x-axis than b".
            This ordering is used to sort EdgeEnds around a node.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.EdgeEnd._edge">
            <summary>
            The parent edge of this edge end.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEnd.#ctor(DotSpatial.Topology.GeometriesGraph.Edge)">
             <summary>
            
             </summary>
             <param name="inEdge"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEnd.#ctor(DotSpatial.Topology.GeometriesGraph.Edge,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="p0"></param>
             <param name="p1"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEnd.#ctor(DotSpatial.Topology.GeometriesGraph.Edge,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.GeometriesGraph.Label)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="p0"></param>
             <param name="p1"></param>
             <param name="inLabel"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEnd.CompareTo(System.Object)">
             <summary>
            
             </summary>
             <param name="obj"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEnd.Init(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEnd.CompareDirection(DotSpatial.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            Implements the total order relation:
            a has a greater angle with the positive x-axis than b.
            Using the obvious algorithm of simply computing the angle is not robust,
            since the angle calculation is obviously susceptible to roundoff.
            A robust algorithm is:
            - first compare the quadrant.  If the quadrants
            are different, it it trivial to determine which vector is "greater".
            - if the vectors lie in the same quadrant, the computeOrientation function
            can be used to decide the relative orientation of the vectors.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEnd.ComputeLabel">
            <summary>
            Subclasses should override this if they are using labels
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEnd.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEnd.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEnd.Edge">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEnd.Label">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEnd.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEnd.DirectedCoordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEnd.Quadrant">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEnd.Dx">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEnd.Dy">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEnd.Node">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.DirectedEdge._depth">
            <summary>
            The depth of each side (position) of this edge.
            The 0 element of the array is never used.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdge.#ctor(DotSpatial.Topology.GeometriesGraph.Edge,System.Boolean)">
            <summary>
            Creates a new instance of a directed edge
            </summary>
            <param name="inEdge">The edge to use in order to create a directed edge</param>
            <param name="inIsForward">A boolean that forces whether or not this edge is counted as forward</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdge.ComputeDirectedLabel">
            <summary>
            Compute the label in the appropriate orientation for this DirEdge.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdge.GetDepth(DotSpatial.Topology.GeometriesGraph.PositionType)">
            <summary>
            Retrieves an integer that describes the depth
            </summary>
            <param name="position">A Positions enumeration</param>
            <returns>An integer showing the depth</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdge.SetDepth(DotSpatial.Topology.GeometriesGraph.PositionType,System.Int32)">
            <summary>
            Sets the depth value for this edge based on the specified position
            </summary>
            <param name="position">A Position</param>
            <param name="depthVal">The integer depth to specify</param>
            <exception cref="T:DotSpatial.Topology.TopologyException">Assigned depths do not match</exception>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdge.SetEdgeDepths(DotSpatial.Topology.GeometriesGraph.PositionType,System.Int32)">
            <summary>
            Set both edge depths.
            One depth for a given side is provided.
            The other is computed depending on the Location
            transition and the depthDelta of the edge.
            </summary>
            <param name="position"></param>
            <param name="depth"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdge.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdge.WriteEdge(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdge.DepthFactor(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType)">
            <summary>
            Computes the factor for the change in depth when moving from one location to another.
            E.g. if crossing from the Interior to the Exterior the depth decreases, so the factor is -1.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdge.DepthDelta">
            <summary>
            Obtains the chaing in depth
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdge.EdgeRing">
            <summary>
            Gets or sets the EdgeRing
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdge.IsForward">
            <summary>
            Gets a boolean indicating whether this edge is directed forward
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdge.IsInResult">
            <summary>
            Gets a boolean that is true if this edge is in the result
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdge.IsInteriorAreaEdge">
            <summary>
            This is an interior Area edge if
            its label is an Area label for both Geometries
            and for each Geometry both sides are in the interior.
            </summary>
            <returns><c>true</c> if this is an interior Area edge.</returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdge.IsLineEdge">
            <summary>
            This edge is a line edge if
            at least one of the labels is a line label
            any labels which are not line labels have all Locations = Exterior.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdge.IsVisited">
            <summary>
            Gets or sets a boolean that is true if this edge has been visited
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdge.MinEdgeRing">
            <summary>
            Gets or sets the minimum Edge Ring
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdge.Next">
            <summary>
            Gets or sets the next directed edge relative to this directed edge
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdge.NextMin">
            <summary>
            Gets or sets a directed edge for Next Min
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdge.Sym">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdge.VisitedEdge">
            <summary>
            VisitedEdge get property returns <c>true</c> if bot Visited
            and Sym.Visited are <c>true</c>.
            VisitedEdge set property marks both DirectedEdges attached to a given Edge.
            This is used for edges corresponding to lines, which will only
            appear oriented in a single direction in the result.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar">
            <summary>
            A DirectedEdgeStar is an ordered list of outgoing DirectedEdges around a node.
            It supports labelling the edges as well as linking the edges to form both
            MaximalEdgeRings and MinimalEdgeRings.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.EdgeEndStar">
            <summary>
            A EdgeEndStar is an ordered list of EdgeEnds around a node.
            They are maintained in CCW order (starting with the positive x-axis) around the node
            for efficient lookup and topology building.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.EdgeEndStar._edgeMap">
            <summary>
            A map which maintains the edges in sorted order around the node.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.EdgeEndStar._ptInAreaLocation">
            <summary>
            The location of the point for this star in Geometry i Areas.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.Insert(DotSpatial.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            Insert a EdgeEnd into this EdgeEndStar.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.InsertEdgeEnd(DotSpatial.Topology.GeometriesGraph.EdgeEnd,System.Object)">
            <summary>
            Insert an EdgeEnd into the map, and clear the edgeList cache,
            since the list of edges has now changed.
            </summary>
            <param name="e"></param>
            <param name="obj"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.GetEnumerator">
            <summary>
            Iterator access to the ordered list of edges is optimized by
            copying the map collection to a list.  (This assumes that
            once an iterator is requested, it is likely that insertion into
            the map is complete).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.InitializeEdges">
            <summary>
            Initializes the edges in the _edgeList
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.GetNextCw(DotSpatial.Topology.GeometriesGraph.EdgeEnd)">
             <summary>
            
             </summary>
             <param name="ee"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.ComputeLabelling(DotSpatial.Topology.GeometriesGraph.GeometryGraph[])">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.ComputeEdgeEndLabels">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.GetLocation(System.Int32,DotSpatial.Topology.Coordinate,DotSpatial.Topology.GeometriesGraph.GeometryGraph[])">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="p"></param>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.CheckAreaLabelsConsistent(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.PropagateSideLabels(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.FindIndex(DotSpatial.Topology.GeometriesGraph.EdgeEnd)">
             <summary>
            
             </summary>
             <param name="eSearch"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.EdgeMap">
            <summary>
            Gets the EdgeMap
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.EdgeList">
            <summary>
            A list of all outgoing edges in the result, in CCW order.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.Coordinate">
            <returns>
            The coordinate for the node this star is based at.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.Degree">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.Edges">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeEndStar.IsAreaLabelsConsistent">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar._resultAreaEdgeList">
            <summary>
            A list of all outgoing edges in the result, in CCW order.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.Insert(DotSpatial.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            Insert a directed edge in the list.
            </summary>
            <param name="ee"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.GetOutgoingDegree">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.GetOutgoingDegree(DotSpatial.Topology.GeometriesGraph.EdgeRing)">
             <summary>
            
             </summary>
             <param name="er"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.GetRightmostEdge">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.ComputeLabelling(DotSpatial.Topology.GeometriesGraph.GeometryGraph[])">
            <summary>
            Compute the labelling for all dirEdges in this star, as well
            as the overall labelling.
            </summary>
            <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.MergeSymLabels">
            <summary>
            For each dirEdge in the star, merge the label .
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.UpdateLabelling(DotSpatial.Topology.GeometriesGraph.Label)">
            <summary>
            Update incomplete dirEdge labels from the labelling for the node.
            </summary>
            <param name="nodeLabel"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.LinkResultDirectedEdges">
            <summary>
            Traverse the star of DirectedEdges, linking the included edges together.
            To link two dirEdges, the next pointer for an incoming dirEdge
            is set to the next outgoing edge.
            DirEdges are only linked if:
            they belong to an area (i.e. they have sides)
            they are marked as being in the result
            Edges are linked in CCW order (the order they are stored).
            This means that rings have their face on the Right
            (in other words, the topological location of the face is given by the RHS label of the DirectedEdge).
            PRECONDITION: No pair of dirEdges are both marked as being in the result.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.LinkMinimalDirectedEdges(DotSpatial.Topology.GeometriesGraph.EdgeRing)">
             <summary>
            
             </summary>
             <param name="er"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.LinkAllDirectedEdges">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.FindCoveredLineEdges">
            <summary>
            Traverse the star of edges, maintaing the current location in the result
            area at this node (if any).
            If any L edges are found in the interior of the result, mark them as covered.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.ComputeDepths(DotSpatial.Topology.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="de"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.ComputeDepths(System.Int32,System.Int32,System.Int32)">
            <summary>
            Compute the DirectedEdge depths for a subsequence of the edge array.
            </summary>
            <returns>The last depth assigned (from the R side of the last edge visited).</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.DirectedEdgeStar.Label">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Edge">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.GraphComponent">
            <summary>
            A GraphComponent is the parent class for the objects'
            that form a graph.  Each GraphComponent can carry a
            Label.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GraphComponent.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GraphComponent.#ctor(DotSpatial.Topology.GeometriesGraph.Label)">
             <summary>
            
             </summary>
             <param name="inLabel"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GraphComponent.ComputeIm(DotSpatial.Topology.IntersectionMatrix)">
            <summary>
            Compute the contribution to an IM for this component.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GraphComponent.UpdateIm(DotSpatial.Topology.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for this component.
            A component only contributes if it has a labelling for both parent geometries.
            </summary>
            <param name="im"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.GraphComponent.Label">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.GraphComponent.IsInResult">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.GraphComponent.IsCovered">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.GraphComponent.IsCoveredSet">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.GraphComponent.IsVisited">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.GraphComponent.Coordinate">
             <summary>
            
             </summary>
             <returns>
             A coordinate in this component (or null, if there are none).
             </returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.GraphComponent.IsIsolated">
            <summary>
            An isolated component is one that does not intersect or touch any other
            component.  This is the case if the label has valid locations for
            only a single Geometry.
            </summary>
            <returns><c>true</c> if this component is isolated.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.#ctor(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},DotSpatial.Topology.GeometriesGraph.Label)">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <param name="label"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.#ctor(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="pts"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.UpdateIm(DotSpatial.Topology.GeometriesGraph.Label,DotSpatial.Topology.IntersectionMatrix)">
            <summary>
            Updates an IM from the label for an edge.
            Handles edges from both L and A geometries.
            </summary>
            <param name="label"></param>
            <param name="im"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.GetCoordinate(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.AddIntersections(DotSpatial.Topology.Algorithm.LineIntersector,System.Int32,System.Int32)">
            <summary>
            Adds EdgeIntersections for one or both
            intersections found for a segment of an edge to the edge intersection list.
            </summary>
            <param name="li"></param>
            <param name="segmentIndex"></param>
            <param name="geomIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.AddIntersection(DotSpatial.Topology.Algorithm.LineIntersector,System.Int32,System.Int32,System.Int32)">
            <summary>
            Add an EdgeIntersection for intersection intIndex.
            An intersection that falls exactly on a vertex of the edge is normalized
            to use the higher of the two possible segmentIndexes.
            </summary>
            <param name="li"></param>
            <param name="segmentIndex"></param>
            <param name="geomIndex"></param>
            <param name="intIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.ComputeIm(DotSpatial.Topology.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for this component.
            A component only contributes if it has a labelling for both parent geometries.
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.Equals(System.Object)">
            <summary>
            Equals is defined to be:
            e1 equals e2
            iff
            the coordinates of e1 are the same or the reverse of the coordinates in e2.
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.Equals(DotSpatial.Topology.GeometriesGraph.Edge)">
            <summary>
            Equals is defined to be:
            e1 equals e2
            iff
            the coordinates of e1 are the same or the reverse of the coordinates in e2.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.op_Equality(DotSpatial.Topology.GeometriesGraph.Edge,DotSpatial.Topology.GeometriesGraph.Edge)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.op_Inequality(DotSpatial.Topology.GeometriesGraph.Edge,DotSpatial.Topology.GeometriesGraph.Edge)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.GetHashCode">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.IsPointwiseEqual(DotSpatial.Topology.GeometriesGraph.Edge)">
            <returns>
            <c>true</c> if the coordinate sequences of the Edges are identical.
            </returns>
            <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.WriteReverse(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Edge.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.Points">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.NumPoints">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.Name">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.Coordinates">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.Envelope">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.Depth">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.DepthDelta">
            <summary>
            The depthDelta is the change in depth as an edge is crossed from R to L.
            </summary>
            <returns>The change in depth as the edge is crossed from R to L.</returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.MaximumSegmentIndex">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.EdgeIntersectionList">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.MonotoneChainEdge">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.IsClosed">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.IsCollapsed">
            <summary>
            An Edge is collapsed if it is an Area edge and it consists of
            two segments which are equal and opposite (eg a zero-width V).
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.CollapsedEdge">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.Isolated">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Edge.IsIsolated">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.EdgeIntersection">
            <summary>
            An EdgeIntersection represents a point on an
            edge which intersects with another edge.
            The intersection may either be a single point, or a line segment
            (in which case this point is the start of the line segment)
            The label attached to this intersection point applies to
            the edge from this point forwards, until the next
            intersection or the end of the edge.
            The intersection point must be precise.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersection.#ctor(DotSpatial.Topology.Coordinate,System.Int32,System.Double)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <param name="segmentIndex"></param>
             <param name="dist"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersection.CompareTo(System.Object)">
             <summary>
            
             </summary>
             <param name="obj"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersection.Compare(System.Int32,System.Double)">
             <summary>
            
             </summary>
             <param name="segmentIndex"></param>
             <param name="dist"></param>
             <returns>
             -1 this EdgeIntersection is located before the argument location,
             0 this EdgeIntersection is at the argument location,
             1 this EdgeIntersection is located after the argument location.
             </returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersection.IsEndPoint(System.Int32)">
             <summary>
            
             </summary>
             <param name="maxSegmentIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersection.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeIntersection.Coordinate">
            <summary>
            The point of intersection.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeIntersection.SegmentIndex">
            <summary>
            The index of the containing line segment in the parent edge.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeIntersection.Distance">
            <summary>
            The edge distance of this point along the containing line segment.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.EdgeIntersectionList">
            <summary>
            A list of edge intersections along an Edge.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersectionList.#ctor(DotSpatial.Topology.GeometriesGraph.Edge)">
             <summary>
            
             </summary>
             <param name="edge"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersectionList.Add(DotSpatial.Topology.Coordinate,System.Int32,System.Double)">
            <summary>
            Adds an intersection into the list, if it isn't already there.
            The input segmentIndex and dist are expected to be normalized.
            </summary>
            <param name="intPt"></param>
            <param name="segmentIndex"></param>
            <param name="dist"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersectionList.GetEnumerator">
            <summary>
            Returns an iterator of EdgeIntersections.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersectionList.IsIntersection(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="pt"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersectionList.AddEndpoints">
            <summary>
            Adds entries for the first and last points of the edge to the list.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersectionList.AddSplitEdges(System.Collections.IList)">
            <summary>
            Creates new edges for all the edges that the intersections in this
            list split the parent edge into.
            Adds the edges to the input list (this is so a single list
            can be used to accumulate all split edges for a Geometry).
            </summary>
            <param name="edgeList"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersectionList.CreateSplitEdge(DotSpatial.Topology.GeometriesGraph.EdgeIntersection,DotSpatial.Topology.GeometriesGraph.EdgeIntersection)">
            <summary>
            Create a new "split edge" with the section of points between
            (and including) the two intersections.
            The label for the new edge is the same as the label for the parent edge.
            </summary>
            <param name="ei0"></param>
            <param name="ei1"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeIntersectionList.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeIntersectionList.Count">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.EdgeList">
            <summary>
            A EdgeList is a list of Edges.  It supports locating edges
            that are pointwise equals to a target edge.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.EdgeList._index">
            <summary>
            An index of the edges, for fast lookup.
            a Quadtree is used, because this index needs to be dynamic
            (e.g. allow insertions after queries).
            An alternative would be to use an ordered set based on the values
            of the edge coordinates.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeList.Remove(DotSpatial.Topology.GeometriesGraph.Edge)">
            <summary>
            Remove the selected Edge element from the list if present.
            </summary>
            <param name="e">Edge element to remove from list</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeList.Add(DotSpatial.Topology.GeometriesGraph.Edge)">
            <summary>
            Insert an edge unless it is already in the list.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeList.AddAll(System.Collections.ICollection)">
             <summary>
            
             </summary>
             <param name="edgeColl"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeList.FindEqualEdge(DotSpatial.Topology.GeometriesGraph.Edge)">
            <summary>
            If there is an edge equal to e already in the list, return it.
            Otherwise return null.
            </summary>
            <param name="e"></param>
            <returns>
            equal edge, if there is one already in the list,
            null otherwise.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeList.GetEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeList.Get(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeList.FindEdgeIndex(DotSpatial.Topology.GeometriesGraph.Edge)">
            <summary>
            If the edge e is already in the list, return its index.
            </summary>
            <param name="e"></param>
            <returns>
            Index, if e is already in the list,
            -1 otherwise.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeList.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeList.Edges">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeList.Item(System.Int32)">
             <summary>
            
             </summary>
             <param name="index"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.EdgeNodingValidator">
            <summary>
            Validates that a collection of SegmentStrings is correctly noded.
            Throws an appropriate exception if an noding error is found.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeNodingValidator.#ctor(System.Collections.IEnumerable)">
             <summary>
            
             </summary>
             <param name="edges"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeNodingValidator.ToSegmentStrings(System.Collections.IEnumerable)">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeNodingValidator.CheckValid">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.EdgeRing">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.#ctor(DotSpatial.Topology.GeometriesGraph.DirectedEdge,DotSpatial.Topology.IGeometryFactory)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <param name="geometryFactory"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.GetCoordinate(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.AddHole(DotSpatial.Topology.GeometriesGraph.EdgeRing)">
             <summary>
            
             </summary>
             <param name="ring"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.ToPolygon(DotSpatial.Topology.IGeometryFactory)">
             <summary>
            
             </summary>
             <param name="geometryFactory"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.ComputeRing">
            <summary>
            Compute a LinearRing from the point list previously collected.
            Test if the ring is a hole (i.e. if it is CCW) and set the hole flag
            accordingly.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.GetNext(DotSpatial.Topology.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.SetEdgeRing(DotSpatial.Topology.GeometriesGraph.DirectedEdge,DotSpatial.Topology.GeometriesGraph.EdgeRing)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <param name="er"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.ComputePoints(DotSpatial.Topology.GeometriesGraph.DirectedEdge)">
            <summary>
            Collect all the points from the DirectedEdges of this ring into a contiguous list.
            </summary>
            <param name="start"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.ComputeMaxNodeDegree">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.SetInResult">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.MergeLabel(DotSpatial.Topology.GeometriesGraph.Label)">
             <summary>
            
             </summary>
             <param name="deLabel"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.MergeLabel(DotSpatial.Topology.GeometriesGraph.Label,System.Int32)">
            <summary>
            Merge the RHS label from a DirectedEdge into the label for this EdgeRing.
            The DirectedEdge label may be null.  This is acceptable - it results
            from a node which is NOT an intersection node between the Geometries
            (e.g. the end node of a LinearRing).  In this case the DirectedEdge label
            does not contribute any information to the overall labelling, and is simply skipped.
            </summary>
            <param name="deLabel"></param>
            <param name="geomIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.AddPoints(DotSpatial.Topology.GeometriesGraph.Edge,System.Boolean,System.Boolean)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="isForward"></param>
             <param name="isFirstEdge"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.EdgeRing.ContainsPoint(DotSpatial.Topology.Coordinate)">
            <summary>
            This method will cause the ring to be computed.
            It will also check any holes, if they have been assigned.
            </summary>
            <param name="p"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeRing.InnerGeometryFactory">
            <summary>
            Gets the inner geometry factory
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeRing.IsIsolated">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeRing.IsHole">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeRing.LinearRing">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeRing.Label">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeRing.IsShell">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeRing.Shell">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeRing.Edges">
            <summary>
            Returns the list of DirectedEdges that make up this EdgeRing.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeRing.StartDe">
            <summary>
            The directed edge which starts the list of edges for this EdgeRing.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.EdgeRing.MaxNodeDegree">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.GeometryGraph">
            <summary>
            A GeometryGraph is a graph that models a given Geometry.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.PlanarGraph">
            <summary>
            The computation of the <c>IntersectionMatrix</c> relies on the use of a structure
            called a "topology graph". The topology graph contains nodes and edges
            corresponding to the nodes and line segments of a <c>Geometry</c>. Each
            node and edge in the graph is labeled with its topological location relative to
            the source point.
            Notice that there is no requirement that points of self-intersection be a vertex.
            Thus to obtain a correct topology graph, <c>Geometry</c>s must be
            self-noded before constructing their graphs.
            Two fundamental operations are supported by topology graphs:
            Computing the intersections between all the edges and nodes of a single graph
            Computing the intersections between the edges and nodes of two different graphs
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.#ctor(DotSpatial.Topology.GeometriesGraph.NodeFactory)">
            <summary>
            Creates a new instance of a Planar Graph
            </summary>
            <param name="nodeFact">A node Factory</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.#ctor">
            <summary>
            Creates a new instance of a Planar Graph using a default NodeFactory
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.Add(DotSpatial.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            Adds a new EdgeEnd to the planar graph
            </summary>
            <param name="e">The EdgeEnd to add</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.AddEdges(System.Collections.IList)">
            <summary>
            Add a set of edges to the graph.  For each edge two DirectedEdges
            will be created.  DirectedEdges are NOT linked by this method.
            </summary>
            <param name="edgesToAdd"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.AddNode(DotSpatial.Topology.GeometriesGraph.Node)">
            <summary>
            Adds the specified node to the geometry graph's NodeMap
            </summary>
            <param name="node">The node to add</param>
            <returns>The node after the addition</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.AddNode(DotSpatial.Topology.Coordinate)">
            <summary>
            Adds a new ICoordinate as though it were a Node to the node map
            </summary>
            <param name="coord">An ICoordinate to add</param>
            <returns>The newly added node</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.Find(DotSpatial.Topology.Coordinate)">
            <returns>
            The node if found; null otherwise
            </returns>
            <param name="coord"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.FindEdgeEnd(DotSpatial.Topology.GeometriesGraph.Edge)">
            <summary>
            Returns the EdgeEnd which has edge e as its base edge
            (MD 18 Feb 2002 - this should return a pair of edges).
            </summary>
            <param name="e"></param>
            <returns> The edge, if found <c>null</c> if the edge was not found.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.FindEdge(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Returns the edge whose first two coordinates are p0 and p1.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns> The edge, if found <c>null</c> if the edge was not found.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.FindEdgeInSameDirection(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
             Returns the edge which starts at p0 and whose first segment is
             parallel to p1.
             </summary>
             <param name="p0"></param>
            <param name="p1"></param>
             <returns> The edge, if found <c>null</c> if the edge was not found.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.GetNodeEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.GetEdgeEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.InsertEdge(DotSpatial.Topology.GeometriesGraph.Edge)">
            <summary>
            Adds a new EdgeEnd to the planar graph
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.LinkResultDirectedEdges">
            <summary>
            Link the DirectedEdges at the nodes of the graph.
            This allows clients to link only a subset of nodes in the graph, for
            efficiency (because they know that only a subset is of interest).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.LinkAllDirectedEdges">
            <summary>
            Link the DirectedEdges at the nodes of the graph.
            This allows clients to link only a subset of nodes in the graph, for
            efficiency (because they know that only a subset is of interest).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.MatchInSameDirection(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            The coordinate pairs match if they define line segments lying in the same direction.
            E.g. the segments are parallel and in the same quadrant
            (as opposed to parallel and opposite!).
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="ep0"></param>
            <param name="ep1"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.WriteEdges(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.IsBoundaryNode(System.Int32,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="coord"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.PlanarGraph.LinkResultDirectedEdges(System.Collections.IList)">
            <summary>
            For nodes in the Collection, link the DirectedEdges at the node that are in the result.
            This allows clients to link only a subset of nodes in the graph, for
            efficiency (because they know that only a subset is of interest).
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.PlanarGraph.EdgeEnds">
            <summary>
            Gets a list of edge ends
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.PlanarGraph.Edges">
            <summary>
            Gets or sets the list of edges.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.PlanarGraph.Nodes">
            <summary>
            Gets or sets the NodeMap for this graph
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.PlanarGraph.NodeValues">
            <summary>
            Gets a list of the actual values contained in the nodes
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.GeometryGraph._lineEdgeMap">
            <summary>
            The lineEdgeMap is a map of the linestring components of the
            parentGeometry to the edges which are derived from them.
            This is used to efficiently perform findEdge queries
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.GeometryGraph._useBoundaryDeterminationRule">
            <summary>
            If this flag is true, the Boundary Determination Rule will used when deciding
            whether nodes are in the boundary or not
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.#ctor(System.Int32,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="argIndex"></param>
             <param name="parentGeom"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.IsInBoundary(System.Int32)">
            <summary>
            This method implements the Boundary Determination Rule
            for determining whether
            a component (node or edge) that appears multiple times in elements
            of a MultiGeometry is in the boundary or the interior of the Geometry.
            The SFS uses the "Mod-2 Rule", which this function implements.
            An alternative (and possibly more intuitive) rule would be
            the "At Most One Rule":
            isInBoundary = (componentCount == 1)
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.DetermineBoundary(System.Int32)">
             <summary>
            
             </summary>
             <param name="boundaryCount"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.CreateEdgeSetIntersector">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.GetBoundaryPoints">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.FindEdge(DotSpatial.Topology.ILineString)">
             <summary>
            
             </summary>
             <param name="line"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.ComputeSplitEdges(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="edgelist"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.Add(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.AddCollection(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="gc"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.AddPolygonRing(DotSpatial.Topology.IBasicGeometry,DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType)">
            <summary>
            The left and right topological location arguments assume that the ring is oriented CW.
            If the ring is in the opposite orientation,
            the left and right locations must be interchanged.
            </summary>
            <param name="lr"></param>
            <param name="cwLeft"></param>
            <param name="cwRight"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.AddPolygon(DotSpatial.Topology.Polygon)">
             <summary>
            
             </summary>
             <param name="p"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.AddLineString(DotSpatial.Topology.IBasicGeometry)">
             <summary>
            
             </summary>
             <param name="line"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.AddEdge(DotSpatial.Topology.GeometriesGraph.Edge)">
            <summary>
            Add an Edge computed externally.  The label on the Edge is assumed
            to be correct.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.AddPoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Add a point computed externally.  The point is assumed to be a
            Point Geometry part, which has a location of INTERIOR.
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.ComputeSelfNodes(DotSpatial.Topology.Algorithm.LineIntersector,System.Boolean)">
            <summary>
            Compute self-nodes, taking advantage of the Geometry type to
            minimize the number of intersection tests.  (E.g. rings are
            not tested for self-intersection, since they are assumed to be valid).
            </summary>
            <param name="li">The <c>LineIntersector</c> to use.</param>
            <param name="computeRingSelfNodes">If <c>false</c>, intersection checks are optimized to not test rings for self-intersection.</param>
            <returns>The SegmentIntersector used, containing information about the intersections found.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.ComputeEdgeIntersections(DotSpatial.Topology.GeometriesGraph.GeometryGraph,DotSpatial.Topology.Algorithm.LineIntersector,System.Boolean)">
             <summary>
            
             </summary>
             <param name="g"></param>
             <param name="li"></param>
             <param name="includeProper"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.InsertPoint(System.Int32,DotSpatial.Topology.Coordinate,DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="argIndex"></param>
             <param name="coord"></param>
             <param name="onLocation"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.InsertBoundaryPoint(System.Int32,DotSpatial.Topology.Coordinate)">
            <summary>
            Adds points using the mod-2 rule of SFS.  This is used to add the boundary
            points of dim-1 geometries (Curves/MultiCurves).  According to the SFS,
            an endpoint of a Curve is on the boundary
            if it is in the boundaries of an odd number of Geometries.
            </summary>
            <param name="argIndex"></param>
            <param name="coord"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.AddSelfIntersectionNodes(System.Int32)">
             <summary>
            
             </summary>
             <param name="argIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.GeometryGraph.AddSelfIntersectionNode(System.Int32,DotSpatial.Topology.Coordinate,DotSpatial.Topology.LocationType)">
            <summary>
            Add a node for a self-intersection.
            If the node is a potential boundary node (e.g. came from an edge which
            is a boundary) then insert it as a potential boundary node.
            Otherwise, just add it as a regular node.
            </summary>
            <param name="argIndex"></param>
            <param name="coord"></param>
            <param name="loc"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.GeometryGraph.HasTooFewPoints">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.GeometryGraph.InvalidPoint">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.GeometryGraph.Geometry">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.GeometryGraph.BoundaryNodes">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Index.EdgeSetIntersector">
            <summary>
            An <c>EdgeSetIntersector</c> computes all the intersections between the
            edges in the set.  It adds the computed intersections to each edge
            they are found on.  It may be used in two scenarios:
            determining the internal intersections between a single set of edges
            determining the mutual intersections between two different sets of edges
            It uses a <c>SegmentIntersector</c> to compute the intersections between
            segments and to record statistics about what kinds of intersections were found.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.EdgeSetIntersector.ComputeIntersections(System.Collections.IList,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector,System.Boolean)">
            <summary>
            Computes all self-intersections between edges in a set of edges,
            allowing client to choose whether self-intersections are computed.
            </summary>
            <param name="edges">A list of edges to test for intersections.</param>
            <param name="si">The SegmentIntersector to use.</param>
            <param name="testAllSegments"><c>true</c> if self-intersections are to be tested as well.</param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.EdgeSetIntersector.ComputeIntersections(System.Collections.IList,System.Collections.IList,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            Computes all mutual intersections between two sets of edges.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChain">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChain.#ctor(DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge,System.Int32)">
             <summary>
            
             </summary>
             <param name="mce"></param>
             <param name="chainIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChain.ComputeIntersections(DotSpatial.Topology.GeometriesGraph.Index.MonotoneChain,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="mc"></param>
             <param name="si"></param>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge">
            <summary>
            MonotoneChains are a way of partitioning the segments of an edge to
            allow for fast searching of intersections.
            They have the following properties:
            the segments within a monotone chain will never intersect each other, and
            the envelope of any contiguous subset of the segments in a monotone chain
            is simply the envelope of the endpoints of the subset.
            Property 1 means that there is no need to test pairs of segments from within
            the same monotone chain for intersection.
            Property 2 allows
            binary search to be used to find the intersection points of two monotone chains.
            For many types of real-world data, these properties eliminate a large number of
            segment comparisons, producing substantial speed gains.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge.#ctor(DotSpatial.Topology.GeometriesGraph.Edge)">
             <summary>
            
             </summary>
             <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge.GetMinX(System.Int32)">
             <summary>
            
             </summary>
             <param name="chainIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge.GetMaxX(System.Int32)">
             <summary>
            
             </summary>
             <param name="chainIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge.ComputeIntersects(DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="mce"></param>
             <param name="si"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge.ComputeIntersectsForChain(System.Int32,DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge,System.Int32,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="chainIndex0"></param>
             <param name="mce"></param>
             <param name="chainIndex1"></param>
             <param name="si"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge.ComputeIntersectsForChain(System.Int32,System.Int32,DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge,System.Int32,System.Int32,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="start0"></param>
             <param name="end0"></param>
             <param name="mce"></param>
             <param name="start1"></param>
             <param name="end1"></param>
             <param name="ei"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge.Coordinates">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainEdge.StartIndexes">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainIndexer">
            <summary>
            MonotoneChains are a way of partitioning the segments of an edge to
            allow for fast searching of intersections.
            They have the following properties:
            the segments within a monotone chain will never intersect each other, and
            the envelope of any contiguous subset of the segments in a monotone chain
            is simply the envelope of the endpoints of the subset.
            Property 1 means that there is no need to test pairs of segments from within
            the same monotone chain for intersection.
            Property 2 allows
            binary search to be used to find the intersection points of two monotone chains.
            For many types of real-world data, these properties eliminate a large number of
            segment comparisons, producing substantial speed gains.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainIndexer.ToIntArray(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="list"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainIndexer.GetChainStartIndices(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.MonotoneChainIndexer.FindChainEnd(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Int32)">
            <returns>
            The index of the last point in the monotone chain.
            </returns>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector.NumTests">
            <summary>
            Testing only.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector.#ctor(DotSpatial.Topology.Algorithm.LineIntersector,System.Boolean,System.Boolean)">
             <summary>
            
             </summary>
             <param name="li"></param>
             <param name="includeProper"></param>
             <param name="recordIsolated"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector.IsAdjacentSegments(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="i1"></param>
             <param name="i2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector.SetBoundaryNodes(System.Collections.ICollection,System.Collections.ICollection)">
             <summary>
            
             </summary>
             <param name="bdyNodes0"></param>
             <param name="bdyNodes1"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector.IsTrivialIntersection(DotSpatial.Topology.GeometriesGraph.Edge,System.Int32,DotSpatial.Topology.GeometriesGraph.Edge,System.Int32)">
            <summary>
            A trivial intersection is an apparent self-intersection which in fact
            is simply the point shared by adjacent line segments.
            Notice that closed edges require a special check for the point shared by the beginning
            and end segments.
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector.AddIntersections(DotSpatial.Topology.GeometriesGraph.Edge,System.Int32,DotSpatial.Topology.GeometriesGraph.Edge,System.Int32)">
            <summary>
            This method is called by clients of the EdgeIntersector class to test for and add
            intersections for two segments of the edges being intersected.
            Notice that clients (such as MonotoneChainEdges) may choose not to intersect
            certain pairs of segments for efficiency reasons.
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector.IsBoundaryPoint(DotSpatial.Topology.Algorithm.LineIntersector,System.Collections.ICollection[])">
             <summary>
            
             </summary>
             <param name="li"></param>
             <param name="bdyNodes"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector.IsBoundaryPoint(DotSpatial.Topology.Algorithm.LineIntersector,System.Collections.IEnumerable)">
             <summary>
            
             </summary>
             <param name="li"></param>
             <param name="bdyNodes"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector.ProperIntersectionPoint">
            <returns>
            The proper intersection point, or <c>null</c> if none was found.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector.HasIntersection">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector.HasProperIntersection">
            <summary>
            A proper intersection is an intersection which is interior to at least two
            line segments.  Notice that a proper intersection is not necessarily
            in the interior of the entire Geometry, since another edge may have
            an endpoint equal to the intersection, which according to SFS semantics
            can result in the point being on the Boundary of the Geometry.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector.HasProperInteriorIntersection">
            <summary>
            A proper interior intersection is a proper intersection which is not
            contained in the set of boundary nodes set for this SegmentIntersector.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Index.SimpleEdgeSetIntersector">
            <summary>
            Finds all intersections in one or two sets of edges,
            using the straightforward method of
            comparing all segments.
            This algorithm is too slow for production use, but is useful for testing purposes.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleEdgeSetIntersector.ComputeIntersections(System.Collections.IList,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector,System.Boolean)">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <param name="si"></param>
             <param name="testAllSegments"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleEdgeSetIntersector.ComputeIntersections(System.Collections.IList,System.Collections.IList,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="edges0"></param>
             <param name="edges1"></param>
             <param name="si"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleEdgeSetIntersector.ComputeIntersects(DotSpatial.Topology.GeometriesGraph.Edge,DotSpatial.Topology.GeometriesGraph.Edge,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            Performs a brute-force comparison of every segment in each Edge.
            This has n^2 performance, and is about 100 times slower than using
            monotone chains.
            </summary>
            <param name="e0"></param>
            <param name="e1"></param>
            <param name="si"></param>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Index.SimpleMcSweepLineIntersector">
            <summary>
            Finds all intersections in one or two sets of edges,
            using an x-axis sweepline algorithm in conjunction with Monotone Chains.
            While still O(n^2) in the worst case, this algorithm
            drastically improves the average-case time.
            The use of MonotoneChains as the items in the index
            seems to offer an improvement in performance over a sweep-line alone.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleMcSweepLineIntersector.ComputeIntersections(System.Collections.IList,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector,System.Boolean)">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <param name="si"></param>
             <param name="testAllSegments"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleMcSweepLineIntersector.ComputeIntersections(System.Collections.IList,System.Collections.IList,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="edges0"></param>
             <param name="edges1"></param>
             <param name="si"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleMcSweepLineIntersector.Add(System.Collections.IEnumerable)">
             <summary>
            
             </summary>
             <param name="edges"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleMcSweepLineIntersector.Add(System.Collections.IEnumerable,System.Object)">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <param name="edgeSet"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleMcSweepLineIntersector.Add(DotSpatial.Topology.GeometriesGraph.Edge,System.Object)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="edgeSet"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleMcSweepLineIntersector.PrepareEvents">
            <summary>
            Because Delete Events have a link to their corresponding Insert event,
            it is possible to compute exactly the range of events which must be
            compared to a given Insert event object.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleMcSweepLineIntersector.ComputeIntersections(DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="si"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleMcSweepLineIntersector.ProcessOverlaps(System.Int32,System.Int32,DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <param name="end"></param>
             <param name="ev0"></param>
             <param name="si"></param>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector">
            <summary>
            Finds all intersections in one or two sets of edges,
            using a simple x-axis sweepline algorithm.
            While still O(n^2) in the worst case, this algorithm
            drastically improves the average-case time.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.ComputeIntersections(System.Collections.IList,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector,System.Boolean)">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <param name="si"></param>
             <param name="testAllSegments"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.ComputeIntersections(System.Collections.IList,System.Collections.IList,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="edges0"></param>
             <param name="edges1"></param>
             <param name="si"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.Add(System.Collections.IEnumerable)">
             <summary>
            
             </summary>
             <param name="edges"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.Add(System.Collections.IEnumerable,System.Object)">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <param name="edgeSet"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.Add(DotSpatial.Topology.GeometriesGraph.Edge,System.Object)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="edgeSet"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.PrepareEvents">
            <summary>
            Because Delete Events have a link to their corresponding Insert event,
            it is possible to compute exactly the range of events which must be
            compared to a given Insert event object.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.ComputeIntersections(DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="si"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.ProcessOverlaps(System.Int32,System.Int32,DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <param name="end"></param>
             <param name="ev0"></param>
             <param name="si"></param>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent.INSERT">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent.DELETE">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent.#ctor(System.Object,System.Double,DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent,System.Object)">
             <summary>
            
             </summary>
             <param name="edgeSet"></param>
             <param name="x"></param>
             <param name="insertEvent"></param>
             <param name="obj"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent.CompareTo(System.Object)">
            <summary>
            ProjectionEvents are ordered first by their x-value, and then by their eventType.
            It is important that Insert events are sorted before Delete events, so that
            items whose Insert and Delete events occur at the same x-value will be
            correctly handled.
            </summary>
            <param name="o"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent.EdgeSet">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent.IsInsert">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent.IsDelete">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent.InsertEvent">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent.DeleteEventIndex">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.SweepLineEvent.Object">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Index.SweepLineSegment">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SweepLineSegment.#ctor(DotSpatial.Topology.GeometriesGraph.Edge,System.Int32)">
             <summary>
            
             </summary>
             <param name="edge"></param>
             <param name="ptIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Index.SweepLineSegment.ComputeIntersections(DotSpatial.Topology.GeometriesGraph.Index.SweepLineSegment,DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector)">
             <summary>
            
             </summary>
             <param name="ss"></param>
             <param name="si"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.SweepLineSegment.MinX">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Index.SweepLineSegment.MaxX">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Label">
            <summary>
            A <c>Label</c> indicates the topological relationship of a component
            of a topology graph to a given <c>Geometry</c>.
            This class supports labels for relationships to two <c>Geometry</c>s,
            which is sufficient for algorithms for binary operations.
            Topology graphs support the concept of labeling nodes and edges in the graph.
            The label of a node or edge specifies its topological relationship to one or
            more geometries.  (In fact, since NTS operations have only two arguments labels
            are required for only two geometries).  A label for a node or edge has one or
            two elements, depending on whether the node or edge occurs in one or both of the
            input <c>Geometry</c>s.  Elements contain attributes which categorize the
            topological location of the node or edge relative to the parent
            <c>Geometry</c>; that is, whether the node or edge is in the interior,
            boundary or exterior of the <c>Geometry</c>.  Attributes have a value
            from the set <c>{Interior, Boundary, Exterior}</c>.  In a node each
            element has a single attribute <c>On</c>. For an edge each element has a
            triplet of attributes <c>Left, On, Right</c>.
            It is up to the client code to associate the 0 and 1 <c>TopologyLocation</c>s
            with specific geometries.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.#ctor(DotSpatial.Topology.LocationType)">
            <summary>
            Construct a Label with a single location for both Geometries.
            Initialize the locations to Null.
            </summary>
            <param name="onLoc"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.#ctor(System.Int32,DotSpatial.Topology.LocationType)">
            <summary>
            Construct a Label with a single location for both Geometries.
            Initialize the location for the Geometry index.
            </summary>
            <param name="geomIndex"></param>
            <param name="onLoc"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.#ctor(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType)">
            <summary>
            Construct a Label with On, Left and Right locations for both Geometries.
            Initialize the locations for both Geometries to the given values.
            </summary>
            <param name="onLoc"></param>
            <param name="leftLoc"></param>
            <param name="rightLoc"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.#ctor(System.Int32,DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType)">
            <summary>
            Construct a Label with On, Left and Right locations for both Geometries.
            Initialize the locations for the given Geometry index.
            </summary>
            <param name="geomIndex"></param>
            <param name="onLoc"></param>
            <param name="leftLoc"></param>
            <param name="rightLoc"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.#ctor(System.Int32,DotSpatial.Topology.GeometriesGraph.TopologyLocation)">
            <summary>
            Construct a Label with the same values as the argument for the
            given Geometry index.
            </summary>
            <param name="geomIndex"></param>
            <param name="gl"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.#ctor(DotSpatial.Topology.GeometriesGraph.Label)">
            <summary>
            Construct a Label with the same values as the argument Label.
            </summary>
            <param name="lbl"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.ToLineLabel(DotSpatial.Topology.GeometriesGraph.Label)">
            <summary>
            Converts a Label to a Line label (that is, one with no side Locations).
            </summary>
            <param name="label">Label to convert.</param>
            <returns>Label as Line label.</returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.Flip">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.GetLocation(System.Int32,DotSpatial.Topology.GeometriesGraph.PositionType)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.GetLocation(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.SetLocation(System.Int32,DotSpatial.Topology.GeometriesGraph.PositionType,DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="posIndex"></param>
             <param name="location"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.SetLocation(System.Int32,DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="location"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.SetAllLocations(System.Int32,DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="location"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.SetAllLocationsIfNull(System.Int32,DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="location"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.SetAllLocationsIfNull(DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="location"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.Merge(DotSpatial.Topology.GeometriesGraph.Label)">
            <summary>
            Merge this label with another one.
            Merging updates any null attributes of this label with the attributes from lbl.
            </summary>
            <param name="lbl"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.IsNull(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.IsAnyNull(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.IsArea">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.IsArea(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.IsLine(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.IsEqualOnSide(DotSpatial.Topology.GeometriesGraph.Label,System.Int32)">
             <summary>
            
             </summary>
             <param name="lbl"></param>
             <param name="side"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.AllPositionsEqual(System.Int32,DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <param name="loc"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.ToLine(System.Int32)">
            <summary>
            Converts one GeometryLocation to a Line location.
            </summary>
            <param name="geomIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Label.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Label.GeometryCount">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Node">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Node.#ctor(DotSpatial.Topology.Coordinate,DotSpatial.Topology.GeometriesGraph.EdgeEndStar)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <param name="edges"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Node.ComputeIm(DotSpatial.Topology.IntersectionMatrix)">
            <summary>
            Basic nodes do not compute IMs.
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Node.Add(DotSpatial.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            Add the edge to the list of edges at this node.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Node.MergeLabel(DotSpatial.Topology.GeometriesGraph.Node)">
             <summary>
            
             </summary>
             <param name="n"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Node.MergeLabel(DotSpatial.Topology.GeometriesGraph.Label)">
            <summary>
            To merge labels for two nodes,
            the merged location for each LabelElement is computed.
            The location for the corresponding node LabelElement is set to the result,
            as long as the location is non-null.
            </summary>
            <param name="label2"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Node.SetLabel(System.Int32,DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="argIndex"></param>
             <param name="onLocation"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Node.SetLabelBoundary(System.Int32)">
            <summary>
            Updates the label of a node to BOUNDARY,
            obeying the mod-2 boundaryDetermination rule.
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Node.ComputeMergedLocation(DotSpatial.Topology.GeometriesGraph.Label,System.Int32)">
            <summary>
            The location for a given eltIndex for a node will be one
            of { Null, Interior, Boundary }.
            A node may be on both the boundary and the interior of a point;
            in this case, the rule is that the node is considered to be in the boundary.
            The merged location is the maximum of the two input values.
            </summary>
            <param name="label2"></param>
            <param name="eltIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Node.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Node.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Node.Coordinate">
            <summary>
            A Coordinate for this node
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Node.Edges">
            <summary>
            Gets the edges for this node
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.Node.IsIsolated">
            <summary>
            Gets a boolean that is true if this node is isolated
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.NodeFactory">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.NodeFactory.CreateNode(DotSpatial.Topology.Coordinate)">
            <summary>
            The basic node constructor does not allow for incident edges.
            </summary>
            <param name="coord"></param>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.NodeMap">
            <summary>
            A map of nodes, indexed by the coordinate of the node.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.NodeMap.#ctor(DotSpatial.Topology.GeometriesGraph.NodeFactory)">
             <summary>
            
             </summary>
             <param name="nodeFact"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.NodeMap.AddNode(DotSpatial.Topology.Coordinate)">
            <summary>
            This method expects that a node has a coordinate value.
            </summary>
            <param name="coord"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.NodeMap.AddNode(DotSpatial.Topology.GeometriesGraph.Node)">
             <summary>
            
             </summary>
             <param name="n"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.NodeMap.Add(DotSpatial.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            Adds a node for the start point of this EdgeEnd
            (if one does not already exist in this map).
            Adds the EdgeEnd to the (possibly new) node.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.NodeMap.Find(DotSpatial.Topology.Coordinate)">
            <returns>
            The node if found; null otherwise.
            </returns>
            <param name="coord"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.NodeMap.GetEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.NodeMap.GetBoundaryNodes(System.Int32)">
             <summary>
            
             </summary>
             <param name="geomIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.NodeMap.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.NodeMap.Values">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.PositionType">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.PositionType.On">
            <summary>
             An indicator that a Location is <c>on</c> a GraphComponent (0)
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.PositionType.Left">
            <summary>
            An indicator that a Location is to the <c>left</c> of a GraphComponent (1)
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.PositionType.Right">
            <summary>
            An indicator that a Location is to the <c>right</c> of a GraphComponent (2)
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.GeometriesGraph.PositionType.Parallel">
            <summary>
            An indicator that a Location is <c>is parallel to x-axis</c> of a GraphComponent (-1)
            /// </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.Position">
            <summary>
            A Position indicates the position of a Location relative to a graph component
            (Node, Edge, or Area).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.Position.Opposite(DotSpatial.Topology.GeometriesGraph.PositionType)">
            <summary>
            Returns Positions.Left if the position is Positions.Right,
            Positions.Right if the position is Left, or the position
            otherwise.
            </summary>
            <param name="position"></param>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.QuadrantOp">
            <summary>
            Utility functions for working with quadrants, which are numbered as follows:
            <para>
            1 | 0
            --+--
            2 | 3
            </para>
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.QuadrantOp.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.QuadrantOp.Quadrant(System.Double,System.Double)">
            <summary>
            Returns the quadrant of a directed line segment (specified as x and y
            displacements, which cannot both be 0).
            </summary>
            <param name="dx"></param>
            <param name="dy"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.QuadrantOp.Quadrant(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Returns the quadrant of a directed line segment from p0 to p1.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.QuadrantOp.IsOpposite(System.Int32,System.Int32)">
            <summary>
            Returns true if the quadrants are 1 and 3, or 2 and 4.
            </summary>
            <param name="quad1"></param>
            <param name="quad2"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.QuadrantOp.CommonHalfPlane(System.Int32,System.Int32)">
            <summary>
            Returns the right-hand quadrant of the halfplane defined by the two quadrants,
            or -1 if the quadrants are opposite, or the quadrant if they are identical.
            </summary>
            <param name="quad1"></param>
            <param name="quad2"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.QuadrantOp.IsInHalfPlane(System.Int32,System.Int32)">
            <summary>
            Returns whether the given quadrant lies within the given halfplane (specified
            by its right-hand quadrant).
            </summary>
            <param name="quad"></param>
            <param name="halfPlane"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.QuadrantOp.IsNorthern(System.Int32)">
            <summary>
            Returns true if the given quadrant is 0 or 1.
            </summary>
            <param name="quad"></param>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.TopologyLocation">
            <summary>
            A TopologyLocation is the labelling of a
            GraphComponent's topological relationship to a single Geometry.
            If the parent component is an area edge, each side and the edge itself
            have a topological location.  These locations are named:
             On: on the edge
             Left: left-hand side of the edge
             Right: right-hand side
            If the parent component is a line edge or node, there is a single
            topological relationship attribute, On.
            The possible values of a topological location are
            { Location.Null, Location.Exterior, Location.Boundary, Location.Interior }
            The labelling is stored in an array location[j] where
            where j has the values On, Left, Right.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.#ctor(System.Collections.Generic.ICollection{DotSpatial.Topology.LocationType})">
             <summary>
            
             </summary>
             <param name="location"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.#ctor(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType)">
            <summary>
            Constructs a TopologyLocation specifying how points on, to the left of, and to the
            right of some GraphComponent relate to some Geometry. Possible values for the
            parameters are Location.Null, Location.Exterior, Location.Boundary,
            and Location.Interior.
            </summary>
            <param name="on"></param>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.#ctor(DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="on"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.#ctor(DotSpatial.Topology.GeometriesGraph.TopologyLocation)">
             <summary>
            
             </summary>
             <param name="gl"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.Init(System.Int32)">
             <summary>
            
             </summary>
             <param name="size"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.Get(DotSpatial.Topology.GeometriesGraph.PositionType)">
             <summary>
            
             </summary>
             <param name="posIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.IsEqualOnSide(DotSpatial.Topology.GeometriesGraph.TopologyLocation,System.Int32)">
             <summary>
            
             </summary>
             <param name="le"></param>
             <param name="locIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.Flip">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.SetAllLocations(DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="locValue"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.SetAllLocationsIfNull(DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="locValue"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.SetLocation(DotSpatial.Topology.GeometriesGraph.PositionType,DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="locIndex"></param>
             <param name="locValue"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.SetLocation(DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="locValue"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.GetLocations">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.SetLocations(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="on"></param>
             <param name="left"></param>
             <param name="right"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.SetLocations(DotSpatial.Topology.GeometriesGraph.TopologyLocation)">
             <summary>
            
             </summary>
             <param name="gl"></param>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.AllPositionsEqual(DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="loc"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.Merge(DotSpatial.Topology.GeometriesGraph.TopologyLocation)">
            <summary>
            Merge updates only the Null attributes of this object
            with the attributes of another.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TopologyLocation.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.TopologyLocation.Item(DotSpatial.Topology.GeometriesGraph.PositionType)">
            <summary>
            Get calls Get(Positions posIndex),
            Set calls SetLocation(Positions locIndex, Locations locValue)
            </summary>
            <param name="posIndex"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.TopologyLocation.IsNull">
            <returns>
            <c>true</c> if all locations are Null.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.TopologyLocation.IsAnyNull">
            <returns>
            <c>true</c> if any locations are Null.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.TopologyLocation.IsArea">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.GeometriesGraph.TopologyLocation.IsLine">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.GeometriesGraph.TwoHorizontalEdgesException">
            <summary>
            A TwoHorizontalEdgesException Class
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.GeometriesGraph.TwoHorizontalEdgesException.#ctor">
            <summary>
            Creates a new instance of TwoHorizontalEdgesException
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.LinearRing">
            <summary>
            Basic implementation of <c>LinearRing</c>.
            The first and last point in the coordinate sequence must be equal.
            Either orientation of the ring is allowed.
            A valid ring must not self-intersect.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.LineString">
            <summary>
            Basic implementation of <c>LineString</c>.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.LineString.Empty">
            <summary>
            Represents an empty <c>LineString</c>.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.LineString._points">
            <summary>
            The points of this <c>LineString</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.LineString.#ctor(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},DotSpatial.Topology.IGeometryFactory)">
             <summary>
            
             </summary>
             <param name="points">
             The points of the linestring, or <c>null</c>
             to create the empty point. Consecutive points may not be equal.
             </param>
             <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.LineString.#ctor(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Creates a new LineString using the default factory
            </summary>
            <param name="points">
            The points of the linestring, or <c>null</c>
            to create the empty point. Consecutive points may not be equal.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.LineString.#ctor(DotSpatial.Topology.IBasicLineString)">
            <summary>
            Creates a new topologically complete LineString from a LineStringBase
            </summary>
            <param name="lineStringBase"></param>
        </member>
        <member name="M:DotSpatial.Topology.LineString.#ctor(DotSpatial.Topology.IBasicLineString,DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Constructor
            </summary>
            <param name="lineString">
            The points of the linestring, or <c>null</c>
            to create the empty point. Consecutive points may not be equal.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.LineString.#ctor(DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Creates an empty linestring using the specified factory.
            </summary>
            <param name="factory">An IGeometryFactory to use when specifying this linestring.</param>
        </member>
        <member name="M:DotSpatial.Topology.LineString.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
            Rather than using the factory trends, this will create a coordinate sequence by simply using the specified list of coordinates.
            </summary>
            <param name="coordinates">The list of coordinates to use as a new ICoordinateSequence</param>
        </member>
        <member name="M:DotSpatial.Topology.LineString.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.ICoordinate})">
            <summary>
            Rather than using the factory trends, this will create a coordinate sequence by simply using the specified list of coordinates.
            </summary>
            <param name="coordinates">The list of coordinates to use as a new ICoordinateSequence</param>
        </member>
        <member name="M:DotSpatial.Topology.LineString.Apply(DotSpatial.Topology.ICoordinateFilter)">
            <summary>
            Applys a given ICoordinateFilter to this LineString
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:DotSpatial.Topology.LineString.Apply(DotSpatial.Topology.IGeometryFilter)">
             <summary>
            
             </summary>
             <param name="filter"></param>
        </member>
        <member name="M:DotSpatial.Topology.LineString.Apply(DotSpatial.Topology.IGeometryComponentFilter)">
             <summary>
            
             </summary>
             <param name="filter"></param>
        </member>
        <member name="M:DotSpatial.Topology.LineString.CompareToSameClass(System.Object)">
            <summary>
            Performs a CompareTo opperation assuming that the specified object is a LineString
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineString.EqualsExact(DotSpatial.Topology.IGeometry,System.Double)">
            <summary>
            Tests the coordinates of this LineString against another geometry and returns true if they are identical.
            </summary>
            <param name="other"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineString.ClosestPoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Given the specified test point, this checks each segment, and will
            return the closest point on the specified segment.
            </summary>
            <param name="testPoint">The point to test.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineString.GetPointN(System.Int32)">
            <summary>
            Returns the N'th point as an Implementation of IPoint.  The specific
            implementation is just the DotSpatial.Geometries.Point
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineString.IsCoordinate(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns true if the given point is a vertex of this <c>LineString</c>.
            </summary>
            <param name="pt">The <c>Coordinate</c> to check.</param>
            <returns><c>true</c> if <c>pt</c> is one of this <c>LineString</c>'s vertices.</returns>
        </member>
        <member name="M:DotSpatial.Topology.LineString.Normalize">
            <summary>
            Normalizes a <c>LineString</c>.  A normalized linestring
            has the first point which is not equal to it's reflected point
            less than the reflected point.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.LineString.Reverse">
            <summary>
            Creates a <see cref="T:DotSpatial.Topology.LineString"/> whose coordinates are in the reverse order of this objects.
            </summary>
            <returns>A <see cref="T:DotSpatial.Topology.LineString"/> with coordinates in the reverse order.</returns>
        </member>
        <member name="M:DotSpatial.Topology.LineString.ComputeEnvelopeInternal">
            <summary>
            Returns the Envelope of this LineString
            </summary>
            <returns>An IEnvelope interface for the envelope containing this LineString</returns>
        </member>
        <member name="M:DotSpatial.Topology.LineString.OnCopy(DotSpatial.Topology.Geometry)">
            <summary>
            Returns a copy of this ILineString
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.LineString.GetCoordinateN(System.Int32)">
            <summary>
            Returns the Nth coordinate of the coordinate sequence making up this LineString
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineString.IsEquivalentClass(DotSpatial.Topology.IGeometry)">
            <summary>
            Tests other and returns true if other is a LineString
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineString.Offset(System.Double)">
            <summary>
            Calculates a new linestring representing a linestring that is offset by
            distance to the left.  Negative distances will be to the right.  The final
            LineString may be shorter or longer than the original.  Left is determined
            by the vector direction of the segment between the 0th and 1st points.
            Outside bends will be circular curves, rather than extended angles.
            </summary>
            <param name="distance">The double distance to create the offset LineString</param>
            <returns>A valid ILineString interface created from calculations performed on this LineString</returns>
        </member>
        <member name="P:DotSpatial.Topology.LineString.Count">
            <summary>
            Gets the integer count of the number of points in this LineString
            </summary>
            <value></value>
        </member>
        <member name="P:DotSpatial.Topology.LineString.Item(System.Int32)">
            <summary>
            Gets the ICoordinate that exists at the Nth index
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.LineString.Angle">
            <summary>
            Gets the value of the angle between the <see cref="P:DotSpatial.Topology.LineString.StartPoint"/>
            and the <see cref="P:DotSpatial.Topology.LineString.EndPoint"/>.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.Boundary">
            <summary>
            Gets a MultiPoint geometry that contains the StartPoint and Endpoint
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.BoundaryDimension">
            <summary>
            Gets False if the LineString is closed, or Point (0) otherwise, representing the endpoints
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.Coordinate">
            <summary>
            Gets the 0th coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.Coordinates">
            <summary>
            Gets a System.Array of the coordinates
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.Dimension">
            <summary>
            Gets the dimensionality of a Curve(1)
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.EndPoint">
            <summary>
            Gets the point corresponding to NumPoints-1 and returns it as an IPoint interface
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.FeatureType">
            <summary>
            This will always contain Line, even if it is technically empty
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.GeometryType">
            <summary>
            Gets a string that says "LineString"
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.IsClosed">
            <summary>
            Gets a boolean that is true if the EndPoint is geometrically equal to the StartPoint in 2 Dimensions
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.IsEmpty">
            <summary>
            Gets a boolean value that returns true if the count of points in this LineString is 0.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.IsRing">
            <summary>
            Gets a boolean that is true if this LineString is both closed (has the same start and end point)
            and simple (does not self-intersect)
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.IsSimple">
            <summary>
            Gets a boolean that is true if any part of this LineString intersects with itself
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.Length">
            <summary>
            Returns the length of this <c>LineString</c>
            </summary>
            <returns>The length of the polygon.</returns>
        </member>
        <member name="P:DotSpatial.Topology.LineString.NumPoints">
            <summary>
            Gets an integer count of the points.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineString.StartPoint">
            <summary>
            Gets the 0 index point as a valid implementation of IPoint interface
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.LinearRing.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
            Creates a new instance of a linear ring where the enumerable collection of
            coordinates represents the set of coordinates to add to the ring.
            </summary>
            <param name="coordinates"></param>
        </member>
        <member name="M:DotSpatial.Topology.LinearRing.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.ICoordinate})">
            <summary>
            Creates a new instance of a linear ring where the enumerable collection of
            coordinates represents the set of coordinates to add to the ring.
            </summary>
            <param name="coordinates"></param>
        </member>
        <member name="M:DotSpatial.Topology.LinearRing.#ctor(DotSpatial.Topology.IBasicLineString)">
            <summary>
            Constructor
            </summary>
            <param name="linestringbase"></param>
        </member>
        <member name="P:DotSpatial.Topology.LinearRing.IsSimple">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.LinearRing.GeometryType">
            <summary>
            Geometry Type
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LinearRing.IsClosed">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.LinearRing.FeatureType">
            <summary>
            This will always contain Line, even if it is technically empty
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.LineSegment">
            <summary>
            Represents a line segment defined by two <c>Coordinate</c>s.
            Provides methods to compute various geometric properties
            and relationships of line segments.
            This class is designed to be easily mutable (to the extent of
            having its contained points public).
            This supports a common pattern of reusing a single LineSegment
            object as a way of computing segment properties on the
            segments defined by arrays or lists of <c>Coordinate</c>s.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.#ctor(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Creates an instance of LineSegment from two coordiantes
            </summary>
            <param name="p0">The first point of the segment</param>
            <param name="p1">The second point of the segment</param>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.#ctor(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Creates a new instance of a LineSegment which implements
            ILineSegment and ILineSegmentBase from an ILineSegmentBase
            </summary>
            <param name="ls"></param>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.#ctor">
            <summary>
            Creates a new instance of a LineSegment which implements
            ILineSegment and ILineSegmentBase
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.GetCoordinate(System.Int32)">
            <summary>
            Retrieves the i'th coordiante.  Since there are only two,
            i can be either 0 or 1.
            </summary>
            <param name="i">Integer, specifies the coordiante</param>
            <returns>A topologically complete ICoordinate</returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.SetCoordinates(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Defines a new LineSegment based on the previous line segment
            </summary>
            <param name="ls">The ILineSegmentBase</param>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.SetCoordinates(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Sets the new coordinates using the ICoordinate interfaces specified
            </summary>
            <param name="p0">The first endpoint</param>
            <param name="p1">The second endpoint</param>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.OrientationIndex(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Determines the orientation of a LineSegment relative to this segment.
            The concept of orientation is specified as follows:
            Given two line segments A and L,
            A is to the left of a segment L if A lies wholly in the
            closed half-plane lying to the left of L
            A is to the right of a segment L if A lies wholly in the
            closed half-plane lying to the right of L
            otherwise, A has indeterminate orientation relative to L. This
            happens if A is collinear with L or if A crosses the line determined by L.
            </summary>
            <param name="seg">The <c>LineSegment</c> to compare.</param>
            <returns>
            1 if <c>seg</c> is to the left of this segment,
            -1 if <c>seg</c> is to the right of this segment,
            0 if <c>seg</c> has indeterminate orientation relative to this segment.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.Reverse">
            <summary>
            Reverses the direction of the line segment.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.Normalize">
            <summary>
            Puts the line segment into a normalized form.
            This is useful for using line segments in maps and indexes when
            topological equality rather than exact equality is desired.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.Distance(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Computes the distance between this line segment and another one.
            </summary>
            <param name="ls"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.Distance(DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the distance between this line segment and a point.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.DistancePerpendicular(DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the perpendicular distance between the (infinite) line defined
            by this line segment and a point.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.ProjectionFactor(DotSpatial.Topology.Coordinate)">
            <summary>
            Compute the projection factor for the projection of the point p
            onto this <c>LineSegment</c>. The projection factor is the constant k
            by which the vector for this segment must be multiplied to
            equal the vector for the projection of p.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.Project(DotSpatial.Topology.Coordinate)">
            <summary>
            Compute the projection of a point onto the line determined
            by this line segment.
            Notice that the projected point
            may lie outside the line segment.  If this is the case,
            the projection factor will lie outside the range [0.0, 1.0].
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.Project(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Project a line segment onto this line segment and return the resulting
            line segment.  The returned line segment will be a subset of
            the target line line segment.  This subset may be null, if
            the segments are oriented in such a way that there is no projection.
            Notice that the returned line may have zero length (i.e. the same endpoints).
            This can happen for instance if the lines are perpendicular to one another.
            </summary>
            <param name="seg">The line segment to project.</param>
            <returns>The projected line segment, or <c>null</c> if there is no overlap.</returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.ClosestPoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the closest point on this line segment to another point.
            </summary>
            <param name="p">The point to find the closest point to.</param>
            <returns>
            A Coordinate which is the closest point on the line segment to the point p.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.ClosestPoints(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Computes the closest points on a line segment.
            </summary>
            <param name="line"></param>
            <returns>
            A pair of Coordinates which are the closest points on the line segments.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.Intersection(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Computes an intersection point between two segments, if there is one.
            There may be 0, 1 or many intersection points between two segments.
            If there are 0, null is returned. If there is 1 or more, a single one
            is returned (chosen at the discretion of the algorithm).  If
            more information is required about the details of the intersection,
            the {RobustLineIntersector} class should be used.
            </summary>
            <param name="line"></param>
            <returns> An intersection point, or <c>null</c> if there is none.</returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.Intersection(DotSpatial.Topology.Envelope)">
            <summary>
            Performs an intersection of this line segment with the specified envelope
            </summary>
            <param name="inEnvelope">The envelope to compare against</param>
            <returns>An ILineSegment, or null if there is no intersection.</returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.Intersects(DotSpatial.Topology.Envelope)">
            <summary>
            Determines if any portion of this segment intersects the specified extent.
            </summary>
            <param name="inEnvelope">The</param>
            <returns>Boolean, true if this line segment intersects the specified envelope</returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.CompareTo(System.Object)">
            <summary>
            Compares this object with the specified object for order.
            Uses the standard lexicographic ordering for the points in the LineSegment.
            </summary>
            <param name="o">
            The <c>LineSegment</c> with which this <c>LineSegment</c>
            is being compared.
            </param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>LineSegment</c>
            is less than, equal to, or greater than the specified <c>LineSegment</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.EqualsTopologically(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Returns <c>true</c> if <c>other</c> is
            topologically equal to this LineSegment (e.g. irrespective
            of orientation).
            </summary>
            <param name="other">
            A <c>LineSegment</c> with which to do the comparison.
            </param>
            <returns>
            <c>true</c> if <c>other</c> is a <c>LineSegment</c>
            with the same values for the x and y ordinates.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <c>o</c> has the same values for its points.
            </summary>
            <param name="o">A <c>LineSegment</c> with which to do the comparison.</param>
            <returns>
            <c>true</c> if <c>o</c> is a <c>LineSegment</c>
            with the same values for the x and y ordinates.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.op_Equality(DotSpatial.Topology.LineSegment,DotSpatial.Topology.ILineSegmentBase)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.op_Inequality(DotSpatial.Topology.LineSegment,DotSpatial.Topology.ILineSegmentBase)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.LineSegment.GetHashCode">
            <summary>
            Return HashCode.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineSegment.P1">
            <summary>
            returns the one of the ICoordinate that defines this linesegment
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineSegment.P0">
            <summary>
            returns the ICoordianteBase defining the second endpoint of the segment
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.LineSegment.Length">
            <summary>
            Computes the length of the line segment.
            </summary>
            <returns>The length of the line segment.</returns>
        </member>
        <member name="P:DotSpatial.Topology.LineSegment.IsHorizontal">
            <summary>
            Tests whether the segment is horizontal.
            </summary>
            <returns><c>true</c> if the segment is horizontal.</returns>
        </member>
        <member name="P:DotSpatial.Topology.LineSegment.IsVertical">
            <summary>
            Tests whether the segment is vertical.
            </summary>
            <returns><c>true</c> if the segment is vertical.</returns>
        </member>
        <member name="P:DotSpatial.Topology.LineSegment.Angle">
            <returns>
            The angle this segment makes with the x-axis (in radians).
            </returns>
        </member>
        <member name="T:DotSpatial.Topology.Location">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Location.ToLocationSymbol(DotSpatial.Topology.LocationType)">
            <summary>
            Converts the location value to a location symbol, for example, <c>EXTERIOR => 'e'</c>.
            </summary>
            <param name="locationValue"></param>
            <returns>Either 'e', 'b', 'i' or '-'.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Matrix4">
            <summary>
            Matrix4
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.MatrixD">
            <summary>
            A 4 x 4 matrix is required for transformations in 3 dimensions
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.MatrixD.#ctor(System.Int32)">
            <summary>
            Creates a new squre identity matrix of the specified size
            </summary>
            <param name="m">The size of the matrix to create</param>
        </member>
        <member name="M:DotSpatial.Topology.MatrixD.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of Matrix with m rows and n columns
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.MatrixD.#ctor(System.Double[0:,0:])">
            <summary>
            Creates a matrix using the specified values.
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:DotSpatial.Topology.MatrixD.Multiply(DotSpatial.Topology.IMatrixD)">
            <summary>
            Matrix multiplication only works if the number of columns of the first matrix is the same
            as the number of rows of the second matrix.  The first matrix is this object, so this
            will only work if inMatrix has the same number of rows as this matrix has columns.
            </summary>
            <param name="inMatrix">The IMatrix to multiply against this matrix</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.MatrixD.Multiply(System.Double)">
            <summary>
            Multiplies this matrix by the specified scalar value.
            </summary>
            <param name="inScalar"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.MatrixD.M">
            <summary>
            Gets the number of rows
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.MatrixD.N">
            <summary>
            Gets the number of columns
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.MatrixD.NumRows">
            <summary>
            Gets the number of rows
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.MatrixD.NumColumns">
            <summary>
            Gets the number of columns
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.MatrixD.Values">
            <summary>
            Gets or sets the values for this matrix
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Matrix4.#ctor">
            <summary>
            Creates a new instance of Matrix4 that is an identity matrix
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Matrix4.RotateX(System.Double)">
            <summary>
            Rotates this matrix by the specified angle in degrees about the X axis.
            </summary>
            <param name="degrees">Specified the angle in degrees to rotate counter clockwise about the positive axis</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Matrix4.RotateY(System.Double)">
            <summary>
            Rotates this matrix by the specified angle in degrees about the Y axis.
            </summary>
            <param name="degrees"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Matrix4.RotateZ(System.Double)">
            <summary>
            Rotates this matrix by the specified angle in degrees about the Z axis.
            </summary>
            <param name="degrees"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Matrix4.Translate(System.Double,System.Double,System.Double)">
            <summary>
            Translates the matrix by the specified amount in each of the directions
            by multiplying by a translation matrix created from the specified values.
            </summary>
            <param name="x">The translation in the X coordinate</param>
            <param name="y">The translation in the Y coordinate</param>
            <param name="z">The translation in the Z coordinate</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Matrix4.RotationX(System.Double)">
            <summary>
            Creates a 4 x 4 matrix that can be used to rotate a 3D vector about the X axis.
            </summary>
            <param name="degrees">The counter-clockwise angle of rotation when looking at the origin from the positive axis</param>
            <returns>A 4x4 rotation matrix</returns>
        </member>
        <member name="M:DotSpatial.Topology.Matrix4.RotationY(System.Double)">
            <summary>
            Creates a 4 x 4 matrix that can be used to rotate a 3D vector about the Y axis.
            </summary>
            <param name="degrees">The counter-clockwise angle of rotation when looking at the origin from the positive axis</param>
            <returns>A 4x4 rotation matrix</returns>
        </member>
        <member name="M:DotSpatial.Topology.Matrix4.RotationZ(System.Double)">
            <summary>
            Creates a 4 x 4 matrix that can be used to rotate a 3D vector about the Z axis.
            </summary>
            <param name="degrees">The counter-clockwise angle of rotation when looking at the origin from the positive axis</param>
            <returns>A 4x4 rotation matrix</returns>
        </member>
        <member name="M:DotSpatial.Topology.Matrix4.Translation(System.Double,System.Double,System.Double)">
            <summary>
            Creates a 4 x 4 matrix where all the values represent an identity matrix except
            that the bottom row has been set to be the translation values.  The result is
            that if a 3D vector is transformed by this matrix, the last row will
            control the translation terms.
            </summary>
            <param name="x">The translation in the x direction</param>
            <param name="y">The translation in the y direction</param>
            <param name="z">The translation in the z direction</param>
            <returns>The translation matrix</returns>
        </member>
        <member name="P:DotSpatial.Topology.Matrix4.Identity">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.MultiLineString">
            <summary>
            Basic implementation of <c>MultiLineString</c>.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.MultiLineString.Empty">
            <summary>
            Represents an empty <c>MultiLineString</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.MultiLineString.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.IBasicLineString})">
            <summary>
            Constructs a multiLineString from the list of IBasicLineStrings, creating new full geometries where necessary.
            </summary>
            <param name="lineStrings">An IBasicLineString that is either a full IGeometry itself, or will be cast into one by this step</param>
        </member>
        <member name="M:DotSpatial.Topology.MultiLineString.#ctor(DotSpatial.Topology.IBasicLineString[],DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Constructs a <c>MultiLineString</c>.
            </summary>
            <param name="lineStrings">
            The <c>LineString</c>s for this <c>MultiLineString</c>,
            or <c>null</c> or an empty array to create the empty
            point. Elements may be empty <c>LineString</c>s,
            but not <c>null</c>s.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.MultiLineString.#ctor(DotSpatial.Topology.IBasicGeometry)">
            <summary>
            This will attempt to create a new MultiLineString from the specified basic geometry.
            </summary>
            <param name="inBasicGeometry">A Basic geometry that shoule be a LineString or MultiLineString</param>
        </member>
        <member name="M:DotSpatial.Topology.MultiLineString.#ctor(DotSpatial.Topology.IBasicGeometry,DotSpatial.Topology.IGeometryFactory)">
            <summary>
            This will attempt to create a new MultiLineString from the specified basic geometry.
            </summary>
            <param name="inBasicGeometry">A Basic geometry that shoule be a LineString or MultiLineString</param>
            <param name="inFactory">Any valid Geometry Factory</param>
        </member>
        <member name="M:DotSpatial.Topology.MultiLineString.#ctor(DotSpatial.Topology.IBasicLineString[])">
            <summary>
            Constructs a <c>MultiLineString</c>.
            </summary>
            <param name="lineStrings">
            The <c>LineString</c>s for this <c>MultiLineString</c>,
            or <c>null</c> or an empty array to create the empty
            point. Elements may be empty <c>LineString</c>s,
            but not <c>null</c>s.
            </param>
            <remarks>
            For create this <see cref="T:DotSpatial.Topology.Geometry"/> is used a standard <see cref="T:DotSpatial.Topology.GeometryFactory"/>
            with <see cref="T:DotSpatial.Topology.PrecisionModel"/> <c> == </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.Floating"/>.
            </remarks>
        </member>
        <member name="M:DotSpatial.Topology.MultiLineString.#ctor">
            <summary>
            Constructor for a MultiLineString that is empty
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.MultiLineString.EqualsExact(DotSpatial.Topology.IGeometry,System.Double)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.MultiLineString.Reverse">
            <summary>
            Creates a <see cref="T:DotSpatial.Topology.MultiLineString"/> in the reverse order to this object.
            Both the order of the component LineStrings
            and the order of their coordinate sequences are reversed.
            </summary>
            <returns>a <see cref="T:DotSpatial.Topology.MultiLineString"/> in the reverse order.</returns>
        </member>
        <member name="P:DotSpatial.Topology.MultiLineString.IsClosed">
            <summary>
            Gets a value indicating whether this instance is closed.
            </summary>
            <value><c>true</c> if this instance is closed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:DotSpatial.Topology.MultiLineString.Dimension">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="P:DotSpatial.Topology.MultiLineString.BoundaryDimension">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="P:DotSpatial.Topology.MultiLineString.GeometryType">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="P:DotSpatial.Topology.MultiLineString.IsSimple">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="P:DotSpatial.Topology.MultiLineString.Boundary">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="P:DotSpatial.Topology.MultiLineString.FeatureType">
            <summary>
            Always returns FeatureTypes.Line
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.MultiLineString.Item(System.Int32)">
            <summary>
            Gets the ILineString that corresponds to the specified index
            </summary>
            <param name="index">The integer index to get a linestring</param>
            <returns>An ILineString</returns>
        </member>
        <member name="T:DotSpatial.Topology.MultiPoint">
            <summary>
            Models a collection of <c>Point</c>s.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.MultiPoint.Empty">
            <summary>
            Represents an empty <c>MultiPoint</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.MultiPoint.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate},DotSpatial.Topology.IGeometryFactory)">
             <summary>
             Constructs a <c>MultiPoint</c>.
             </summary>
             <param name="points">
             The <c>Point</c>s for this <c>MultiPoint</c>
            , or <c>null</c> or an empty array to create the empty point.
             Elements may be empty <c>Point</c>s, but not <c>null</c>s.
             </param>
             <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.MultiPoint.#ctor(DotSpatial.Topology.IBasicGeometry)">
            <summary>
            This will attempt to create a new MultiPoint from the specified basic geometry.
            </summary>
            <param name="inBasicGeometry">A Point or MultiPoint</param>
        </member>
        <member name="M:DotSpatial.Topology.MultiPoint.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
            Creates new Multipoint using interface points
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:DotSpatial.Topology.MultiPoint.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.ICoordinate})">
            <summary>
            Creates new Multipoint using interface points
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:DotSpatial.Topology.MultiPoint.EqualsExact(DotSpatial.Topology.IGeometry,System.Double)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.MultiPoint.CastPoints(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
            Converts an array of point interface variables into local points.
            Eventually I hope to reduce the amount of "casting" necessary, in order
            to allow as much as possible to occur via an interface.
            </summary>
            <param name="rawPoints"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.MultiPoint.CastPoints(System.Collections.Generic.IEnumerable{DotSpatial.Topology.ICoordinate})">
            <summary>
            Converts an array of point interface variables into local points.
            Eventually I hope to reduce the amount of "casting" necessary, in order
            to allow as much as possible to occur via an interface.
            </summary>
            <param name="rawPoints"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.MultiPoint.GetCoordinate(System.Int32)">
            <summary>
            Returns the <c>Coordinate</c> at the given position.
            </summary>
            <param name="n">The index of the <c>Coordinate</c> to retrieve, beginning at 0.
            </param>
            <returns>The <c>n</c>th <c>Coordinate</c>.</returns>
        </member>
        <member name="P:DotSpatial.Topology.MultiPoint.Dimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.MultiPoint.BoundaryDimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.MultiPoint.GeometryType">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.MultiPoint.FeatureType">
            <inheritdoc />
        </member>
        <member name="P:DotSpatial.Topology.MultiPoint.Boundary">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.MultiPoint.IsSimple">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.MultiPoint.IsValid">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.MultiPoint.Item(System.Int32)">
            <summary>
            Gets or sets the point that resides at the specified index
            </summary>
            <param name="index">A zero-based integer index specifying the point to get or set</param>
            <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.MultiPolygon">
            <summary>
            Basic implementation of <c>MultiPolygon</c>.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.MultiPolygon.Empty">
            <summary>
            Represents an empty <c>MultiPolygon</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.MultiPolygon.#ctor(DotSpatial.Topology.Polygon[])">
             <summary>
             Constructs a <c>MultiPolygon</c>.
             </summary>
             <param name="polygons">
             The <c>Polygon</c>s for this <c>MultiPolygon</c>
            , or <c>null</c> or an empty array to create the empty point.
             Elements may be empty <c>Polygon</c>s, but not <c>null</c>
             s. The polygons must conform to the assertions specified in the
             <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features
             Specification for SQL.
             </param>
             <remarks>
             For create this <see cref="T:DotSpatial.Topology.Geometry"/> is used a standard <see cref="T:DotSpatial.Topology.GeometryFactory"/>
             with <see cref="T:DotSpatial.Topology.PrecisionModel"/> <c> == </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.Floating"/>.
             </remarks>
        </member>
        <member name="M:DotSpatial.Topology.MultiPolygon.#ctor(DotSpatial.Topology.IBasicPolygon[])">
            <summary>
            This was added by Ted Dunsford to allow the construction of MultiPolygons
            from an array of basic polygon interfaces.
            </summary>
            <param name="polygons"></param>
        </member>
        <member name="M:DotSpatial.Topology.MultiPolygon.#ctor(DotSpatial.Topology.IBasicGeometry)">
            <summary>
            This will attempt to create a new MultiPolygon from the specified basic geometry.
            </summary>
            <param name="inBasicGeometry">A Polygon or MultiPolygon</param>
        </member>
        <member name="M:DotSpatial.Topology.MultiPolygon.#ctor(DotSpatial.Topology.IBasicGeometry,DotSpatial.Topology.IGeometryFactory)">
            <summary>
            This will attempt to create a new MultiPolygon from the specified basic geometry.
            </summary>
            <param name="inBasicGeometry">A Polygon or MultiPolygon</param>
            <param name="inFactory">An implementation of the IGeometryFactory interface</param>
        </member>
        <member name="M:DotSpatial.Topology.MultiPolygon.#ctor(DotSpatial.Topology.IPolygon[],DotSpatial.Topology.IGeometryFactory)">
             <summary>
             Constructs a <c>MultiPolygon</c>.
             </summary>
             <param name="polygons">
             The <c>Polygon</c>s for this <c>MultiPolygon</c>
            , or <c>null</c> or an empty array to create the empty point.
             Elements may be empty <c>Polygon</c>s, but not <c>null</c>
             s. The polygons must conform to the assertions specified in the
             <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features
             Specification for SQL.
             </param>
             <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.MultiPolygon.EqualsExact(DotSpatial.Topology.IGeometry,System.Double)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.MultiPolygon.FromBasicGeometry(DotSpatial.Topology.IBasicGeometry)">
            <summary>
            Presuming that the specified basic geometry describes a MultiPolygon, this will perform the necessary
            casting in order to create a MultiPolygon.  If, in fact, it is only a BasicMultiPolygon, this will
            create a new, fully functional MultiPolygon based on the same coordinates.
            </summary>
            <param name="inGeometry">The IBasicGeometry to turn into a MultiPolygon. </param>
        </member>
        <member name="P:DotSpatial.Topology.MultiPolygon.Dimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.MultiPolygon.BoundaryDimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.MultiPolygon.GeometryType">
            <summary>
            Always returns "MultiPolygon"
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.MultiPolygon.FeatureType">
            <summary>
            Always Polygon
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.MultiPolygon.IsSimple">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.MultiPolygon.Boundary">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Point">
            <summary>
            Basic implementation of Point.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Point.#ctor">
            <summary>
            Creates a null point with X = 0, Y = 0, which can have its properties set later.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Point.#ctor(DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Creates a null point with X = 0, Y = 0 but using the specified factory for
            precision and SRID stuff.
            </summary>
            <param name="factory">The factory to use when creating this geometry.</param>
        </member>
        <member name="M:DotSpatial.Topology.Point.#ctor(DotSpatial.Topology.Coordinate)">
            <summary>
            Initializes a new instance of the Point class.
            </summary>
            <param name="coordinate">The coordinate used for create this <see cref="T:DotSpatial.Topology.Point"/>.</param>
            <remarks>
            For create this <see cref="T:DotSpatial.Topology.Geometry"/> is used a standard <see cref="T:DotSpatial.Topology.GeometryFactory"/>
            with <see cref="T:DotSpatial.Topology.PrecisionModel"/> <c> == </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.Floating"/>.
            </remarks>
        </member>
        <member name="M:DotSpatial.Topology.Point.#ctor(DotSpatial.Topology.ICoordinate)">
            <summary>
            Initializes a new instance of the Point class.
            </summary>
            <param name="coordinate">The coordinate used for create this <see cref="T:DotSpatial.Topology.Point"/>.</param>
            <remarks>
            For create this <see cref="T:DotSpatial.Topology.Geometry"/> is used a standard <see cref="T:DotSpatial.Topology.GeometryFactory"/>
            with <see cref="T:DotSpatial.Topology.PrecisionModel"/> <c> == </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.Floating"/>.
            </remarks>
        </member>
        <member name="M:DotSpatial.Topology.Point.#ctor(DotSpatial.Topology.Coordinate,DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Constructs a <c>Point</c> with the given coordinate.
            </summary>
            <param name="coordinate">
            Contains the single coordinate on which to base this <c>Point</c>,
            or <c>null</c> to create the empty point.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.Point.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the Point class.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="z">The z coordinate.</param>
            /// <remarks>
            For create this <see cref="T:DotSpatial.Topology.Geometry"/> is used a standard <see cref="T:DotSpatial.Topology.GeometryFactory"/>
            with <see cref="T:DotSpatial.Topology.PrecisionModel"/> <c> set to </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.Floating"/>.
            </remarks>
        </member>
        <member name="M:DotSpatial.Topology.Point.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the Point class.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            /// <remarks>
            For create this <see cref="T:DotSpatial.Topology.Geometry"/> is used a standard <see cref="T:DotSpatial.Topology.GeometryFactory"/>
            with <see cref="T:DotSpatial.Topology.PrecisionModel"/> <c> set to </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.Floating"/>.
            </remarks>
        </member>
        <member name="F:DotSpatial.Topology.Point.Empty">
            <summary>
            Represents an empty <c>Point</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Point.Apply(DotSpatial.Topology.ICoordinateFilter)">
            <summary>
            Performs an operation with or on this <c>Geometry</c>'s
            coordinates. If you are using this method to modify the point, be sure
            to call GeometryChanged() afterwards. Notice that you cannot use this
            method to
            modify this Geometry if its underlying CoordinateSequence's Get method
            returns a copy of the Coordinate, rather than the actual Coordinate stored
            (if it even stores Coordinates at all).
            </summary>
            <param name="filter">The filter to apply to this <c>Geometry</c>'s coordinates</param>
        </member>
        <member name="M:DotSpatial.Topology.Point.Apply(DotSpatial.Topology.IGeometryFilter)">
            <summary>
            Performs an operation with or on this <c>Geometry</c> and its
            subelement <c>Geometry</c>s (if any).
            Only GeometryCollections and subclasses
            have subelement Geometry's.
            </summary>
            <param name="filter">
            The filter to apply to this <c>Geometry</c> (and
            its children, if it is a <c>GeometryCollection</c>).
            </param>
        </member>
        <member name="M:DotSpatial.Topology.Point.Apply(DotSpatial.Topology.IGeometryComponentFilter)">
            <summary>
            Performs an operation with or on this Geometry and its
            component Geometry's. Only GeometryCollections and
            Polygons have component Geometry's; for Polygons they are the LinearRings
            of the shell and holes.
            </summary>
            <param name="filter">The filter to apply to this <c>Geometry</c>.</param>
        </member>
        <member name="M:DotSpatial.Topology.Point.CompareToSameClass(System.Object)">
            <summary>
            Returns whether this <c>Geometry</c> is greater than, equal to,
            or less than another <c>Geometry</c> having the same class.
            </summary>
            <param name="other">A <c>Geometry</c> having the same class as this <c>Geometry</c>.</param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <c>o</c>, as
            defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Point.ClosestPoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Given the specified test point, this returns the closest point in this geometry.
            </summary>
            <param name="testPoint"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Point.EqualsExact(DotSpatial.Topology.IGeometry,System.Double)">
            EqualsExact
            <summary>
            Returns true if the two <c>Geometry</c>s are exactly equal,
            up to a specified tolerance.
            Two Geometries are exactly within a tolerance equal iff:
            they have the same class,
            they have the same values of Coordinates,
            within the given tolerance distance, in their internal
            Coordinate lists, in exactly the same order.
            If this and the other <c>Geometry</c>s are
            composites and any children are not <c>Geometry</c>s, returns
            false.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <param name="tolerance">Distance at or below which two Coordinates will be considered equal.</param>
            <returns>
            <c>true</c> if this and the other <c>Geometry</c>
            are of the same class and have equal internal data.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Point.Normalize">
            Normalize
            <summary>
            Converts this <c>Geometry</c> to normal form (or
            canonical form ). Normal form is a unique representation for <c>Geometry</c>
            s. It can be used to test whether two <c>Geometry</c>s are equal
            in a way that is independent of the ordering of the coordinates within
            them. Normal form equality is a stronger condition than topological
            equality, but weaker than pointwise equality. The definitions for normal
            form use the standard lexicographical ordering for coordinates. "Sorted in
            order of coordinates" means the obvious extension of this ordering to
            sequences of coordinates.  This does nothing for points.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Point.OnCopy(DotSpatial.Topology.Geometry)">
            <summary>
            Creates a copy of this Point with the same factory
            specifications and values.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Point.ComputeEnvelopeInternal">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Point.Distance(DotSpatial.Topology.Coordinate)">
            <summary>
            Calculates the vector distance.  (This is a 2D opperation)
            </summary>
            <param name="coord">Any valid implementation of the ICoordinate Interface</param>
            <returns>The Euclidean distance between two points {Sqrt((X2 - X1)^2 + (Y2 - Y1)^2)</returns>
        </member>
        <member name="M:DotSpatial.Topology.Point.HyperDistance(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns the distance that is appropriate for N dimensions.  In otherwords, if this point is
            three dimensional, then all three dimensions will be used for calculating the distance.
            </summary>
            <param name="coordinate">The coordinate to compare to this coordinate</param>
            <returns>A double valued distance measure that is invariant to the number of coordinates</returns>
            <exception cref="T:DotSpatial.Topology.CoordinateMismatchException">The number of dimensions does not match between the points.</exception>
        </member>
        <member name="M:DotSpatial.Topology.Point.Equals2D(DotSpatial.Topology.Coordinate)">
            <summary>
            Tests to see if the X coordinate and Y coordinate are the same between this point and the
            specified Coordinate
            </summary>
            <param name="coord">Any valid implementation of the ICoordinate Interface</param>
            <returns>True if the coordinates are equal, false otherwise</returns>
        </member>
        <member name="M:DotSpatial.Topology.Point.Equals3D(DotSpatial.Topology.Coordinate)">
            <summary>
            Tests to see if the X, Y, and Z coordinate are the same between this point and the
            specified Coordinate
            </summary>
            <param name="coord">Any valid implementation of the ICoordinate Interface</param>
            <returns>True if the coordinates are equal, false otherwise</returns>
        </member>
        <member name="M:DotSpatial.Topology.Point.SetCoordinate(DotSpatial.Topology.Coordinate)">
            <summary>
            Sets the coordinate.
            </summary>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:DotSpatial.Topology.Point.ToArray">
            <summary>
            Creates an array of ordinate values that is the size of NumDimensions.  This
            will not include an M value.
            </summary>
            <returns>An Array of double values, with one value for each ordinate.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Point.Item(System.Int32)">
            <summary>
            Gets or sets the double value of the specific ordinate
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Point.RecordNumber">
            <summary>
            This is an optional recordnumber index, used specifically for Shapefile points.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.Boundary">
            Boundary
            <summary>
            Returns the boundary, or the empty point if this <c>Geometry</c>
            is empty. For a discussion of this function, see the OpenGIS Simple
            Features Specification. As stated in SFS Section 2.1.13.1, "the boundary
            of a Geometry is a set of Geometries of the next lower dimension."
            </summary>
            <returns>The closure of the combinatorial boundary of this <c>Geometry</c>.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Point.BoundaryDimension">
            <summary>
            Returns the dimension of this <c>Geometry</c>s inherent boundary.
            </summary>
            <returns>
            The dimension of the boundary of the class implementing this
            interface, whether or not this object is the empty point. Returns
            <c>Dimension.False</c> if the boundary is the empty point.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.Point.Coordinate">
            Coordinate
            <summary>
            Returns a vertex of this Geometry
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.Coordinates">
            <summary>
            People might access "Coordinates".  If we spontaneously generate a list from
            our single coordinate, thne we will have problems.
            They cannot SET the coordinate like myPoint.Coordinates[0].X = 5.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.Dimension">
            Dimension
            <summary>
            Gets or sets the DotSpatial.Geometries.Dimensions of this Geometry.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.NumOrdinates">
            <summary>
            Gets the number of ordinates that are being used by the underlying coordinate for
            this point.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.Envelope">
            <summary>
            Envelope containing this
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.FeatureType">
            <summary>
            This will always contain points, even if it is technically empty
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.GeometryType">
            <summary>
            returns Point
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.IsEmpty">
            IsEmpty
            <summary>
            Returns whether or not the set of points in this geometry is empty
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.IsSimple">
            IsSimple
            <summary>
            Returns false if the Geometry not simple.  Subclasses provide their own definition
            of "simple". If this Geometry is empty, returns true. In general, the SFS specifications
            of simplicity seem to follow the following rule: A Geometry is simple if the only
            self-intersections are at boundary points.  For all empty Geometrys, IsSimple==true.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.IsValid">
            IsValid
            <summary>
            Tests the validity of this Geometry.  Subclasses provide their own definition of "valid"
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.M">
            <summary>
            The measure coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.NumPoints">
            <summary>
            The integer number of points.  In this case it is either 1 or 0 if the point is empty.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.Values">
            <summary>
            Gets or sets the ordinates directly as an array of double values for this point.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.X">
            <summary>
            The X coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.Y">
            <summary>
            The Y coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Point.Z">
            <summary>
            The Z coordinate
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Polygon">
            <summary>
            Represents a linear polygon, which may include holes.
            The shell and holes of the polygon are represented by {LinearRing}s.
            In a valid polygon, holes may touch the shell or other holes at a single point.
            However, no sequence of touching holes may split the polygon into two pieces.
            The orientation of the rings in the polygon does not matter.
            The shell and holes must conform to the assertions specified in the
            <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features Specification for SQL.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.#ctor(DotSpatial.Topology.ILinearRing,DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>,
            or <c>null</c> or an empty <c>LinearRing</c> if the empty
            polygon is to be created.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.#ctor(DotSpatial.Topology.ILinearRing)">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>,
            or <c>null</c> or an empty <c>LinearRing</c> if the empty
            polygon is to be created.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.#ctor(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
            <summary>
            Generates a new polygon using the default geometry factory from the specified set of coordinates,
            where the coordinates will become the polygon shell.
            </summary>
            <param name="shell">The shell of the polygon expressed as an enumerable collection of ICoordinate</param>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.#ctor(DotSpatial.Topology.ILinearRing,DotSpatial.Topology.ILinearRing[])">
             <summary>
             Initializes a new instance of the Polygon class.
             </summary>
             <param name="shell">
             The outer boundary of the new <c>Polygon</c>,
             or <c>null</c> or an empty <c>LinearRing</c> if the empty
             point is to be created.
             </param>
             <param name="holes">
             The inner boundaries of the new <c>Polygon</c>
            , or <c>null</c> or empty <c>LinearRing</c>s if the empty
             point is to be created.
             </param>
             <remarks>
             For create this <see cref="T:DotSpatial.Topology.Geometry"/> is used a standard <see cref="T:DotSpatial.Topology.GeometryFactory"/>
             with <see cref="T:DotSpatial.Topology.PrecisionModel"/> <c> == </c> <see cref="F:DotSpatial.Topology.PrecisionModelType.Floating"/>.
             </remarks>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.#ctor(DotSpatial.Topology.ILinearRing,DotSpatial.Topology.ILinearRing[],DotSpatial.Topology.IGeometryFactory)">
             <summary>
             Constructs a <c>Polygon</c> with the given exterior boundary and
             interior boundaries.
             </summary>
             <param name="inShell">
             The outer boundary of the new <c>Polygon</c>,
             or <c>null</c> or an empty <c>LinearRing</c> if the empty
             point is to be created.
             </param>
             <param name="inHoles">
             The inner boundaries of the new <c>Polygon</c>
            , or <c>null</c> or empty <c>LinearRing</c>s if the empty
             point is to be created.
             </param>
             <param name="factory"></param>
             <exception cref="T:DotSpatial.Topology.PolygonException">Holes must not contain null elements</exception>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.#ctor(DotSpatial.Topology.IBasicPolygon)">
            <summary>
            Constructor for a polygon
            </summary>
            <param name="polygonBase">A simpler BasicPolygon to empower with topology functions</param>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.Apply(DotSpatial.Topology.ICoordinateFilter)">
             <summary>
            
             </summary>
             <param name="filter"></param>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.Apply(DotSpatial.Topology.IGeometryFilter)">
             <summary>
            
             </summary>
             <param name="filter"></param>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.Apply(DotSpatial.Topology.IGeometryComponentFilter)">
             <summary>
            
             </summary>
             <param name="filter"></param>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.CompareToSameClass(System.Object)">
             <summary>
            
             </summary>
             <param name="o"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.ClearEnvelope">
            <summary>
            Clears any cached envelopes
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.ConvexHull">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.EqualsExact(DotSpatial.Topology.IGeometry,System.Double)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <param name="tolerance"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.ClosestPoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Given the specified test point, this checks each segment, and will
            return the closest point on the specified segment.
            </summary>
            <param name="testPoint">The point to test.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.GetInteriorRingN(System.Int32)">
             <summary>
            
             </summary>
             <param name="n"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.Normalize">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.OnCopy(DotSpatial.Topology.Geometry)">
            <summary>
            Occurs during the copy process and ensures that the shell and holes are all duplicated and not direct references
            </summary>
            <param name="copy"></param>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.ComputeEnvelopeInternal">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.Normalize(DotSpatial.Topology.ILinearRing,System.Boolean)">
             <summary>
            
             </summary>
             <param name="ring"></param>
             <param name="clockwise"></param>
        </member>
        <member name="M:DotSpatial.Topology.Polygon.SetHoles(System.Collections.Generic.ICollection{DotSpatial.Topology.IBasicLineString})">
            <summary>
            Hole data might actually already be cast appropriately, but it might need to be
            converted into an array of linear rings.
            </summary>
            <param name="holeData"></param>
        </member>
        <member name="F:DotSpatial.Topology.Polygon.Empty">
            <summary>
            Represents an empty <c>Polygon</c>.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.ExteriorRing">
            <summary>
            This is just the Shell, but modified to work with IBasicPolygon
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.Area">
            <summary>
            Returns the area of this <c>Polygon</c>
            </summary>
            <returns>Area in Meters (by default) when using projected coordinates.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.Boundary">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.BoundaryDimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.Coordinates">
            <summary>
            Gets all the coordinates for the polygon.  Setting this assumes that all the coordintes
            belong in the shell.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.Dimension">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.FeatureType">
            <summary>
            This will always contain points, even if it is technically empty
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.GeometryType">
            <summary>
            Specifically returns a Polygon type
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.Holes">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.IsEmpty">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.IsRectangle">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.IsSimple">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.Length">
            <summary>
            Returns the perimeter of this <c>Polygon</c>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.NumHoles">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.NumPoints">
            <summary>
            For polygons, this returns the complete number of points, including all the points
            from the outer ring as well as from the interior holes.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Polygon.Shell">
            <summary>
            This returns a full ILinearRing geometry
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.PolygonException">
            <summary>
            PolygonException
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.PolygonException.#ctor(System.String)">
            <summary>
            Creates a new instance of PolygonException
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.PrecisionModel">
            <summary>
            Specifies the precision model of the <c>Coordinate</c>s in a <c>Geometry</c>.
            In other words, specifies the grid of allowable
            points for all <c>Geometry</c>s.
            The <c>makePrecise</c> method allows rounding a coordinate to
            a "precise" value; that is, one whose
            precision is known exactly.
            Coordinates are assumed to be precise in geometries.
            That is, the coordinates are assumed to be rounded to the
            precision model given for the point.
            NTS input routines automatically round coordinates to the precision model
            before creating Geometries.
            All internal operations
            assume that coordinates are rounded to the precision model.
            Constructive methods (such as bool operations) always round computed
            coordinates to the appropriate precision model.
            Currently three types of precision model are supported:
            <para>
            Floating: represents full double precision floating point.
            This is the default precision model used in NTS
            FloatingSingle: represents single precision floating point.
            Fixed: represents a model with a fixed number of decimal places.
            </para>
            A Fixed Precision Model is specified by a scale factor.
            The scale factor specifies the grid which numbers are rounded to.
            Input coordinates are mapped to fixed coordinates according to the following
            equations:
             jtsPt.x = round((inputPt.x * scale ) / scale
             jtsPt.y = round((inputPt.y * scale ) / scale
            Coordinates are represented internally as double-precision values.
            Since .NET uses the IEEE-394 floating point standard, this
            provides 53 bits of precision. (Thus the maximum precisely representable
            integer is 9, 007, 199, 254, 740, 992).
            NTS methods currently do not handle inputs with different precision models.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.PrecisionModel.MAXIMUM_PRECISE_VALUE">
            <summary>
            The maximum precise value representable in a double. Since IEE754
            double-precision numbers allow 53 bits of mantissa, the value is equal to
            2^53 - 1.  This provides <i>almost</i> 16 decimal digits of precision.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.PrecisionModel._modelType">
            <summary>
            The type of PrecisionModel this represents.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.PrecisionModel._scale">
            <summary>
            The scale factor which determines the number of decimal places in fixed precision.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.#ctor">
            <summary>
            Creates a <c>PrecisionModel</c> with a default precision
            of Floating.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.#ctor(DotSpatial.Topology.PrecisionModelType)">
            <summary>
            Creates a <c>PrecisionModel</c> that specifies
            an explicit precision model type.
            If the model type is Fixed the scale factor will default to 1.
            </summary>
            <param name="modelType">
            The type of the precision model.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.#ctor(System.Double)">
            <summary>
            Creates a <c>PrecisionModel</c> that specifies Fixed precision.
            Fixed-precision coordinates are represented as precise internal coordinates,
            which are rounded to the grid defined by the scale factor.
            </summary>
            <param name="scale">
            Amount by which to multiply a coordinate after subtracting
            the offset, to obtain a precise coordinate.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.#ctor(DotSpatial.Topology.PrecisionModel)">
            <summary>
            Copy constructor to create a new <c>PrecisionModel</c>
            from an existing one.
            </summary>
            <param name="pm"></param>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.CompareTo(System.Object)">
            <summary>
            Compares this <c>PrecisionModel</c> object with the specified object for order.
            A PrecisionModel is greater than another if it provides greater precision.
            The comparison is based on the value returned by the
            {getMaximumSignificantDigits) method.
            This comparison is not strictly accurate when comparing floating precision models
            to fixed models; however, it is correct when both models are either floating or fixed.
            </summary>
            <param name="o">
            The <c>PrecisionModel</c> with which this <c>PrecisionModel</c>
            is being compared.
            </param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>PrecisionModel</c>
            is less than, equal to, or greater than the specified <c>PrecisionModel</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.GetHashCode">
            <summary>
            Return HashCode.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.GetPrecisionModelType">
            <summary>
            Gets the type of this PrecisionModel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.ToInternal(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Sets <c>internal</c> to the precise representation of <c>external</c>.
            </summary>
            <param name="cexternal">The original coordinate.</param>
            <param name="cinternal">
            The coordinate whose values will be changed to the
            precise representation of <c>external</c>.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.ToInternal(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns the precise representation of <c>external</c>.
            </summary>
            <param name="cexternal">The original coordinate.</param>
            <returns>
            The coordinate whose values will be changed to the precise
            representation of <c>external</c>
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.ToExternal(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns the external representation of <c>internal</c>.
            </summary>
            <param name="cinternal">The original coordinate.</param>
            <returns>
            The coordinate whose values will be changed to the
            external representation of <c>internal</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.ToExternal(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Sets <c>external</c> to the external representation of <c>internal</c>.
            </summary>
            <param name="cinternal">The original coordinate.</param>
            <param name="cexternal">
            The coordinate whose values will be changed to the
            external representation of <c>internal</c>.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.MakePrecise(System.Double)">
            <summary>
            Rounds a numeric value to the PrecisionModel grid.
            Symmetric Arithmetic Rounding is used, to provide
            uniform rounding behaviour no matter where the number is
            on the number line.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.MakePrecise(DotSpatial.Topology.Coordinate)">
            <summary>
            Rounds a Coordinate to the PrecisionModel grid.
            </summary>
            <param name="coord"></param>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.Equals(System.Object)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.op_Equality(DotSpatial.Topology.PrecisionModel,DotSpatial.Topology.PrecisionModel)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.PrecisionModel.op_Inequality(DotSpatial.Topology.PrecisionModel,DotSpatial.Topology.PrecisionModel)">
             <summary>
            
             </summary>
             <param name="obj1"></param>
             <param name="obj2"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.PrecisionModel.IsFloating">
            <summary>
            Tests whether the precision model supports floating point.
            </summary>
            <returns><c>true</c> if the precision model supports floating point.</returns>
        </member>
        <member name="P:DotSpatial.Topology.PrecisionModel.MaximumSignificantDigits">
            <summary>
            Returns the maximum number of significant digits provided by this
            precision model.
            Intended for use by routines which need to print out precise values.
            </summary>
            <returns>
            The maximum number of decimal places provided by this precision model.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.PrecisionModel.Scale">
            <summary>
            Returns the multiplying factor used to obtain a precise coordinate.
            This method is private because PrecisionModel is intended to
            be an immutable (value) type.
            </summary>
            <returns>
            the amount by which to multiply a coordinate after subtracting
            the offset.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.PrecisionModel.OffsetX">
            <summary>
            Returns the x-offset used to obtain a precise coordinate.
            </summary>
            <returns>
            The amount by which to subtract the x-coordinate before
            multiplying by the scale.
            </returns>
        </member>
        <member name="P:DotSpatial.Topology.PrecisionModel.OffsetY">
            <summary>
            Returns the y-offset used to obtain a precise coordinate.
            </summary>
            <returns>
            The amount by which to subtract the y-coordinate before
            multiplying by the scale
            </returns>
        </member>
        <member name="T:DotSpatial.Topology.SizeD">
            <summary>
            SizeD is just like a Size class except that it has double valued measures,
            and expresses sizes in three dimensions.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.SizeD.#ctor">
            <summary>
            Creates a new instance of SizeD
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.SizeD.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new SizeD structure.
            </summary>
            <param name="xSize">X or longitude size</param>
            <param name="ySize">Y or latitude size</param>
            <param name="zSize">Z or altitude size</param>
        </member>
        <member name="P:DotSpatial.Topology.SizeD.XSize">
            <summary>
            Gets or sets the size in the x direction or longitude
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.SizeD.YSize">
            <summary>
            Gets or sets the size in the y direction or latitude
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.SizeD.ZSize">
            <summary>
            Gets or sets the size in the z direction or altitude
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.TopologyException">
            <summary>
            Indicates an invalid or inconsistent topological situation encountered during processing
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.TopologyException.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="msg"></param>
        </member>
        <member name="M:DotSpatial.Topology.TopologyException.#ctor(System.String,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="msg"></param>
             <param name="pt"></param>
        </member>
        <member name="M:DotSpatial.Topology.TopologyException.MsgWithCoord(System.String,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="msg"></param>
             <param name="pt"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.TopologyException.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Triangle">
            <summary>
            Represents a planar triangle, and provides methods for calculating various
            properties of triangles.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Triangle.#ctor(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
             <param name="p2"></param>
        </member>
        <member name="P:DotSpatial.Topology.Triangle.P2">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Triangle.P1">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Triangle.P0">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Triangle.InCentre">
            <summary>
            The inCentre of a triangle is the point which is equidistant
            from the sides of the triangle.  This is also the point at which the bisectors
            of the angles meet.
            </summary>
            <returns>
            The point which is the InCentre of the triangle.
            </returns>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.GeometryTransformer">
            <summary>
            A framework for processes which transform an input <c>Geometry</c> into
            an output <c>Geometry</c>, possibly changing its structure and type(s).
            This class is a framework for implementing subclasses
            which perform transformations on
            various different Geometry subclasses.
            It provides an easy way of applying specific transformations
            to given point types, while allowing unhandled types to be simply copied.
            Also, the framework handles ensuring that if subcomponents change type
            the parent geometries types change appropriately to maintain valid structure.
            Subclasses will override whichever <c>TransformX</c> methods
            they need to to handle particular Geometry types.
            A typically usage would be a transformation that may transform Polygons into
            Polygons, LineStrings
            or Points.  This class would likely need to override the TransformMultiPolygon
            method to ensure that if input Polygons change type the result is a GeometryCollection,
            not a MultiPolygon.
            The default behaviour of this class is to simply recursively transform
            each Geometry component into an identical object by copying.
            Notice that all <c>TransformX</c> methods may return <c>null</c>,
            to avoid creating empty point objects. This will be handled correctly
            by the transformer.
            The Transform method itself will always
            return a point object.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.GeometryTransformer.PRUNE_EMPTY_GEOMETRY">
            <summary>
            <c>true</c> if empty geometries should not be included in the result.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.GeometryTransformer.PRESERVE_TYPE">
            <summary>
            <c>true</c> if the type of the input should be preserved.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.GeometryTransformer._factory">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryTransformer.Transform(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="anInputGeom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryTransformer.CreateCoordinateSequence(DotSpatial.Topology.Coordinate[])">
            <summary>
            Convenience method which provides standard way of
            creating a <c>CoordinateSequence</c>.
            </summary>
            <param name="coords">The coordinate array to copy.</param>
            <returns>A coordinate sequence for the array.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryTransformer.Copy(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Convenience method which provides statndard way of copying {CoordinateSequence}s
            </summary>
            <param name="seq">The sequence to copy.</param>
            <returns>A deep copy of the sequence.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryTransformer.TransformCoordinates(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="coords"></param>
             <param name="parent"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryTransformer.TransformPoint(DotSpatial.Topology.IPoint)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryTransformer.TransformMultiPoint(DotSpatial.Topology.IMultiPoint)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryTransformer.TransformLinearRing(DotSpatial.Topology.ILinearRing)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryTransformer.TransformLineString(DotSpatial.Topology.ILineString)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryTransformer.TransformMultiLineString(DotSpatial.Topology.IMultiLineString)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryTransformer.TransformPolygon(DotSpatial.Topology.IPolygon,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <param name="parent"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryTransformer.TransformMultiPolygon(DotSpatial.Topology.IMultiPolygon)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.GeometryTransformer.TransformGeometryCollection(DotSpatial.Topology.IGeometryCollection,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <param name="parent"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Utilities.GeometryTransformer.InputGeometry">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.LinearComponentExtracter">
            <summary>
            Extracts all the 1-dimensional (<c>LineString</c>) components from a <c>Geometry</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.LinearComponentExtracter.#ctor(System.Collections.IList)">
            <summary>
            Constructs a LineExtracterFilter with a list in which to store LineStrings found.
            </summary>
            <param name="lines"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.LinearComponentExtracter.Filter(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.LinearComponentExtracter.GetLines(DotSpatial.Topology.IGeometry)">
            <summary>
            Extracts the linear components from a single point.
            If more than one point is to be processed, it is more
            efficient to create a single <c>LineExtracterFilter</c> instance
            and pass it to multiple geometries.
            </summary>
            <param name="geom">The point from which to extract linear components.</param>
            <returns>The list of linear components.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.PointExtracter">
            <summary>
            Extracts all the 0-dimensional (<c>Point</c>) components from a <c>Geometry</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.PointExtracter.#ctor(System.Collections.IList)">
            <summary>
            Constructs a PointExtracterFilter with a list in which to store Points found.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.PointExtracter.Filter(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.PointExtracter.GetPoints(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns the Point components from a single point.
            If more than one point is to be processed, it is more
            efficient to create a single <c>PointExtracterFilter</c> instance
            and pass it to multiple geometries.
            </summary>
            <param name="geom"></param>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.PolygonExtracter">
            <summary>
            Extracts all the 2-dimensional (<c>Polygon</c>) components from a <c>Geometry</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.PolygonExtracter.#ctor(System.Collections.IList)">
            <summary>
            Constructs a PolygonExtracterFilter with a list in which to store Polygons found.
            </summary>
            <param name="comps"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.PolygonExtracter.Filter(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.PolygonExtracter.GetPolygons(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns the Polygon components from a single point.
            If more than one point is to be processed, it is more
            efficient to create a single <c>PolygonExtracterFilter</c> instance
            and pass it to multiple geometries.
            </summary>
            <param name="geom"></param>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.ShortCircuitedGeometryVisitor">
            <summary>
            A visitor to Geometry elements which can
            be short-circuited by a given condition.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.ShortCircuitedGeometryVisitor.ApplyTo(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.ShortCircuitedGeometryVisitor.Visit(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="element"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.ShortCircuitedGeometryVisitor.IsDone">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.UnsupportedGeometryException">
            <summary>
            Unsupported geometry Exception
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.UnsupportedGeometryException.#ctor">
            <summary>
            Creates a new instance of the unsupported geometry exception
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Vector">
            <summary>
            Contains a magnitude and direction
            Supports more fundamental calculations than LineSegment, rather than topological functions
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Vector.#ctor">
            <summary>
            Creates a new empty vector
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Vector.#ctor(DotSpatial.Topology.Coordinate)">
            <summary>
            Creates a new instance of a vector where the X, Y and Z terms are the same as the
            specified coordinate.
            </summary>
            <param name="coord">The ICoordinate to use</param>
        </member>
        <member name="M:DotSpatial.Topology.Vector.#ctor(DotSpatial.Topology.ICoordinate)">
            <summary>
            Creates a new vector from the Point, assuming the tail of the vector is the origin
            </summary>
            <param name="inPoint">The Point to create a vector from</param>
        </member>
        <member name="M:DotSpatial.Topology.Vector.#ctor(DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Creates a new vector from a line segment, assuming that the direction is from the start point to the end point
            </summary>
            <param name="inLineSegment">A Topology.LineSegment object to turn into a vector</param>
        </member>
        <member name="M:DotSpatial.Topology.Vector.#ctor(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Creates a vector that points from the start coordinate to the end coordinate and
            uses the distance between the two coordinates to form its length.
            </summary>
            <param name="startCoord">The start coordinate</param>
            <param name="endCoord">The end coordinate for the vector</param>
        </member>
        <member name="M:DotSpatial.Topology.Vector.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a mathematical vector from X1, Y1 to X2, Y2
            </summary>
            <param name="x1">Double, The X coordinate of the start point for the vector</param>
            <param name="y1">Double, The Y coordinate of the start point for the vector </param>
            <param name="z1">Double, the Z coordinate of the start point for the vector</param>
            <param name="x2">Double, The X coordinate of the end point for the vector</param>
            <param name="y2">Double, The Y coordinate of the end point for the vector</param>
            <param name="z2">Double, the Z coordinate of the end point for the vector</param>
        </member>
        <member name="M:DotSpatial.Topology.Vector.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates a mathemtacal vector from the origin to the x, y, z coordinates
            </summary>
            <param name="x">Double, the X coordinate from the origin</param>
            <param name="y">Double, the Y coordinate from the origin</param>
            <param name="z">Double, the Z coordinate from the origin</param>
        </member>
        <member name="M:DotSpatial.Topology.Vector.#ctor(System.Double,DotSpatial.Topology.Angle,DotSpatial.Topology.Angle)">
            <summary>
            Creates a mathematical vector from the origin with the new magnitude and directions specified
            </summary>
            <param name="newMagnitude">Double, the length of the vector</param>
            <param name="theta">The angle in the x-y plane</param>
            <param name="phi">The angle in the z direction</param>
        </member>
        <member name="M:DotSpatial.Topology.Vector.#ctor(System.Double,DotSpatial.Topology.Angle)">
            <summary>
            Creates a mathematical vector in the X-Y plane with angle Theta
            </summary>
            <param name="newMagnitude">Double, The magnitude of the vector</param>
            <param name="theta">Angle, The direction measured counterclockwise from Positive X Axis </param>
        </member>
        <member name="M:DotSpatial.Topology.Vector.#ctor(DotSpatial.Topology.Vector)">
            <summary>
            Creates a new vector from a vector that can be longer or shorter than 3 ordinates.
            If an X, Y or Z value is not specified, it will become 0.  Values greater than
            the Z ordinate are lost.
            </summary>
            <param name="vect"></param>
        </member>
        <member name="M:DotSpatial.Topology.Vector.#ctor(DotSpatial.Topology.IMatrixD)">
            <summary>
            Creates a new vector based on the first three values on the first row of the
            matrix.  This is useful for working with the result of a transformation matrix.
            </summary>
            <param name="mat">An IMatrixD that should represent the vector</param>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Add(DotSpatial.Topology.Vector)">
            <summary>
            Adds each of the elements of V to the elements of this vector
            </summary>
            <param name="v">Vector, the vector to add to this vector</param>
            <returns>A vector result from the addition</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Norm2">
            <summary>
            Returns the square of the distance of the vector without taking the square root
            This is the same as doting the vector with itself
            </summary>
            <returns>Double, the square of the distance between the vectors</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.RotateX(System.Double)">
            <summary>
            Rotates the vector about the X axis as though the tail of the vector were at the origin
            </summary>
            <param name="degrees">The angle in degrees to rotate counter-clockwise when looking at the origin from the positive axis.</param>
            <returns>A new Vector that has been rotated</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.RotateY(System.Double)">
            <summary>
            Rotates the vector about the Y axis as though the tail of the vector were at the origin
            </summary>
            <param name="degrees">The angle in degrees to rotate counter-clockwise when looking at the origin from the positive axis.</param>
            <returns>A new Vector that has been rotated</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.RotateZ(System.Double)">
            <summary>
            Rotates the vector about the Z axis as though the tail of the vector were at the origin
            </summary>
            <param name="degrees">The angle in degrees to rotate counter-clockwise when looking at the origin from the positive axis.</param>
            <returns>A new Vector that has been rotated</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.ToPoint">
            <summary>
            Assuming the vector starts at the origin of 0, 0, 0, this function returns
            a Point representing the tip of the vector.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Vector.ToLineSegment">
            <summary>
            Returns a new segment from this vector, where the StartPoint is 0, 0, 0
            and the End Point is the tip of this vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.ToCoordinate">
            <summary>
            Returns an ICoordinate from this vector, where the X, Y and Z value match the values in this vector
            </summary>
            <returns>an ICoordinate, where the X, Y and Z value match the values in this vector</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.TransformCoordinate(DotSpatial.Topology.IMatrix4)">
            <summary>
            Transforms a point that has 3 dimensions by multiplying it by the
            specified 3 x 3 matrix in the upper left, but treats the
            bottom row as supplying the translation coordinates.
            </summary>
            <param name="transformMatrix"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.ToMatrix">
            <summary>
            Rotations and transformations work by applying matrix mathematics,
            so this creates a 1 x 4 version of this vector.  The 4th value
            is always 1, and allows for the translation terms to work.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Subtract(DotSpatial.Topology.Vector)">
            <summary>
            Subtracts each element of V from each element of this vector
            </summary>
            <param name="v">Vector, the vector to subtract from this vector</param>
            <returns>A vector result from the subtraction</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Normalize">
            <summary>
            Normalizes the vector.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Cross(DotSpatial.Topology.Vector)">
            <summary>
            Returns the cross product of this vector with the specified vector V
            </summary>
            <param name="v">The vector to perform a cross product against</param>
            <returns>A vector result from the inner product</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Dot(DotSpatial.Topology.Vector)">
            <summary>
            Returns the dot product of this vector with V2
            </summary>
            <param name="v">The vector to perform an inner product against</param>
            <returns>A Double result from the inner product</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Intersects(DotSpatial.Topology.Vector)">
            <summary>
            Compares the values of each element, and if all the elements are equal, returns true.
            </summary>
            <param name="v">The vector to compare against this vector.</param>
            <returns>Boolean, true if all the elements have the same value.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Equals(DotSpatial.Topology.Vector)">
            <summary>
            Override  for definition of equality for vectors
            </summary>
            <param name="v">A vector to compare with</param>
            <returns>true if the X, Y, and Z coordinates are all equal</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Equals(System.Object)">
            <summary>
            Checks first to make sure that both objects are vectors.  If they are,
            then it checks to determine whether or not the X, Y and Z values are equal.
            </summary>
            <param name="vect">The object to test against</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.GetHashCode">
            <summary>
            Returns the hash code.. or something
            </summary>
            <returns>A hash code I guess</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Multiply(System.Double)">
            <summary>
            Returns the scalar product of this vector against a scalar
            </summary>
            <param name="scalar">Double, a value to multiply against all the members of this vector</param>
            <returns>A vector multiplied by the scalar</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Add(DotSpatial.Topology.Vector,DotSpatial.Topology.Vector)">
            <summary>
            Adds the vectors U and V using vector addition, which adds the corresponding components
            </summary>
            <param name="u">One vector to be added</param>
            <param name="v">A second vector to be added</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.CrossProduct(DotSpatial.Topology.Vector,DotSpatial.Topology.Vector)">
            <summary>
            Returns the Cross Product of two vectors U and V
            </summary>
            <param name="u">Vector, the first input vector</param>
            <param name="v">Vector, the second input vector</param>
            <returns>A Vector containing the cross product of U and V</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Divide(DotSpatial.Topology.Vector,System.Double)">
            <summary>
            Multiplies each component of vector U by the Scalar value
            </summary>
            <param name="u">A vector representing the vector to be multiplied</param>
            <param name="scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A Vector representing the vector product of vector U and the Scalar</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.DotProduct(DotSpatial.Topology.Vector,DotSpatial.Topology.Vector)">
            <summary>
            Returns the Inner Product also known as the dot product of two vectors, U and V
            </summary>
            <param name="u">The input vector</param>
            <param name="v">The vector to take the inner product against U</param>
            <returns>a Double containing the dot product of U and V</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Norm2(DotSpatial.Topology.Vector)">
            <summary>
            Non-static version of taking the square distance for a vector
            </summary>
            <param name="u">The vector to find the square of the distance of</param>
            <returns>Double, the square of the distance</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Multiply(DotSpatial.Topology.Vector,System.Double)">
            <summary>
            Multiplies each component of vector U by the Scalar value
            </summary>
            <param name="u">A vector representing the vector to be multiplied</param>
            <param name="scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A Vector representing the vector product of vector U and the Scalar</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.Subtract(DotSpatial.Topology.Vector,DotSpatial.Topology.Vector)">
            <summary>
            Subtracts Vector V from Vector U
            </summary>
            <param name="u">A Vector to subtract from</param>
            <param name="v">A Vector to subtract</param>
            <returns>The Vector difference U - V</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.op_Addition(DotSpatial.Topology.Vector,DotSpatial.Topology.Vector)">
            <summary>
            Adds the vectors U and V using vector addition, which adds the corresponding components
            </summary>
            <param name="u">One vector to be added</param>
            <param name="v">A second vector to be added</param>
            <returns>The sum of the vectors</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.op_Equality(DotSpatial.Topology.Vector,DotSpatial.Topology.Vector)">
            <summary>
            Tests equality of the X, Y, and Z members.
            </summary>
            <param name="u">The left hand side vector to test for equality.</param>
            <param name="v">The right hand side vector to test for equality.</param>
            <returns>Returns true if X, Y and Z are equal.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.op_Inequality(DotSpatial.Topology.Vector,DotSpatial.Topology.Vector)">
            <summary>
            Tests inequality of the X, Y and Z members.
            </summary>
            <param name="u">The left hand side vector to test inequality for.</param>
            <param name="v">The right hand side vector to test inequality for</param>
            <returns>Returns true if X, Y and Z are equal</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.op_ExclusiveOr(DotSpatial.Topology.Vector,DotSpatial.Topology.Vector)">
            <summary>
            Returns the Cross Product of two vectors U and V
            </summary>
            <param name="u">Vector, the first input vector</param>
            <param name="v">Vector, the second input vector</param>
            <returns>A Vector containing the cross product of U and V</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.op_Multiply(DotSpatial.Topology.Vector,DotSpatial.Topology.Vector)">
            <summary>
            Returns the Inner Product also known as the dot product of two vectors, U and V
            </summary>
            <param name="u">The input vector</param>
            <param name="v">The vector to take the inner product against U</param>
            <returns>a Double containing the dot product of U and V</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.op_Multiply(System.Double,DotSpatial.Topology.Vector)">
            <summary>
            Multiplies the vectors U and V using vector multiplication,
            which adds the corresponding components
            </summary>
            <param name="scalar">A scalar to multpy to the vector</param>
            <param name="v">A vector to be multiplied</param>
            <returns>The scalar product for the vectors</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.op_Multiply(DotSpatial.Topology.Vector,System.Double)">
            <summary>
            Multiplies each component of vector U by the Scalar value
            </summary>
            <param name="u">A vector representing the vector to be multiplied</param>
            <param name="scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A Vector representing the vector product of vector U and the Scalar</returns>
        </member>
        <member name="M:DotSpatial.Topology.Vector.op_Subtraction(DotSpatial.Topology.Vector,DotSpatial.Topology.Vector)">
            <summary>
            Subtracts Vector V from Vector U
            </summary>
            <param name="u">A Vector to subtract from</param>
            <param name="v">A Vector to subtract</param>
            <returns>The Vector difference U - V</returns>
        </member>
        <member name="P:DotSpatial.Topology.Vector.Length">
            <summary>
            The Euclidean distance from the origin to the tip of the 3 dimensional vector
            Setting the magntiude won't change the direction.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Vector.Length2D">
            <summary>
            Returns the magnitude of the projection of the vector onto the base.X-Y plane
            Setting this magnitude will not affect Z, which should be adjusted separately
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Vector.Phi">
            <summary>
            Obtains the angle above the X-Y plane.  Positive towards positive Z.
            Values are in radians from -Pi/2 to Pi/2
            Setting this value when no magnitude exists results in a unit vector with angle phi in the X direction.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Vector.Theta">
            <summary>
            Represents the angle in the X-Y plane.  0 along the positive X axis, and increasing counterclockwise
            Values are in Radians.  Setting this value when no X-Y magnitude exists results in a unit vector
            between X and Y, but does not affect Z, so you may have something other than a unit vector in 3-D.
            Set theta before phi in order to obtain a unit vector in 3-D space.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.WkbGeometryType">
            <summary>
            WkbGeometryTypes
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.WkbGeometryType.Point">
            <summary>
            Point.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.WkbGeometryType.LineString">
            <summary>
            LineString.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.WkbGeometryType.Polygon">
            <summary>
            Polygon.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.WkbGeometryType.MultiPoint">
            <summary>
            MultiPoint.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.WkbGeometryType.MultiLineString">
            <summary>
            MultiLineString.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.WkbGeometryType.MultiPolygon">
            <summary>
            MultiPolygon.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.WkbGeometryType.GeometryCollection">
            <summary>
            GeometryCollection.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.WkbWriter">
            <summary>
            Writes a Well-Known Binary byte data representation of a <c>Geometry</c>.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Utilities.WkbWriter.INIT_COUNT">
            <summary>
            Standard byte size for each complex point.
            Each complex point (LineString, Polygon, ...) contains:
                1 byte for ByteOrder and
                4 bytes for WKBType.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.#ctor">
            <summary>
            Initializes writer with LittleIndian byte order.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.#ctor(DotSpatial.Topology.Utilities.ByteOrder)">
            <summary>
            Initializes writer with the specified byte order.
            </summary>
            <param name="encodingType">Encoding type</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.Write(DotSpatial.Topology.IGeometry)">
            <summary>
            Writes a WKB representation of a given point.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.Write(DotSpatial.Topology.IGeometry,System.IO.Stream)">
            <summary>
            Writes a WKB representation of a given point.
            </summary>
            <param name="geometry"></param>
            <param name="stream"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.Write(DotSpatial.Topology.IGeometry,System.IO.BinaryWriter)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.WriteByteOrder(System.IO.BinaryWriter)">
            <summary>
            Writes LittleIndian ByteOrder.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.Write(DotSpatial.Topology.IPoint,System.IO.BinaryWriter)">
             <summary>
            
             </summary>
             <param name="point"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.Write(DotSpatial.Topology.ILineString,System.IO.BinaryWriter)">
             <summary>
            
             </summary>
             <param name="lineString"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.Write(DotSpatial.Topology.IPolygon,System.IO.BinaryWriter)">
             <summary>
            
             </summary>
             <param name="polygon"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.Write(DotSpatial.Topology.IMultiPoint,System.IO.BinaryWriter)">
             <summary>
            
             </summary>
             <param name="multiPoint"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.Write(DotSpatial.Topology.IMultiLineString,System.IO.BinaryWriter)">
             <summary>
            
             </summary>
             <param name="multiLineString"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.Write(DotSpatial.Topology.IMultiPolygon,System.IO.BinaryWriter)">
             <summary>
            
             </summary>
             <param name="multiPolygon"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.Write(DotSpatial.Topology.IGeometryCollection,System.IO.BinaryWriter)">
             <summary>
            
             </summary>
             <param name="geomCollection"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.Write(DotSpatial.Topology.Coordinate,System.IO.BinaryWriter)">
             <summary>
            
             </summary>
             <param name="coordinate"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.Write(DotSpatial.Topology.ILinearRing,System.IO.BinaryWriter)">
             <summary>
            
             </summary>
             <param name="ring"></param>
             <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.GetBytes(DotSpatial.Topology.IGeometry)">
            <summary>
            Sets corrent length for Byte Stream.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.SetByteStream(DotSpatial.Topology.IGeometry)">
            <summary>
            Sets corrent length for Byte Stream.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.SetByteStream(DotSpatial.Topology.IGeometryCollection)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.SetByteStream(DotSpatial.Topology.IMultiPolygon)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.SetByteStream(DotSpatial.Topology.IMultiLineString)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.SetByteStream(DotSpatial.Topology.IMultiPoint)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.SetByteStream(DotSpatial.Topology.IPolygon)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.SetByteStream(DotSpatial.Topology.ILineString)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WkbWriter.SetByteStream(DotSpatial.Topology.IPoint)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.WktWriter">
            <summary>
            Outputs the textual representation of a Geometry.
            The WktWriter outputs coordinates rounded to the precision
            model. No more than the maximum number of necessary decimal places will be
            output.
            The Well-known Text format is defined in the OpenGIS Simple Features  Specification
            (http://www.opengis.org/techno/specs.htm) for SQL.
            A non-standard "LINEARRING" tag is used for LinearRings. The WKT spec does
            not define a special tag for LinearRings. The standard tag to use is
            "LINESTRING".
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.ToPoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Generates the WKT for a <c>Point</c>.
            </summary>
            <param name="p0">The point coordinate.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.ToLineString(DotSpatial.Topology.ICoordinateSequence)">
            <summary>
            Generates the WKT for a N-point <c>LineString</c>.
            </summary>
            <param name="seq">The sequence to output.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.ToLineString(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Generates the WKT for a 2-point <c>LineString</c>.
            </summary>
            <param name="p0">The first coordinate.</param>
            <param name="p1">The second coordinate.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.CreateFormatter(DotSpatial.Topology.PrecisionModel)">
            <summary>
            Creates the <c>NumberFormatInfo</c> used to write <c>double</c>s
            with a sufficient number of decimal places.
            </summary>
            <param name="precisionModel">
            The <c>PrecisionModel</c> used to determine
            the number of decimal places to write.
            </param>
            <returns>
            A <c>NumberFormatInfo</c> that write <c>double</c>
            s without scientific notation.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.StringOfChar(System.Char,System.Int32)">
            <summary>
            Returns a <c>String</c> of repeated characters.
            </summary>
            <param name="ch">The character to repeat.</param>
            <param name="count">The number of times to repeat the character.</param>
            <returns>A <c>string</c> of characters.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.Write(DotSpatial.Topology.Geometry)">
            <summary>
            Converts a <c>Geometry</c> to its Well-known Text representation.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process.</param>
            <returns>A Geometry Tagged Text string (see the OpenGIS Simple Features Specification).</returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.Write(DotSpatial.Topology.Geometry,System.IO.TextWriter)">
            <summary>
            Converts a <c>Geometry</c> to its Well-known Text representation.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process.</param>
            <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.WriteFormatted(DotSpatial.Topology.Geometry)">
            <summary>
            Same as <c>write</c>, but with newlines and spaces to make the
            well-known text more readable.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process</param>
            <returns>
            A "Geometry Tagged Text" string (see the OpenGIS Simple
            Features Specification), with newlines and spaces.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.WriteFormatted(DotSpatial.Topology.Geometry,System.IO.TextWriter)">
            <summary>
            Same as <c>write</c>, but with newlines and spaces to make the
            well-known text more readable.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process</param>
            <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.WriteFormatted(DotSpatial.Topology.IGeometry,System.Boolean,System.IO.TextWriter)">
            <summary>
            Converts a <c>Geometry</c> to its Well-known Text representation.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process</param>
            <param name="isFormatted"></param>
            <param name="writer"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendGeometryTaggedText(DotSpatial.Topology.IGeometry,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>Geometry</c> to &lt;Geometry Tagged Text format,
            then appends it to the writer.
            </summary>
            <param name="geometry">/he <c>Geometry</c> to process.</param>
            <param name="level"></param>
            <param name="writer">/he output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendPointTaggedText(DotSpatial.Topology.Coordinate,System.IO.TextWriter)">
            <summary>
            Converts a <c>Coordinate</c> to Point Tagged Text format,
            then appends it to the writer.
            </summary>
            <param name="coordinate">The <c>Coordinate</c> to process.</param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendLineStringTaggedText(DotSpatial.Topology.IBasicLineString,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>LineString</c> to &lt;LineString Tagged Text
            format, then appends it to the writer.
            </summary>
            <param name="lineString">The <c>LineString</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendLinearRingTaggedText(DotSpatial.Topology.ILinearRing,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>LinearRing</c> to &lt;LinearRing Tagged Text
            format, then appends it to the writer.
            </summary>
            <param name="linearRing">The <c>LinearRing</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendPolygonTaggedText(DotSpatial.Topology.IPolygon,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>Polygon</c> to Polygon Tagged Text format,
            then appends it to the writer.
            </summary>
            <param name="polygon">The <c>Polygon</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendMultiPointTaggedText(DotSpatial.Topology.IMultiPoint,System.IO.TextWriter)">
            <summary>
            Converts a <c>MultiPoint</c> to &lt;MultiPoint Tagged Text
            format, then appends it to the writer.
            </summary>
            <param name="multipoint">The <c>MultiPoint</c> to process.</param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendMultiLineStringTaggedText(DotSpatial.Topology.IMultiLineString,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>MultiLineString</c> to MultiLineString Tagged
            Text format, then appends it to the writer.
            </summary>
            <param name="multiLineString">The <c>MultiLineString</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendMultiPolygonTaggedText(DotSpatial.Topology.IMultiPolygon,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>MultiPolygon</c> to MultiPolygon Tagged Text
            format, then appends it to the writer.
            </summary>
            <param name="multiPolygon">The <c>MultiPolygon</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendGeometryCollectionTaggedText(DotSpatial.Topology.IGeometryCollection,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>GeometryCollection</c> to GeometryCollection
            Tagged Text format, then appends it to the writer.
            </summary>
            <param name="geometryCollection">The <c>GeometryCollection</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendPointText(DotSpatial.Topology.Coordinate,System.IO.TextWriter)">
            <summary>
            Converts a <c>Coordinate</c> to Point Text format, then
            appends it to the writer.
            </summary>
            <param name="coordinate">The <c>Coordinate</c> to process.</param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendCoordinate(DotSpatial.Topology.Coordinate,System.IO.TextWriter)">
            <summary>
            Converts a <c>Coordinate</c> to Point format, then appends
            it to the writer.
            </summary>
            <param name="coordinate">The <c>Coordinate</c> to process.</param>
            <param name="writer">The output writer to append to.</param>
            The <c>PrecisionModel</c> to use to convert
            from a precise coordinate to an external coordinate.
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.WriteNumber(System.Double)">
            <summary>
            Converts a <see cref="T:System.Double"/> to a <see cref="T:System.String"/>,
            not in scientific notation.
            </summary>
            <param name="d">The <see cref="T:System.Double"/> to convert.</param>
            <returns>
            The <see cref="T:System.Double"/> as a <see cref="T:System.String"/>,
            not in scientific notation.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendLineStringText(DotSpatial.Topology.IBasicLineString,System.Int32,System.Boolean,System.IO.TextWriter)">
            <summary>
            Converts a <c>LineString</c> to &lt;LineString Text format, then
            appends it to the writer.
            </summary>
            <param name="lineString">The <c>LineString</c> to process.</param>
            <param name="level"></param>
            <param name="doIndent"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendPolygonText(DotSpatial.Topology.IPolygon,System.Int32,System.Boolean,System.IO.TextWriter)">
            <summary>
            Converts a <c>Polygon</c> to Polygon Text format, then
            appends it to the writer.
            </summary>
            <param name="polygon">The <c>Polygon</c> to process.</param>
            <param name="level"></param>
            <param name="indentFirst"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendMultiPointText(DotSpatial.Topology.IGeometry,System.IO.TextWriter)">
            <summary>
            Converts a <c>MultiPoint</c> to &lt;MultiPoint Text format, then
            appends it to the writer.
            </summary>
            <param name="multiPoint">The <c>MultiPoint</c> to process.</param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendMultiLineStringText(DotSpatial.Topology.IMultiLineString,System.Int32,System.Boolean,System.IO.TextWriter)">
            <summary>
            Converts a <c>MultiLineString</c> to &lt;MultiLineString Text
            format, then appends it to the writer.
            </summary>
            <param name="multiLineString">The <c>MultiLineString</c> to process.</param>
            <param name="level"></param>
            <param name="indentFirst"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendMultiPolygonText(DotSpatial.Topology.IMultiPolygon,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>MultiPolygon</c> to &lt;MultiPolygon Text format,
            then appends it to the writer.
            </summary>
            <param name="multiPolygon">The <c>MultiPolygon</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.AppendGeometryCollectionText(DotSpatial.Topology.IGeometryCollection,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>GeometryCollection</c> to GeometryCollectionText
            format, then appends it to the writer.
            </summary>
            <param name="geometryCollection">The <c>GeometryCollection</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.WktWriter.Indent(System.Int32,System.IO.TextWriter)">
             <summary>
            
             </summary>
             <param name="level"></param>
             <param name="writer"></param>
        </member>
        <member name="T:DotSpatial.Topology.TopologyText">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.ArgumentCannotBeNegative_S">
            <summary>
              Looks up a localized string similar to The argument %S cannot be negative..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.ArgumentCouldNotBeCast_S1_S2">
            <summary>
              Looks up a localized string similar to The argument %S1 could not be successfully cast into %S2..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.ArgumentOutOfRangeException_S">
            <summary>
              Looks up a localized string similar to The argument %S was outside the range of accepted values..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.ClassNotSupportedException_S">
            <summary>
              Looks up a localized string similar to The class %S is not supported..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.CoordinateMismatchException">
            <summary>
              Looks up a localized string similar to The number of ordinates did not match between the dimensions, so the hyperdistance cannot be accurately calculated..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.DuplicateEdgeException">
            <summary>
              Looks up a localized string similar to The same directed edge appeared more than once..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.GeometryCollectionNotSupportedException">
            <summary>
              Looks up a localized string similar to Geometry collections are not supported for this method..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.InsufficientDimensions">
            <summary>
              Looks up a localized string similar to The number of dimensions in at least one argument is insufficient for this calculation..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.InsufficientDimensions_S">
            <summary>
              Looks up a localized string similar to The number of dimensions in %S is insufficient for this calculation..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.InvalidOctantException_S">
            <summary>
              Looks up a localized string similar to An invalid octant was specified: %S.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.KeyDuplicateException">
            <summary>
              Looks up a localized string similar to The specified key already exists in the tree..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.KeyMissingException">
            <summary>
              Looks up a localized string similar to The specified key could not be found in the tree..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.KeySizeException">
            <summary>
              Looks up a localized string similar to The size of the key did not match the size of the tree..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.NullEdgeException">
            <summary>
              Looks up a localized string similar to Found null Directed Edge in ring.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.PolygonException_HoleElementNull">
            <summary>
              Looks up a localized string similar to Holes must not contain null elements.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.PolygonException_ShellEmptyButHolesNot">
            <summary>
              Looks up a localized string similar to Shell is empty but holes are not.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.ReadOnlyException">
            <summary>
              Looks up a localized string similar to The ICollection is read-only..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.ShellHoleIdentityException">
            <summary>
              Looks up a localized string similar to Points in shell and hole appear to be equal.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.ShouldNeverReachHereException">
            <summary>
              Looks up a localized string similar to The code execution should never have reached this location..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.SideLocationConflict">
            <summary>
              Looks up a localized string similar to Side location conflict at.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.SingleNullSide">
            <summary>
              Looks up a localized string similar to Found single null side at.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.TopologyException_Depth">
            <summary>
              Looks up a localized string similar to Assigned depths do not match.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.TwoHorizontalEdgesException">
            <summary>
              Looks up a localized string similar to Found two horizontal edges incident on node..
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.TopologyText.UnsupportedGeometryException">
            <summary>
              Looks up a localized string similar to Unsupported Geometry classes should be caught in the GeometryEditorOperation..
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.CentroidArea">
            <summary>
            Computes the centroid of an area point.
            Algorithm:
            Based on the usual algorithm for calculating
            the centroid as a weighted sum of the centroids
            of a decomposition of the area into (possibly overlapping) triangles.
            The algorithm has been extended to handle holes and multi-polygons.
            See <see href="http://www.faqs.org/faqs/graphics/algorithms-faq"/>
            for further details of the basic approach.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CentroidArea.Add(DotSpatial.Topology.IGeometry)">
            <summary>
            Adds the area defined by a Geometry to the centroid total.
            If the point has no area it does not contribute to the centroid.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CentroidArea.Add(DotSpatial.Topology.Coordinate[])">
            <summary>
            Adds the area defined by an array of
            coordinates.  The array must be a ring;
            i.e. end with the same coordinate as it starts with.
            </summary>
            <param name="ring">An array of Coordinates.</param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CentroidArea.Add(DotSpatial.Topology.IPolygon)">
             <summary>
            
             </summary>
             <param name="poly"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CentroidArea.AddShell(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="pts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CentroidArea.AddHole(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="pts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CentroidArea.AddTriangle(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,System.Boolean)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
             <param name="p2"></param>
             <param name="isPositiveArea"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CentroidArea.Centroid3(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate@)">
            <summary>
            Returns three times the centroid of the triangle p1-p2-p3.
            The factor of 3 is
            left in to permit division to be avoided until later.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CentroidArea.Area2(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Returns twice the signed area of the triangle p1-p2-p3,
            positive if a, b, c are oriented Ccw, and negative if cw.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.CentroidArea.Centroid">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.CentroidArea.BasePoint">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.CentroidLine">
            <summary>
            Computes the centroid of a linear point.
            Algorithm:
            Compute the average of the midpoints
            of all line segments weighted by the segment length.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CentroidLine.Add(DotSpatial.Topology.IGeometry)">
            <summary>
            Adds the linestring(s) defined by a Geometry to the centroid total.
            If the point is not linear it does not contribute to the centroid.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CentroidLine.Add(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Adds the length defined by an array of coordinates.
            </summary>
            <param name="pts">An array of <c>Coordinates</c>.</param>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.CentroidLine.Centroid">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.CentroidPoint">
            <summary>
            Computes the centroid of a point point.
            Algorithm:
            Compute the average of all points.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CentroidPoint.Add(DotSpatial.Topology.IGeometry)">
            <summary>
            Adds the point(s) defined by a Geometry to the centroid total.
            If the point is not of dimension 0 it does not contribute to the centroid.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CentroidPoint.Add(DotSpatial.Topology.Coordinate)">
            <summary>
            Adds the length defined by a coordinate.
            </summary>
            <param name="pt">A coordinate.</param>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.CentroidPoint.Centroid">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.CgAlgorithms">
            <summary>
            Specifies and implements various fundamental Computational Geometric algorithms.
            The algorithms supplied in this class are robust for double-precision floating point.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Algorithm.CgAlgorithms.CLOCKWISE">
            <summary>
            A value that indicates an orientation of clockwise, or a right turn.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Algorithm.CgAlgorithms.RIGHT">
            <summary>
            A value that indicates an orientation of clockwise, or a right turn.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Algorithm.CgAlgorithms.COUNTER_CLOCKWISE">
            <summary>
            A value that indicates an orientation of counterclockwise, or a left turn.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Algorithm.CgAlgorithms.LEFT">
            <summary>
            A value that indicates an orientation of counterclockwise, or a left turn.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Algorithm.CgAlgorithms.COLLINEAR">
            <summary>
            A value that indicates an orientation of collinear, or no turn (straight).
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Algorithm.CgAlgorithms.STRAIGHT">
            <summary>
            A value that indicates an orientation of collinear, or no turn (straight).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CgAlgorithms.OrientationIndex(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Returns the index of the direction of the point <c>q</c>
            relative to a vector specified by <c>p1-p2</c>.
            </summary>
            <param name="p1">The origin point of the vector.</param>
            <param name="p2">The final point of the vector.</param>
            <param name="q">The point to compute the direction to.</param>
            <returns>
            1 if q is counter-clockwise (left) from p1-p2,
            -1 if q is clockwise (right) from p1-p2,
            0 if q is collinear with p1-p2.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CgAlgorithms.IsPointInRing(DotSpatial.Topology.Coordinate,System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Test whether a point lies inside a ring.
            The ring may be oriented in either direction.
            If the point lies on the ring boundary the result of this method is unspecified.
            This algorithm does not attempt to first check the point against the envelope
            of the ring.
            </summary>
            <param name="p">Point to check for ring inclusion.</param>
            <param name="ring">Assumed to have first point identical to last point.</param>
            <returns><c>true</c> if p is inside ring.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CgAlgorithms.IsOnLine(DotSpatial.Topology.Coordinate,System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Test whether a point lies on the line segments defined by a
            list of coordinates.
            </summary>
            <param name="p"></param>
            <param name="pt"></param>
            <returns>
            <c>true</c> true if
            the point is a vertex of the line or lies in the interior of a line
            segment in the linestring.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CgAlgorithms.IsCounterClockwise(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Computes whether a ring defined by an array of <see cref="T:DotSpatial.Topology.Coordinate"/>s is oriented counter-clockwise.
            The list of points is assumed to have the first and last points equal.
            This will handle coordinate lists which contain repeated points.
            This algorithm is only guaranteed to work with valid rings.
            If the ring is invalid (e.g. self-crosses or touches),
            the computed result may not be correct.
            </summary>&gt;
            <param name="ring"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CgAlgorithms.ComputeOrientation(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the orientation of a point q to the directed line segment p1-p2.
            The orientation of a point relative to a directed line segment indicates
            which way you turn to get to q after travelling from p1 to p2.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q"></param>
            <returns>
            1 if q is counter-clockwise from p1-p2,
            -1 if q is clockwise from p1-p2,
            0 if q is collinear with p1-p2-
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CgAlgorithms.DistancePointLine(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the distance from a point p to a line segment AB.
            Notice: NON-ROBUST!
            </summary>
            <param name="p">The point to compute the distance for.</param>
            <param name="a">One point of the line.</param>
            <param name="b">Another point of the line (must be different to A).</param>
            <returns> The distance from p to line segment AB.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CgAlgorithms.DistancePointLinePerpendicular(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the perpendicular distance from a point p
            to the (infinite) line containing the points AB
            </summary>
            <param name="p">The point to compute the distance for.</param>
            <param name="a">One point of the line.</param>
            <param name="b">Another point of the line (must be different to A).</param>
            <returns>The perpendicular distance from p to line AB.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CgAlgorithms.DistanceLineLine(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the distance from a line segment AB to a line segment CD.
            Notice: NON-ROBUST!
            </summary>
            <param name="a">A point of one line.</param>
            <param name="b">The second point of the line (must be different to A).</param>
            <param name="c">One point of the line.</param>
            <param name="d">Another point of the line (must be different to A).</param>
            <returns>The distance from line segment AB to line segment CD.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CgAlgorithms.SignedArea(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Returns the signed area for a ring.  The area is positive if the ring is oriented CW.
            </summary>
            <param name="ring"></param>
            <returns>Area in Meters (by default) when using projected coordinates.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.CgAlgorithms.Length(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Computes the length of a linestring specified by a sequence of points.
            </summary>
            <param name="pts">The points specifying the linestring.</param>
            <returns>The length of the linestring.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.ConvexHull">
            <summary>
            Computes the convex hull of a <see cref="T:DotSpatial.Topology.Geometry"/>.
            The convex hull is the smallest convex Geometry that contains all the
            points in the input Geometry.
            Uses the Graham Scan algorithm.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.#ctor(DotSpatial.Topology.IGeometry)">
            <summary>
            Create a new convex hull construction for the input <c>Geometry</c>.
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.#ctor(DotSpatial.Topology.Coordinate[],DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Create a new convex hull construction for the input <see cref="T:DotSpatial.Topology.Coordinate"/> array.
            </summary>
            <param name="pts"></param>
            <param name="geomFactory"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.ExtractCoordinates(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.GetConvexHull">
            <summary>
            Returns a <c>Geometry</c> that represents the convex hull of the input point.
            The point will contain the minimal number of points needed to
            represent the convex hull.  In particular, no more than two consecutive
            points will be collinear.
            </summary>
            <returns>
            If the convex hull contains 3 or more points, a <c>Polygon</c>;
            2 points, a <c>LineString</c>;
            1 point, a <c>Point</c>;
            0 points, an empty <c>GeometryCollection</c>.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.Reduce(DotSpatial.Topology.Coordinate[])">
            <summary>
            Uses a heuristic to reduce the number of points scanned to compute the hull.
            The heuristic is to find a polygon guaranteed to
            be in (or on) the hull, and eliminate all points inside it.
            A quadrilateral defined by the extremal points
            in the four orthogonal directions
            can be used, but even more inclusive is
            to use an octilateral defined by the points in the 8 cardinal directions.
            Notice that even if the method used to determine the polygon vertices
            is not 100% robust, this does not affect the robustness of the convex hull.
            </summary>
            <param name="pts"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.PreSort(DotSpatial.Topology.Coordinate[])">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.GrahamScan(DotSpatial.Topology.Coordinate[])">
             <summary>
            
             </summary>
             <param name="c"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.ReverseStack(System.Collections.Generic.Stack{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="ps"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.IsBetween(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="c1"></param>
             <param name="c2"></param>
             <param name="c3"></param>
             <returns>
             Whether the three coordinates are collinear
             and c2 lies between c1 and c3 inclusive.
             </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.ComputeOctRing(DotSpatial.Topology.Coordinate[])">
             <summary>
            
             </summary>
             <param name="inputPts"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.ComputeOctPts(DotSpatial.Topology.Coordinate[])">
             <summary>
            
             </summary>
             <param name="inputPts"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.LineOrPolygon(DotSpatial.Topology.Coordinate[])">
             <summary>
            
             </summary>
             <param name="coordinates"> The vertices of a linear ring, which may or may not be flattened (i.e. vertices collinear).</param>
             <returns>A 2-vertex <c>LineString</c> if the vertices are collinear;
             otherwise, a <c>Polygon</c> with unnecessary (collinear) vertices removed. </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.CleanRing(DotSpatial.Topology.Coordinate[])">
             <summary>
            
             </summary>
             <param name="original">The vertices of a linear ring, which may or may not be flattened (i.e. vertices collinear).</param>
             <returns>The coordinates with unnecessary (collinear) vertices removed.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.ConvexHull.RadialComparator">
            <summary>
            Compares <see cref="T:DotSpatial.Topology.Coordinate"/>s for their angle and distance
            relative to an origin.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.RadialComparator.#ctor(DotSpatial.Topology.Coordinate)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Algorithm.ConvexHull.RadialComparator"/> class.
            </summary>
            <param name="origin"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.RadialComparator.Compare(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p1"></param>
             <param name="p2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.ConvexHull.RadialComparator.PolarCompare(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="o"></param>
             <param name="p"></param>
             <param name="q"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.HCoordinate">
            <summary>
            Represents a homogeneous coordinate for 2-D coordinates.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.HCoordinate.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.HCoordinate.#ctor(System.Double,System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="x"></param>
             <param name="y"></param>
             <param name="w"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.HCoordinate.#ctor(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.HCoordinate.#ctor(DotSpatial.Topology.Algorithm.HCoordinate,DotSpatial.Topology.Algorithm.HCoordinate)">
             <summary>
            
             </summary>
             <param name="p1"></param>
             <param name="p2"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.HCoordinate.Intersection(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the (approximate) intersection point between two line segments
            using homogeneous coordinates.
            Notice that this algorithm is
            not numerically stable; i.e. it can produce intersection points which
            lie outside the envelope of the line segments themselves.  In order
            to increase the precision of the calculation input points should be normalized
            before passing them to this routine.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.HCoordinate.GetX">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.HCoordinate.GetY">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.HCoordinate.X">
            <summary>
            Direct access to x private field
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.HCoordinate.Y">
            <summary>
            Direct access to y private field
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.HCoordinate.W">
            <summary>
            Direct access to w private field
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.HCoordinate.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.InteriorPointArea">
            <summary>
            Computes a point in the interior of an area point.
            Algorithm:
            Find the intersections between the point
            and the horizontal bisector of the area's envelope
            Pick the midpoint of the largest intersection (the intersections
            will be lines and points)
            Notice: If a fixed precision model is used,
            in some cases this method may return a point
            which does not lie in the interior.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointArea.#ctor(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointArea.Avg(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="a"></param>
             <param name="b"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointArea.Add(DotSpatial.Topology.IGeometry)">
            <summary>
            Tests the interior vertices (if any)
            defined by a linear Geometry for the best inside point.
            If a Geometry is not of dimension 1 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointArea.AddPolygon(DotSpatial.Topology.IGeometry)">
            <summary>
            Adds a polygon.
            </summary>
            <param name="geometry">The polygon to add.</param>>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointArea.WidestGeometry(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <returns>
             If point is a collection, the widest sub-point; otherwise,
             the point itself.
             </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointArea.WidestGeometry(DotSpatial.Topology.IGeometryCollection)">
             <summary>
            
             </summary>
             <param name="gc"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointArea.HorizontalBisector(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geometry"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointArea.Centre(DotSpatial.Topology.IEnvelope)">
            <summary>
            Returns the centre point of the envelope.
            </summary>
            <param name="envelope">The envelope to analyze.</param>
            <returns> The centre of the envelope.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.InteriorPointArea.InteriorPoint">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.InteriorPointLine">
            <summary>
            Computes a point in the interior of an linear point.
            Algorithm:
            Find an interior vertex which is closest to
            the centroid of the linestring.
            If there is no interior vertex, find the endpoint which is
            closest to the centroid.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointLine.#ctor(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointLine.AddInterior(DotSpatial.Topology.IGeometry)">
            <summary>
            Tests the interior vertices (if any)
            defined by a linear Geometry for the best inside point.
            If a Geometry is not of dimension 1 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointLine.AddInterior(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="pts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointLine.AddEndpoints(DotSpatial.Topology.IGeometry)">
            <summary>
            Tests the endpoint vertices
            defined by a linear Geometry for the best inside point.
            If a Geometry is not of dimension 1 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointLine.AddEndpoints(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="pts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointLine.Add(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="point"></param>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.InteriorPointLine.InteriorPoint">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.InteriorPointPoint">
            <summary>
            Computes a point in the interior of an point point.
            Algorithm:
            Find a point which is closest to the centroid of the point.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointPoint.#ctor(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointPoint.Add(DotSpatial.Topology.IGeometry)">
            <summary>
            Tests the point(s) defined by a Geometry for the best inside point.
            If a Geometry is not of dimension 0 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.InteriorPointPoint.Add(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="point"></param>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.InteriorPointPoint.InteriorPoint">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.IntersectionType">
            <summary>
            IntersectionTypes
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Algorithm.IntersectionType.NoIntersection">
            <summary>
            No intersection occurs
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Algorithm.IntersectionType.PointIntersection">
            <summary>
            The lines intersect in a single point
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Algorithm.IntersectionType.Collinear">
            <summary>
            The lines intersect by overlapping
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.IPointInRing">
            <summary>
            An interface for classes which test whether a <c>Coordinate</c> lies inside a ring.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.IPointInRing.IsInside(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="pt"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.LineIntersector">
            <summary>
            A LineIntersector is an algorithm that can both test whether
            two line segments intersect and compute the intersection point
            if they do.
            The intersection point may be computed in a precise or non-precise manner.
            Computing it precisely involves rounding it to an integer.  (This assumes
            that the input coordinates have been made precise by scaling them to
            an integer grid.)
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Algorithm.LineIntersector._intLineIndex">
            <summary>
            The indexes of the endpoints of the intersection lines, in order along
            the corresponding line
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Algorithm.LineIntersector._precisionModel">
            <summary>
            If MakePrecise is true, computed intersection coordinates will be made precise
            using <c>Coordinate.MakePrecise</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.ComputeEdgeDistance(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the "edge distance" of an intersection point p along a segment.
            The edge distance is a metric of the point along the edge.
            The metric used is a robust and easy to compute metric function.
            It is not equivalent to the usual Euclidean metric.
            It relies on the fact that either the x or the y ordinates of the
            points in the edge are unique, depending on whether the edge is longer in
            the horizontal or vertical direction.
            Notice: This function may produce incorrect distances
            for inputs where p is not precisely on p1-p2
            (E.g. p = (139, 9) p1 = (139, 10), p2 = (280, 1) produces distanct 0.0, which is incorrect.
            My hypothesis is that the function is safe to use for points which are the
            result of rounding points which lie on the line, but not safe to use for truncated points.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.NonRobustComputeEdgeDistance(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            This function is non-robust, since it may compute the square of large numbers.
            Currently not sure how to improve this.
            </summary>
            <param name="p"></param>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.ComputeIntersection(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Compute the intersection of a point p and the line p1-p2.
            This function computes the bool value of the hasIntersection test.
            The actual value of the intersection (if there is one)
            is equal to the value of <c>p</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.ComputeIntersection(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Computes the intersection of the lines p1-p2 and p3-p4.
            This function computes both the bool value of the hasIntersection test
            and the (approximate) value of the intersection point itself (if there is one).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.ComputeIntersect(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p1"></param>
             <param name="p2"></param>
             <param name="q1"></param>
             <param name="q2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.GetIntersection(System.Int32)">
            <summary>
            Returns the intIndex'th intersection point.
            </summary>
            <param name="intIndex">is 0 or 1.</param>
            <returns>The intIndex'th intersection point.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.ComputeIntLineIndex">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.IsIntersection(DotSpatial.Topology.Coordinate)">
            <summary>
            Test whether a point is a intersection point of two line segments.
            Notice that if the intersection is a line segment, this method only tests for
            equality with the endpoints of the intersection segment.
            It does not return true if the input point is internal to the intersection segment.
            </summary>
            <returns><c>true</c> if the input point is one of the intersection points.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.IsInteriorIntersection">
            <summary>
            Tests whether either intersection point is an interior point of one of the input segments.
            </summary>
            <returns>
            <c>true</c> if either intersection point is in the interior of one of the input segment.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.IsInteriorIntersection(System.Int32)">
            <summary>
            Tests whether either intersection point is an interior point of the specified input segment.
            </summary>
            <returns>
            <c>true</c> if either intersection point is in the interior of the input segment.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.GetIntersectionAlongSegment(System.Int32,System.Int32)">
            <summary>
            Computes the coordinate of the intIndex'th intersection point in the direction of
            a specified input line segment.
            </summary>
            <param name="segmentIndex">The segment index from 0 to 1.</param>
            <param name="intIndex">The integer intersection index from 0 to 1.</param>
            <returns>
            The coordinate of the intIndex'th intersection point in the direction of the specified input line segment.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.GetIndexAlongSegment(System.Int32,System.Int32)">
            <summary>
            Computes the index of the intIndex'th intersection point in the direction of
            a specified input line segment, and returns the integer index.
            </summary>
            <param name="segmentIndex">The integer segment index from 0 to 1.</param>
            <param name="intIndex">The integer intersection index from 0 to 1.</param>
            <returns>
            The integer index of the intersection point along the segment (0 or 1).
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.ComputeIntLineIndex(System.Int32)">
            <summary>
            Computes the integer line index of the specified integer segment index.
            </summary>
            <param name="segmentIndex">The integer index of the segment.</param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.LineIntersector.GetEdgeDistance(System.Int32,System.Int32)">
            <summary>
            Computes the "edge distance" of an intersection point along the specified input line segment.
            </summary>
            <param name="segmentIndex">The integer segment index from 0 to 1.</param>
            <param name="intIndex">The integer intersection index from 0 to 1.</param>
            <returns>The edge distance of the intersection point.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.LineIntersector.PointA">
            <summary>
            Gets or sets the first intersection coordinate, if any.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.LineIntersector.PointB">
            <summary>
            Gets or sets the second intersection coordiante, if any.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.LineIntersector.MakePrecise">
            <summary>
            Force computed intersection to be rounded to a given precision model
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.LineIntersector.PrecisionModel">
            <summary>
            Force computed intersection to be rounded to a given precision model.
            No getter is provided, because the precision model is not required to be specified.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.LineIntersector.HasIntersection">
            <summary>
            Tests whether the input geometries intersect.
            </summary>
            <returns><c>true</c> if the input geometries intersect.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.LineIntersector.IntersectionNum">
            <summary>
            Returns the number of intersection points found.  This will be either 0, 1 or 2.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.LineIntersector.IntersectionPoints">
            <summary>
            Gets the array of intersection points
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.LineIntersector.InputLines">
            <summary>
            Gets or sets a two dimensional array of coordinates representing the input lines for the calculation
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.LineIntersector.IsCollinear">
            <summary>
            This is true if the intersection forms a line
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.LineIntersector.IsEndPoint">
            <summary>
            Gets Whether this is both propper and has an intersection
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.LineIntersector.IsProper">
            <summary>
            Tests whether an intersection is proper.
            The intersection between two line segments is considered proper if
            they intersect in a single point in the interior of both segments
            (e.g. the intersection is a single point and is not equal to any of the endpoints).
            The intersection between a point and a line segment is considered proper
            if the point lies in the interior of the segment (e.g. is not equal to either of the endpoints).
            </summary>
            <returns><c>true</c>  if the intersection is proper.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.LineIntersector.Result">
            <summary>
            Gets or sets the integer result
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.McPointInRing">
            <summary>
            Implements <c>IPointInRing</c>
            using a <c>MonotoneChain</c>s and a <c>BinTree</c> index to increase performance.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.McPointInRing.#ctor(DotSpatial.Topology.ILinearRing)">
             <summary>
            
             </summary>
             <param name="ring"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.McPointInRing.IsInside(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="pt"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.McPointInRing.BuildIndex">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.McPointInRing.TestMonotoneChain(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Index.Chain.MonotoneChainSelectAction,DotSpatial.Topology.Index.Chain.MonotoneChain)">
             <summary>
            
             </summary>
             <param name="rayEnv"></param>
             <param name="mcSelecter"></param>
             <param name="mc"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.McPointInRing.TestLineSegment(DotSpatial.Topology.Coordinate,DotSpatial.Topology.ILineSegmentBase)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="seg"></param>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.McPointInRing.McSelecter">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Chain.MonotoneChainSelectAction">
            <summary>
            The action for the internal iterator for performing
            envelope select queries on a MonotoneChain.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Index.Chain.MonotoneChainSelectAction.TempEnv1">
            <summary>
            These envelopes are used during the MonotoneChain search process.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChainSelectAction.Select(DotSpatial.Topology.Index.Chain.MonotoneChain,System.Int32)">
            <summary>
            This function can be overridden if the original chain is needed.
            </summary>
            <param name="mc"></param>
            <param name="start"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChainSelectAction.Select(DotSpatial.Topology.LineSegment)">
            <summary>
            This is a convenience function which can be overridden to obtain the actual
            line segment which is selected.
            </summary>
            <param name="seg"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.McPointInRing.McSelecter.#ctor(DotSpatial.Topology.Algorithm.McPointInRing,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="container"></param>
             <param name="p"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.McPointInRing.McSelecter.Select(DotSpatial.Topology.LineSegment)">
             <summary>
            
             </summary>
             <param name="ls"></param>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.MinimumDiameter">
            <summary>
            Computes the minimum diameter of a <c>Geometry</c>.
            The minimum diameter is defined to be the
            width of the smallest band that contains the point,
            where a band is a strip of the plane defined
            by two parallel lines.
            This can be thought of as the smallest hole that the point can be
            moved through, with a single rotation.
            The first step in the algorithm is computing the convex hull of the Geometry.
            If the input Geometry is known to be convex, a hint can be supplied to
            avoid this computation.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.MinimumDiameter.#ctor(DotSpatial.Topology.IGeometry)">
            <summary>
            Compute a minimum diameter for a giver <c>Geometry</c>.
            </summary>
            <param name="inputGeom">a Geometry.</param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.MinimumDiameter.#ctor(DotSpatial.Topology.IGeometry,System.Boolean)">
            <summary>
            Compute a minimum diameter for a giver <c>Geometry</c>,
            with a hint if
            the Geometry is convex
            (e.g. a convex Polygon or LinearRing,
            or a two-point LineString, or a Point).
            </summary>
            <param name="inputGeom">a Geometry which is convex.</param>
            <param name="isConvex"><c>true</c> if the input point is convex.</param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.MinimumDiameter.ComputeMinimumDiameter">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.MinimumDiameter.ComputeWidthConvex(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.MinimumDiameter.ComputeConvexRingMinDiameter(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Compute the width information for a ring of <c>Coordinate</c>s.
            Leaves the width information in the instance variables.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.MinimumDiameter.FindMaxPerpDistance(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},DotSpatial.Topology.ILineSegment,System.Int32)">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <param name="seg"></param>
             <param name="startIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.MinimumDiameter.NextIndex(System.Collections.Generic.ICollection{DotSpatial.Topology.Coordinate},System.Int32)">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <param name="index"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.MinimumDiameter.Length">
            <summary>
            Gets the length of the minimum diameter of the input Geometry.
            </summary>
            <returns>The length of the minimum diameter.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.MinimumDiameter.WidthCoordinate">
            <summary>
            Gets the <c>Coordinate</c> forming one end of the minimum diameter.
            </summary>
            <returns>A coordinate forming one end of the minimum diameter.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.MinimumDiameter.SupportingSegment">
            <summary>
            Gets the segment forming the base of the minimum diameter.
            </summary>
            <returns>The segment forming the base of the minimum diameter.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Algorithm.MinimumDiameter.Diameter">
            <summary>
            Gets a <c>LineString</c> which is a minimum diameter.
            </summary>
            <returns>A <c>LineString</c> which is a minimum diameter.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.NonRobustCgAlgorithms">
            <summary>
            Non-robust versions of various fundamental Computational Geometric algorithms,
            FOR TESTING PURPOSES ONLY!.
            The non-robustness is due to rounding error in floating point computation.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.NonRobustCgAlgorithms.IsPointInRing(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate[])">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="ring"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.NonRobustCgAlgorithms.IsCcw(DotSpatial.Topology.Coordinate[])">
            <summary>
            Computes whether a ring defined by an array of <c>Coordinate</c> is
            oriented counter-clockwise.
            This will handle coordinate lists which contain repeated points.
            </summary>
            <param name="ring">an array of coordinates forming a ring.</param>
            <returns>
            <c>true</c> if the ring is oriented counter-clockwise.
            throws <c>ArgumentException</c> if the ring is degenerate (does not contain 3 different points)
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.NonRobustCgAlgorithms.ComputeOrientation(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p1"></param>
             <param name="p2"></param>
             <param name="q"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.NonRobustLineIntersector">
            <summary>
            A non-robust version of <c>LineIntersector</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.NonRobustLineIntersector.IsSameSignAndNonZero(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="a"></param>
             <param name="b"></param>
             <returns>
             <c>true</c> if both numbers are positive or if both numbers are negative,
             <c>false</c> if both numbers are zero.
             </returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.NonRobustLineIntersector.ComputeIntersection(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="p1"></param>
             <param name="p2"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.NonRobustLineIntersector.ComputeIntersect(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p1"></param>
             <param name="p2"></param>
             <param name="p3"></param>
             <param name="p4"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.NonRobustLineIntersector.ComputeCollinearIntersection(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p1"></param>
             <param name="p2"></param>
             <param name="p3"></param>
             <param name="p4"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.NonRobustLineIntersector.RParameter(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            RParameter computes the parameter for the point p
            in the parameterized equation
            of the line from p1 to p2.
            This is equal to the 'distance' of p along p1-p2.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.NotRepresentableException">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.NotRepresentableException.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.PointLocator">
            <summary>
            Computes the topological relationship (Location) of a single point to a Geometry.
            The algorithm obeys the SFS boundaryDetermination rule to correctly determine
            whether the point lies on the boundary or not.
            Notice that instances of this class are not reentrant.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.PointLocator.Intersects(DotSpatial.Topology.Coordinate,DotSpatial.Topology.IGeometry)">
            <summary>
            Convenience method to test a point for intersection with a Geometry
            </summary>
            <param name="p">The coordinate to test.</param>
            <param name="geom">The Geometry to test.</param>
            <returns><c>true</c> if the point is in the interior or boundary of the Geometry.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.PointLocator.Locate(DotSpatial.Topology.Coordinate,DotSpatial.Topology.IGeometry)">
            <summary>
            Computes the topological relationship ({Location}) of a single point to a Geometry.
            It handles both single-element and multi-element Geometries.
            The algorithm for multi-part Geometries takes into account the boundaryDetermination rule.
            </summary>
            <returns>The Location of the point relative to the input Geometry.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.PointLocator.ComputeLocation(DotSpatial.Topology.Coordinate,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.PointLocator.UpdateLocationInfo(DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="loc"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.PointLocator.LocateInLineString(DotSpatial.Topology.Coordinate,DotSpatial.Topology.ILineString)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="l"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.PointLocator.LocateInPolygonRing(DotSpatial.Topology.Coordinate,DotSpatial.Topology.IBasicGeometry)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="ring"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.PointLocator.LocateInPolygon(DotSpatial.Topology.Coordinate,DotSpatial.Topology.IPolygon)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="poly"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.RobustDeterminant">
             <summary>
             Implements an algorithm to compute the
             sign of a 2x2 determinant for double precision values robustly.
             It is a direct translation of code developed by Olivier Devillers.
            
             The original code carries the following copyright notice:
             ************************************************************************
             Author : Olivier Devillers
             Olivier.Devillers@sophia.inria.fr
             http:/www.inria.fr:/prisme/personnel/devillers/anglais/determinant.html
             *************************************************************************
             *************************************************************************
             Copyright (c) 1995  by  INRIA Prisme Project
             BP 93 06902 Sophia Antipolis Cedex, France.
             All rights reserved
             *************************************************************************
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.RobustDeterminant.SignOfDet2X2(System.Double,System.Double,System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="x1"></param>
             <param name="y1"></param>
             <param name="x2"></param>
             <param name="y2"></param>
             <returns>
             returns -1 if the determinant is negative,
             returns  1 if the determinant is positive,
             retunrs  0 if the determinant is null.
             </returns>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.RobustLineIntersector">
            <summary>
            A robust version of <c>LineIntersector</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.RobustLineIntersector.ComputeIntersection(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="p1"></param>
             <param name="p2"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.RobustLineIntersector.ComputeIntersect(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p1"></param>
             <param name="p2"></param>
             <param name="q1"></param>
             <param name="q2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.RobustLineIntersector.ComputeCollinearIntersection(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p1"></param>
             <param name="p2"></param>
             <param name="q1"></param>
             <param name="q2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.RobustLineIntersector.Intersection(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            This method computes the actual value of the intersection point.
            To obtain the maximum precision from the intersection calculation,
            the coordinates are normalized by subtracting the minimum
            ordinate values (in absolute value).  This has the effect of
            removing common significant digits from the calculation to
            maintain more bits of precision.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.RobustLineIntersector.NormalizeToEnvCentre(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
             Normalize the supplied coordinates to
            so that the midpoint of their intersection envelope
            lies at the origin.
            </summary>
            <param name="n00"></param>
            <param name="n01"></param>
            <param name="n10"></param>
            <param name="n11"></param>
            <param name="normPt"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.RobustLineIntersector.IsInSegmentEnvelopes(DotSpatial.Topology.Coordinate)">
            <summary>
            Test whether a point lies in the envelopes of both input segments.
            A correctly computed intersection point should return <c>true</c>
            for this test.
            Since this test is for debugging purposes only, no attempt is
            made to optimize the envelope test.
            </summary>
            <param name="intPt"></param>
            <returns><c>true</c> if the input point lies within both input segment envelopes.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.SimplePointInAreaLocator">
            <summary>
            Computes whether a point
            lies in the interior of an area <c>Geometry</c>.
            The algorithm used is only guaranteed to return correct results
            for points which are not on the boundary of the Geometry.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.SimplePointInAreaLocator.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.SimplePointInAreaLocator.Locate(DotSpatial.Topology.Coordinate,DotSpatial.Topology.IGeometry)">
            <summary>
            Locate is the main location function.  It handles both single-element
            and multi-element Geometries.  The algorithm for multi-element Geometries
            is more complex, since it has to take into account the boundaryDetermination rule.
            </summary>
            <param name="p">The coordinate to locate.</param>
            <param name="geom">The Geometry to locate the coordinate in.</param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.SimplePointInAreaLocator.ContainsPoint(DotSpatial.Topology.Coordinate,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.SimplePointInAreaLocator.ContainsPointInPolygon(DotSpatial.Topology.Coordinate,DotSpatial.Topology.IPolygon)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="poly"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.SimplePointInRing">
            <summary>
            Tests whether a <c>Coordinate</c> lies inside
            a ring, using a linear-time algorithm.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Algorithm.SimplePointInRing._pts">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.SimplePointInRing.#ctor(DotSpatial.Topology.IBasicGeometry)">
             <summary>
            
             </summary>
             <param name="ring"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.SimplePointInRing.IsInside(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="pt"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Algorithm.SiRtreePointInRing">
            <summary>
            Implements <c>PointInRing</c> using a <c>SIRtree</c> index to increase performance.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.SiRtreePointInRing.#ctor(DotSpatial.Topology.LinearRing)">
             <summary>
            
             </summary>
             <param name="ring"></param>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.SiRtreePointInRing.IsInside(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="pt"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.SiRtreePointInRing.BuildIndex">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Algorithm.SiRtreePointInRing.TestLineSegment(DotSpatial.Topology.Coordinate,DotSpatial.Topology.ILineSegmentBase)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="seg"></param>
        </member>
        <member name="T:DotSpatial.Topology.ClassNotSupportedException">
            <summary>
            A ClassNotSupportedException Class
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.ClassNotSupportedException.#ctor(System.String)">
            <summary>
            Creates a new instance of ClassNotSupportedException
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.ArrayListVisitor">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.IItemVisitor">
            <summary>
            A visitor for items in an index.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.IItemVisitor.VisitItem(System.Object)">
             <summary>
            
             </summary>
             <param name="item"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.ArrayListVisitor.VisitItem(System.Object)">
             <summary>
            
             </summary>
             <param name="item"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.ArrayListVisitor.Items">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Bintree.Bintree">
            <summary>
            An <c>BinTree</c> (or "Binary Interval Tree")
            is a 1-dimensional version of a quadtree.
            It indexes 1-dimensional intervals (which of course may
            be the projection of 2-D objects on an axis).
            It supports range searching
            (where the range may be a single point).
            This implementation does not require specifying the extent of the inserted
            items beforehand.  It will automatically expand to accomodate any extent
            of dataset.
            This index is different to the Interval Tree of Edelsbrunner
            or the Segment Tree of Bentley.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Bintree.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Bintree.EnsureExtent(DotSpatial.Topology.Index.Bintree.Interval,System.Double)">
            <summary>
            Ensure that the Interval for the inserted item has non-zero extents.
            Use the current minExtent to pad it, if necessary.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Bintree.Insert(DotSpatial.Topology.Index.Bintree.Interval,System.Object)">
             <summary>
            
             </summary>
             <param name="itemInterval"></param>
             <param name="item"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Bintree.GetEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Bintree.Query(System.Double)">
             <summary>
            
             </summary>
             <param name="x"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Bintree.Query(DotSpatial.Topology.Index.Bintree.Interval)">
            <summary>
            min and max may be the same value.
            </summary>
            <param name="interval"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Bintree.Query(DotSpatial.Topology.Index.Bintree.Interval,System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="interval"></param>
             <param name="foundItems"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Bintree.CollectStats(DotSpatial.Topology.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="interval"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.Bintree.Depth">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.Bintree.Count">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.Bintree.NodeSize">
            <summary>
            Compute the total number of nodes in the tree.
            </summary>
            <returns>The number of nodes in the tree.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Index.Bintree.Interval">
            <summary>
            Represents an (1-dimensional) closed interval on the Real number line.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Interval.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Interval.#ctor(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="min"></param>
             <param name="max"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Interval.#ctor(DotSpatial.Topology.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="interval"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Interval.Init(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="min"></param>
             <param name="max"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Interval.ExpandToInclude(DotSpatial.Topology.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="interval"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Interval.Overlaps(DotSpatial.Topology.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="interval"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Interval.Overlaps(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="min"></param>
             <param name="max"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Interval.Contains(DotSpatial.Topology.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="interval"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Interval.Contains(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="min"></param>
             <param name="max"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Interval.Contains(System.Double)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.Interval.Min">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.Interval.Max">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.Interval.Width">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Bintree.Key">
            <summary>
            A Key is a unique identifier for a node in a tree.
            It contains a lower-left point and a level number. The level number
            is the power of two for the size of the node envelope.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Key.#ctor(DotSpatial.Topology.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="interval"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Key.ComputeLevel(DotSpatial.Topology.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="interval"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Key.ComputeKey(DotSpatial.Topology.Index.Bintree.Interval)">
            <summary>
            Return a square envelope containing the argument envelope,
            whose extent is a power of two and which is based at a power of 2.
            </summary>
            <param name="itemInterval"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Key.ComputeInterval(System.Int32,DotSpatial.Topology.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="level"></param>
             <param name="itemInterval"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.Key.Point">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.Key.Level">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.Key.Interval">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Bintree.Node">
            <summary>
            A node of a <c>Bintree</c>.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Bintree.NodeBase">
            <summary>
            The base class for nodes in a <c>Bintree</c>.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Index.Bintree.NodeBase._subnode">
            <summary>
            Subnodes are numbered as follows:
            0 | 1
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.NodeBase.Add(System.Object)">
            <summary>
            Adds the specified object to the items list for this node.  This will not affect child nodes.
            </summary>
            <param name="item">The object item to add to the list.</param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.NodeBase.AddAllItems(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="items"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.NodeBase.AddAllItemsFromOverlapping(DotSpatial.Topology.Index.Bintree.Interval,System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="interval"></param>
             <param name="resultItems"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.NodeBase.IsSearchMatch(DotSpatial.Topology.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="interval"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.NodeBase.GetSubnodeIndex(DotSpatial.Topology.Index.Bintree.Interval,System.Double)">
            <summary>
            Returns the index of the subnode that wholely contains the given interval.
            If none does, returns -1.
            </summary>
            <param name="interval"></param>
            <param name="centre"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.NodeBase.Count">
            <summary>
            Gets the count of all the items in this node, plus all the items in all of the child nodes
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.NodeBase.Depth">
            <summary>
            Gets an integer representing the maximum levels needed to be decended to account for all the child nodes
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.NodeBase.Items">
            <summary>
            Gets a list of all the items currently stored in this node.  This does not include
            any items from child nodes.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.NodeBase.NodeCount">
            <summary>
            Gets the count of this node plus all of the child nodes
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.NodeBase.Nodes">
            <summary>
            Gets the array of all the sub-nodes below this node.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Node.#ctor(DotSpatial.Topology.Index.Bintree.Interval,System.Int32)">
             <summary>
            
             </summary>
             <param name="interval"></param>
             <param name="level"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Node.CreateNode(DotSpatial.Topology.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="itemInterval"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Node.CreateExpanded(DotSpatial.Topology.Index.Bintree.Node,DotSpatial.Topology.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="node"></param>
             <param name="addInterval"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Node.IsSearchMatch(DotSpatial.Topology.Index.Bintree.Interval)">
             <summary>
            
             </summary>
             <param name="itemInterval"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Node.GetNode(DotSpatial.Topology.Index.Bintree.Interval)">
            <summary>
            Returns the subnode containing the envelope.
            Creates the node if
            it does not already exist.
            </summary>
            <param name="searchInterval"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Node.Find(DotSpatial.Topology.Index.Bintree.Interval)">
            <summary>
            Returns the smallest existing
            node containing the envelope.
            </summary>
            <param name="searchInterval"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Node.Insert(DotSpatial.Topology.Index.Bintree.Node)">
             <summary>
            
             </summary>
             <param name="node"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Node.GetSubnode(System.Int32)">
            <summary>
            Get the subnode for the index.
            If it doesn't exist, create it.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Node.CreateSubnode(System.Int32)">
             <summary>
            
             </summary>
             <param name="index"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Index.Bintree.Node.Interval">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Bintree.Root">
            <summary>
            The root node of a single <c>Bintree</c>.
            It is centred at the origin,
            and does not have a defined extent.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Root.Insert(DotSpatial.Topology.Index.Bintree.Interval,System.Object)">
            <summary>
            Insert an item into the tree this is the root of.
            </summary>
            <param name="itemInterval"></param>
            <param name="item"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Root.InsertContained(DotSpatial.Topology.Index.Bintree.Node,DotSpatial.Topology.Index.Bintree.Interval,System.Object)">
            <summary>
            Insert an item which is known to be contained in the tree rooted at
            the given Node.  Lower levels of the tree will be created
            if necessary to hold the item.
            </summary>
            <param name="tree"></param>
            <param name="itemInterval"></param>
            <param name="item"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Bintree.Root.IsSearchMatch(DotSpatial.Topology.Index.Bintree.Interval)">
            <summary>
            The root node matches all searches.
            </summary>
            <param name="interval"></param>
        </member>
        <member name="T:DotSpatial.Topology.Index.Chain.MonotoneChain">
            <summary>
            MonotoneChains are a way of partitioning the segments of a linestring to
            allow for fast searching of intersections.
            They have the following properties:
            the segments within a monotone chain will never intersect each other
            the envelope of any contiguous subset of the segments in a monotone chain
            is equal to the envelope of the endpoints of the subset.
            Property 1 means that there is no need to test pairs of segments from within
            the same monotone chain for intersection.
            Property 2 allows
            binary search to be used to find the intersection points of two monotone chains.
            For many types of real-world data, these properties eliminate a large number of
            segment comparisons, producing substantial speed gains.
            One of the goals of this implementation of MonotoneChains is to be
            as space and time efficient as possible. One design choice that aids this
            is that a MonotoneChain is based on a subarray of a list of points.
            This means that new arrays of points (potentially very large) do not
            have to be allocated.
            MonotoneChains support the following kinds of queries:
            Envelope select: determine all the segments in the chain which
            intersect a given envelope.
            Overlap: determine all the pairs of segments in two chains whose
            envelopes overlap.
            This implementation of MonotoneChains uses the concept of internal iterators
            to return the resultsets for the above queries.
            This has time and space advantages, since it
            is not necessary to build lists of instantiated objects to represent the segments
            returned by the query.
            However, it does mean that the queries are not thread-safe.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChain.#ctor(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Int32,System.Int32,System.Object)">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <param name="start"></param>
             <param name="end"></param>
             <param name="context"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChain.GetLineSegment(System.Int32)">
            <summary>
            Gets a copy of the line segment located at the specified index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChain.Select(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Index.Chain.MonotoneChainSelectAction)">
            <summary>
            Determine all the line segments in the chain whose envelopes overlap
            the searchEnvelope, and process them.
            </summary>
            <param name="searchEnv"></param>
            <param name="mcs"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChain.ComputeSelect(DotSpatial.Topology.IEnvelope,System.Int32,System.Int32,DotSpatial.Topology.Index.Chain.MonotoneChainSelectAction)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <param name="start0"></param>
             <param name="end0"></param>
             <param name="mcs"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChain.ComputeOverlaps(DotSpatial.Topology.Index.Chain.MonotoneChain,DotSpatial.Topology.Index.Chain.MonotoneChainOverlapAction)">
             <summary>
            
             </summary>
             <param name="mc"></param>
             <param name="mco"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChain.ComputeOverlaps(System.Int32,System.Int32,DotSpatial.Topology.Index.Chain.MonotoneChain,System.Int32,System.Int32,DotSpatial.Topology.Index.Chain.MonotoneChainOverlapAction)">
             <summary>
            
             </summary>
             <param name="start0"></param>
             <param name="end0"></param>
             <param name="mc"></param>
             <param name="start1"></param>
             <param name="end1"></param>
             <param name="mco"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.Chain.MonotoneChain.Id">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Chain.MonotoneChain.Context">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Chain.MonotoneChain.Envelope">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Chain.MonotoneChain.StartIndex">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Chain.MonotoneChain.EndIndex">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Chain.MonotoneChain.Coordinates">
            <summary>
            Return the subsequence of coordinates forming this chain.
            Allocates a new array to hold the Coordinates.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Chain.MonotoneChainBuilder">
            <summary>
            A MonotoneChainBuilder implements static functions
            to determine the monotone chains in a sequence of points.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChainBuilder.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChainBuilder.ToIntArray(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="list"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChainBuilder.GetChains(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChainBuilder.GetChains(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Object)">
            <summary>
            Return a list of the <c>MonotoneChain</c>s
            for the given list of coordinates.
            </summary>
            <param name="pts"></param>
            <param name="context"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChainBuilder.GetChainStartIndices(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Return an array containing lists of start/end indexes of the monotone chains
            for the given list of coordinates.
            The last entry in the array points to the end point of the point array,
            for use as a sentinel.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChainBuilder.FindChainEnd(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Int32)">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <param name="start"></param>
             <returns>
             The index of the last point in the monotone chain starting at <c>start</c>.
             </returns>
        </member>
        <member name="T:DotSpatial.Topology.Index.Chain.MonotoneChainOverlapAction">
            <summary>
            The action for the internal iterator for performing
            overlap queries on a MonotoneChain.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChainOverlapAction.Overlap(DotSpatial.Topology.Index.Chain.MonotoneChain,System.Int32,DotSpatial.Topology.Index.Chain.MonotoneChain,System.Int32)">
            <summary>
            This function can be overridden if the original chains are needed.
            </summary>
            <param name="mc1"></param>
            <param name="start1">The index of the start of the overlapping segment from mc1.</param>
            <param name="mc2"></param>
            <param name="start2">The index of the start of the overlapping segment from mc2.</param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Chain.MonotoneChainOverlapAction.Overlap(DotSpatial.Topology.LineSegment,DotSpatial.Topology.LineSegment)">
            <summary>
            This is a convenience function which can be overridden to obtain the actual
            line segments which overlap.
            </summary>
            <param name="seg1"></param>
            <param name="seg2"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.Chain.MonotoneChainOverlapAction.TempEnv1">
            <summary>
            This envelope is used during the MonotoneChain search process.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Chain.MonotoneChainOverlapAction.TempEnv2">
            <summary>
            This envelope is used during the MonotoneChain search process.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Chain.MonotoneChainOverlapAction.OverlapSeg1">
            <summary>
            One overlapping segment.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Chain.MonotoneChainOverlapAction.OverlapSeg2">
            <summary>
            The other overlapping segment.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.IIndexVisitor">
            <summary>
            A visitor for nodes and items in an index.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.IIndexVisitor.VisitItem(System.Object)">
             <summary>
            
             </summary>
             <param name="item"></param>
        </member>
        <member name="T:DotSpatial.Topology.Index.ISpatialIndex">
            <summary>
            The basic insertion and query operations supported by classes
            implementing spatial index algorithms.
            A spatial index typically provides a primary filter for range rectangle queries. A
            secondary filter is required to test for exact intersection. Of course, this
            secondary filter may consist of other tests besides intersection, such as
            testing other kinds of spatial relationships.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.ISpatialIndex.Insert(DotSpatial.Topology.IEnvelope,System.Object)">
            <summary>
            Adds a spatial item with an extent specified by the given <c>Envelope</c> to the index.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.ISpatialIndex.Query(DotSpatial.Topology.IEnvelope)">
            <summary>
            Queries the index for all items whose extents intersect the given search <c>Envelope</c>
            Notice that some kinds of indexes may also return objects which do not in fact
            intersect the query envelope.
            </summary>
            <param name="searchEnv">The envelope to query for.</param>
            <returns>A list of the items found by the query.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.ISpatialIndex.Query(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Index.IItemVisitor)">
            <summary>
            Queries the index for all items whose extents intersect the given search <see cref="T:DotSpatial.Topology.Envelope"/>,
            and applies an <see cref="T:DotSpatial.Topology.Index.IItemVisitor"/> to them.
            Notice that some kinds of indexes may also return objects which do not in fact
            intersect the query envelope.
            </summary>
            <param name="searchEnv">The envelope to query for.</param>
            <param name="visitor">A visitor object to apply to the items found.</param>
        </member>
        <member name="M:DotSpatial.Topology.Index.ISpatialIndex.Remove(DotSpatial.Topology.IEnvelope,System.Object)">
            <summary>
            Removes a single item from the tree.
            </summary>
            <param name="itemEnv">The Envelope of the item to remove.</param>
            <param name="item">The item to remove.</param>
            <returns> <c>true</c> if the item was found.</returns>
        </member>
        <member name="T:DotSpatial.Topology.KDTree.FarthestNeighborList">
            <summary>
            Bjoern Heckel's solution to the KD-Tree n-nearest-neighbor problem
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.FarthestNeighborList.#ctor(System.Int32)">
            <summary>
            Creates a new NearestNeighborList
            </summary>
            <param name="capacity">An integer indicating the maximum size for the cue</param>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.FarthestNeighborList.Insert(System.Object,System.Double)">
            <summary>
            Inserts an object with a given priority
            </summary>
            <param name="obj"></param>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.FarthestNeighborList.RemoveFarthest">
            <summary>
            Removes the highest member from the cue and returns that object.
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.FarthestNeighborList.MinimumPriority">
            <summary>
            Gets the minimum priority, or distance.  Since we are looking for the maximum distance, or the
            n maximum distances, we want to determine quickly the lowest distance currently contained
            in the cue.
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.FarthestNeighborList.IsCapacityReached">
            <summary>
            Gets whether or not the length of the cue has reached the capacity
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.FarthestNeighborList.Farthest">
            <summary>
            Gets the highest object in the nearest neighbor list
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.FarthestNeighborList.IsEmpty">
            <summary>
            Gets a boolean indicating whether or not the cue is empty
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.FarthestNeighborList.Size">
            <summary>
            Gets the length of the current list
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.KDTree.HPoint">
            <summary>
            Hyper-Point class supporting KdTree class
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HPoint.#ctor(System.Int32)">
            <summary>
            Constructs a new HyperPoint where numDimensions indicates the size of the array for the coordinates
            </summary>
            <param name="numDimensions">The number of dimensions</param>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HPoint.#ctor(System.Double[])">
            <summary>
            Constructs a new HyperPoint where the specified array of doubles defines the internal coordinate values.
            </summary>
            <param name="inCoord">The in coordinate to use when constructing this hyper point.</param>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HPoint.SquareDistance(DotSpatial.Topology.KDTree.HPoint,DotSpatial.Topology.KDTree.HPoint)">
            <summary>
            A Static method for returning the square distance between two coordinates
            </summary>
            <param name="x">One coordinate</param>
            <param name="y">A second coordinate</param>
            <returns>A double representing the square distance</returns>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HPoint.EuclideanDistance(DotSpatial.Topology.KDTree.HPoint,DotSpatial.Topology.KDTree.HPoint)">
            <summary>
            Calculates the Euclidean distance between the two coordinates
            </summary>
            <param name="x">An ICoordinate</param>
            <param name="y">Another ICoordinate</param>
            <returns>A double representing the distance</returns>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HPoint.HyperDistance(DotSpatial.Topology.KDTree.HPoint)">
            <summary>
            Calculates the distance in comparison with any coordinate.  The coordinate with fewer dimensions
            will determine the dimensionality for the comparison.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HPoint.SquareHyperDistance(DotSpatial.Topology.KDTree.HPoint)">
            <summary>
            Calculates the square of the Euclidean distance between this point and the other point.
            </summary>
            <param name="p">Any valid implementation of ICoordinate</param>
            <returns>A double representing the distances.</returns>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.HPoint.Values">
            <summary>
            Gets or sets the actual values for this class.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.KDTree.HRect">
            <summary>
            Hyper-Rectangle class supporting KdTree class
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.KDTree.HRect.Max">
            <summary>
            Maximum values
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.KDTree.HRect.Min">
            <summary>
            Minimum values
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HRect.#ctor(System.Int32)">
            <summary>
            Constructs a new instance of a rectangle binding structure based on a specified number of dimensions
            </summary>
            <param name="numDimensions">An integer representing the number of dimensions.  For X, Y coordinates, this should be 2.</param>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HRect.#ctor(DotSpatial.Topology.KDTree.HPoint,DotSpatial.Topology.KDTree.HPoint)">
            <summary>
            Creates a new bounding rectangle based on the two coordinates specified.  It is assumed that
            the vmin and vmax coordinates have already been correctly calculated.
            </summary>
            <param name="vmin"></param>
            <param name="vmax"></param>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HRect.Clone">
            <summary>
            Creates a duplicate of this object
            </summary>
            <returns>An object duplicate of this object</returns>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HRect.Copy">
            <summary>
            Creates a duplicate of this bounding box using the existing minimum and maximum.
            </summary>
            <returns>An HRect duplicate of this object</returns>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HRect.Closest(DotSpatial.Topology.KDTree.HPoint)">
            <summary>
            Calculates the closest point on the hyper-extent to the specified point.
            from Moore's eqn. 6.6
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HRect.Farthest(DotSpatial.Topology.KDTree.HPoint)">
            <summary>
            This method calculates the furthest point on the rectangle
            from the specified point.  This is to determine if it is
            possible for any of the members of the closer rectangle
            to be positioned further away from the test point than
            the points in the hyper-extent that is further from the point.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HRect.InfiniteHRect(System.Int32)">
            <summary>
            Calculates a new HRect object that has a nearly infinite bounds.
            </summary>
            <param name="d">THe number of dimensions to use</param>
            <returns>A new HRect where the minimum is negative infinity, and the maximum is positive infinity</returns>
            <remarks>Used in initial conditions of KdTree.nearest()</remarks>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HRect.Intersection(DotSpatial.Topology.KDTree.HRect)">
            <summary>
            If the specified HRect does not intersect this HRect, this returns null.  Otherwise,
            this will return a smaller rectangular region that represents the intersection
            of the two bounding regions.
            </summary>
            <param name="region">Another HRect object to intersect with this one.</param>
            <returns>The HRect that represents the intersection area for the two bounding boxes.</returns>
            <remarks>currently unused</remarks>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.HRect.ToString">
            <summary>
            Creates a string that represents this bounding box
            </summary>
            <returns>A String</returns>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.HRect.HyperVolume">
            <summary>
            Gets the current hyper-volume.  For 1D, this is Length.  For 2D this is Area.  For 3D this is Volume.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.HRect.Minimum">
            <summary>
            Gets or sets the minimum coordinate (containing the smaller value) in all dimensions.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.HRect.Maximum">
            <summary>
            Gets or sets the maximum coordinate
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.HRect.NumOrdinates">
            <summary>
            Gets the number of ordinates for this rectangular structure (based on the minimum HPoint)
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.KDTree.KdNode">
            <summary>
            K-D Tree node class
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdNode.#ctor(DotSpatial.Topology.KDTree.HPoint,System.Object)">
            <summary>
            Constructs a new instance of the KDNode.
            </summary>
            <param name="key">A Hyper Point representing the key to use for storing this value</param>
            <param name="value">A valid object value to use for copying this.</param>
            <remarks>The constructor is used only by class; other methods are static</remarks>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdNode.ToString(System.Int32)">
            <summary>
            Creates a string representation of this node
            </summary>
            <param name="depth">The depth of child nodes to search when creating the string.</param>
            <returns>A string representation of this node.</returns>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdNode.Insert(DotSpatial.Topology.KDTree.HPoint,System.Object,DotSpatial.Topology.KDTree.KdNode,System.Int32,System.Int32)">
            <summary>
            Inserts a
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="t"></param>
            <param name="lev"></param>
            <param name="k"></param>
            <returns></returns>
            <remarks> Method ins translated from 352.ins.c of Gonnet and Baeza-Yates</remarks>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdNode.Search(DotSpatial.Topology.KDTree.HPoint,DotSpatial.Topology.KDTree.KdNode,System.Int32)">
            <summary>
            Searches for a specific value
            </summary>
            <param name="key"></param>
            <param name="t"></param>
            <param name="k"></param>
            <returns></returns>
            <remarks>Method srch translated from 352.srch.c of Gonnet and Baeza-Yates</remarks>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdNode.SearchRange(DotSpatial.Topology.KDTree.HPoint,DotSpatial.Topology.KDTree.HPoint,DotSpatial.Topology.KDTree.KdNode,System.Int32,System.Int32,System.Collections.Generic.List{DotSpatial.Topology.KDTree.KdNode})">
            <summary>
            Searches for values in a range
            </summary>
            <param name="lowk"></param>
            <param name="uppk"></param>
            <param name="t"></param>
            <param name="lev"></param>
            <param name="k"></param>
            <param name="v"></param>
            <remarks>Method rsearch translated from 352.range.c of Gonnet and Baeza-Yates</remarks>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdNode.Nnbr(DotSpatial.Topology.KDTree.KdNode,DotSpatial.Topology.KDTree.HPoint,DotSpatial.Topology.KDTree.HRect,System.Double,System.Int32,System.Int32,DotSpatial.Topology.KDTree.NearestNeighborList)">
            <summary>
            Method Nearest Neighbor from Andrew Moore's thesis. Numbered
            comments are direct quotes from there. Step "SDL" is added to
            make the algorithm work correctly.  NearestNeighborList solution
            courtesy of Bjoern Heckel.
            </summary>
            <param name="kd"></param>
            <param name="target"></param>
            <param name="hr"></param>
            <param name="maxDistSqd"></param>
            <param name="lev"></param>
            <param name="k"></param>
            <param name="nnl"></param>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdNode.FarthestNeighbor(DotSpatial.Topology.KDTree.KdNode,DotSpatial.Topology.KDTree.HPoint,DotSpatial.Topology.KDTree.HRect,System.Double,System.Int32,System.Int32,DotSpatial.Topology.KDTree.FarthestNeighborList)">
            <summary>
            This method was written by Ted Dunsford by restructuring the nearest neighbor
            algorithm presented by Andrew and Bjoern
            </summary>
            <param name="kd">Since this is recursive, this represents the current node</param>
            <param name="target">The target is the HPoint that we are trying to calculate the farthest distance from</param>
            <param name="hr">In this case, the hr is the hyper rectangle bounding the region that must contain the furthest point.</param>
            <param name="maxDistSqd">The maximum distance that we have calculated thus far, and will therefore be testing against.</param>
            <param name="lev">The integer based level of that we have recursed to in the tree</param>
            <param name="k">The dimensionality of the kd tree</param>
            <param name="fnl">A list to contain the output, prioritized by distance</param>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.KdNode.IsDeleted">
            <summary>
            Gets or sets whether this node has been _isDeleted
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.KDTree.KdTree">
             <summary>
             This is an adaptation of the Java KdTree library implemented by Levy
             and Heckel. This simplified version is written by Marco A. Alvarez
            
             KdTree is a class supporting KD-tree insertion, deletion, equality
             search, range search, and nearest neighbor(s) using double-precision
             floating-point keys.  Splitting dimension is chosen naively, by
             depth modulo K.  Semantics are as follows:
            
              Two different keys containing identical numbers should retrieve the
                  same value from a given KD-tree.  Therefore keys are cloned when a
                  node is inserted.
            
              As with Hashtables, values inserted into a KD-tree are <I>not</I>
                  cloned.  Modifying a value between insertion and retrieval will
                  therefore modify the value stored in the tree.
            
            
             @author Simon Levy, Bjoern Heckel
             Translation by Marco A. Alvarez
             Adapted by Ted Dunsford to better suite the dot net framework by
             changing comments to work in intellisense and extending some of the
             basic objects to work more tightly with MapWindow.
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdTree.#ctor(System.Int32)">
            <summary>
            Creates a new tree with the specified number of dimensions.
            </summary>
            <param name="k">An integer value specifying how many ordinates each key should have.</param>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdTree.Insert(System.Double[],System.Object)">
            <summary>
            Insert a node into the KD-tree.
            </summary>
            <param name="key">The array of double valued keys marking the position to insert this object into the tree</param>
            <param name="value">The object value to insert into the tree</param>
            <exception cref="T:DotSpatial.Topology.KDTree.KeySizeException"> if key.length mismatches the dimension of the tree (K)</exception>
            <exception cref="T:DotSpatial.Topology.KDTree.KeyDuplicateException"> if the key already exists in the tree</exception>
            <remarks>
            Uses algorithm translated from 352.ins.c of
              @Book{GonnetBaezaYates1991,
              author =    {G.H. Gonnet and R. Baeza-Yates},
              title =     {Handbook of Algorithms and Data Structures},
              publisher = {Addison-Wesley},
              year =      {1991}
            </remarks>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdTree.Search(System.Double[])">
            <summary>
            Find the KD-tree node whose key is identical to the specified key.
            This uses the algorithm translated from 352.srch.c of Connet and Baeza-Yates.
            </summary>
            <param name="key">The key identifying the node to search for</param>
            <returns>An object that is the node with a matching key, or null if no key was found.</returns>
            <exception cref="T:DotSpatial.Topology.KDTree.KeySizeException"> if key.length mismatches the dimension of the tree (K)</exception>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdTree.Delete(System.Double[])">
            <summary>
            Deletes a node from the KD-tree.  Instead of actually deleting the node and
            rebuilding the tree, it marks the node as deleted.  Hence, it is up to the
            caller to rebuild the tree as needed for efficiency.
            </summary>
            <param name="key">The key to use to identify the node to delete</param>
            <exception cref="T:DotSpatial.Topology.KDTree.KeySizeException"> if key.length mismatches the dimension of the tree (K)</exception>
            <exception cref="T:DotSpatial.Topology.KDTree.KeyMissingException"> if the key was not found in the tree</exception>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdTree.Nearest(System.Double[])">
            <summary>
            Find KD-tree node whose key is nearest neighbor to key.
            Implements the Nearest Neighbor algorithm (Table 6.4) of
            </summary>
            <param name="key">key for KD-tree node</param>
            <returns>object at node nearest to key, or null on failure</returns>
            <exception cref="T:DotSpatial.Topology.KDTree.KeySizeException"> if key.length mismatches the dimensions of the tree (K)</exception>
            <remarks>
             @techreport{AndrewMooreNearestNeighbor,
               author  = {Andrew Moore},
               title   = {An introductory tutorial on kd-trees},
               institution = {Robotics Institute, Carnegie Mellon University},
               year    = {1991},
               number  = {Technical Report No. 209, Computer Laboratory,
                          University of Cambridge},
               address = {Pittsburgh, PA}
            </remarks>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdTree.Nearest(System.Double[],System.Int32)">
            <summary>
            Find KD-tree nodes whose keys are <I>n</I> nearest neighbors to
            key. Uses algorithm above.  Neighbors are returned in ascending
            order of distance to key.
            </summary>
            <param name="key">key for KD-tree node</param>
            <param name="numNeighbors">The Integer showing how many neighbors to find</param>
            <returns>An array of objects at the node nearest to the key</returns>
            <exception cref="T:DotSpatial.Topology.KDTree.KeySizeException">Mismatch if key length doesn't match the dimension for the tree</exception>
            <exception cref="T:DotSpatial.Topology.KDTree.NeighborsOutOfRangeException">if <I>n</I> is negative or exceeds tree size </exception>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdTree.Farthest(System.Double[])">
            <summary>
            Reverses the conventional nearest neighbor in order to obtain the furthest neighbor instead.
            </summary>
            <param name="key">The key for the KD-tree node</param>
            <returns>The object that corresponds to the furthest object</returns>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdTree.Farthest(System.Double[],System.Int32)">
            <summary>
            Find KD-tree nodes whose keys are <I>n</I> farthest neighbors from
            key.  Neighbors are returned in descending order of distance to key.
            </summary>
            <param name="key">key for KD-tree node</param>
            <param name="numNeighbors">The Integer showing how many neighbors to find</param>
            <returns>An array of objects at the node nearest to the key</returns>
            <exception cref="T:DotSpatial.Topology.KDTree.KeySizeException">Mismatch if key length doesn't match the dimension for the tree</exception>
            <exception cref="T:DotSpatial.Topology.KDTree.NeighborsOutOfRangeException">if <I>n</I> is negative or exceeds tree size </exception>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdTree.SearchRange(System.Double[],System.Double[])">
            <summary>
            Search a range in the KD-tree.
            </summary>
            <param name="lowKey">The lower bound in all ordinates for keys</param>
            <param name="highKey">Teh upper bound in all ordinates for keys</param>
            <returns>An array of objects whose keys fall in range [lowk, uppk]</returns>
            <remarks> Range search in a KD-tree.  Uses algorithm translated from 352.range.c of Gonnet and Baeza-Yates.</remarks>
            <exception cref="T:DotSpatial.Topology.KDTree.KeySizeException">Mismatch of the specified parameters compared with the tree or each other.</exception>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KdTree.ToString">
            <summary>
            Converts the value to a string
            </summary>
            <returns>A string</returns>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.KdTree.Count">
            <summary>
            Gets the number of members in this tree.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.KdTree.K">
            <summary>
            Gets the actual number of dimensions for this tree.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.KDTree.KeyDuplicateException">
             <summary>
             KeyDuplicateException is thrown when the <TT>KdTree.insert</TT> method
             is invoked on a key already in the KdTree.
            
             @author Simon Levy
             Translation by Marco A. Alvarez
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KeyDuplicateException.#ctor">
            <summary>
            KeyDuplicateException
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.KDTree.KeyMissingException">
             <summary>
             Key-size mismatch exception supporting KdTree class
            
             @author Simon Levy
             Translation by Marco A. Alvarez
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KeyMissingException.#ctor">
            <summary>
            KeyMissing Exception
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.KDTree.KeySizeException">
             <summary>
             KeySizeException is thrown when a KdTree method is invoked on a
             key whose size (array length) mismatches the one used in the that
             KdTree's constructor.
            
             @author Simon Levy
             Translation by Marco A. Alvarez
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.KeySizeException.#ctor">
            <summary>
            KeySizeException
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.KDTree.NearestNeighborList">
            <summary>
            Bjoern Heckel's solution to the KD-Tree n-nearest-neighbor problem
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.KDTree.NearestNeighborList.REMOVE_HIGHEST">
            <summary>
            Indicates whether removal should occur from the highest value or lowest value
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.KDTree.NearestNeighborList.REMOVE_LOWEST">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.NearestNeighborList.#ctor(System.Int32)">
            <summary>
            Creates a new NearestNeighborList
            </summary>
            <param name="capacity">An integer indicating the maximum size for the cue</param>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.NearestNeighborList.Insert(System.Object,System.Double)">
            <summary>
            Inserts an item with a given priority
            </summary>
            <param name="item"></param>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.NearestNeighborList.RemoveHighest">
            <summary>
            Removes the highest member from the cue and returns that object.
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.NearestNeighborList.MaxPriority">
            <summary>
            Gets the maximum priority
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.NearestNeighborList.IsCapacityReached">
            <summary>
            Gets whether or not the length fo the cue has reached the capacity
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.NearestNeighborList.Highest">
            <summary>
            Gets the highest object in the nearest neighbor list
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.NearestNeighborList.IsEmpty">
            <summary>
            Gets a boolean indicating whether or not the cue is empty
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.KDTree.NearestNeighborList.Size">
            <summary>
            Gets the length of the current list
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.KDTree.NeighborsOutOfRangeException">
            <summary>
            NeighborsOutOfRangeException
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.NeighborsOutOfRangeException.#ctor">
            <summary>
            Creates a new NeighborsOutOfRangeException
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.KDTree.PriorityQueue">
             <summary>
             This class implements a PriorityQueue. This class
             is implemented in such a way that objects are added using an
             add function. The add function takes
             two parameters an object and a long.
            
             The object represents an item in the queue, the long indicates
             its priority in the queue. The remove function in this class
             returns the object first in the queue and that object is removed
             from the queue permanently.
            
             @author Simon Levy
             Translation by Marco A. Alvarez
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.KDTree.PriorityQueue._maxPriority">
            The maximum priority possible in this priority queue.
        </member>
        <member name="F:DotSpatial.Topology.KDTree.PriorityQueue._count">
            Holds the number of elements currently in the queue.
        </member>
        <member name="F:DotSpatial.Topology.KDTree.PriorityQueue._data">
            This contains the list of objects in the queue.
        </member>
        <member name="F:DotSpatial.Topology.KDTree.PriorityQueue._value">
            This contains the list of prioritys in the queue.
        </member>
        <member name="M:DotSpatial.Topology.KDTree.PriorityQueue.#ctor">
            Creates a new <code>PriorityQueue</code> object. The
            <code>PriorityQueue</code> object allows objects to be
            entered into the queue and to leave in the order of
            priority i.e the highest priority get's to leave first.
        </member>
        <member name="M:DotSpatial.Topology.KDTree.PriorityQueue.#ctor(System.Int32)">
             Creates a new <code>PriorityQueue</code> object. The
             <code>PriorityQueue</code> object allows objects to
             be entered into the queue an to leave in the order of
             priority i.e the highest priority get's to leave first.
            
             @param capacity the initial capacity of the queue before
             a resize
        </member>
        <member name="M:DotSpatial.Topology.KDTree.PriorityQueue.#ctor(System.Int32,System.Double)">
             Creates a new <code>PriorityQueue</code> object. The
             <code>PriorityQueue</code> object allows objects to
             be entered into the queue an to leave in the order of
             priority i.e the highest priority get's to leave first.
            
             @param capacity the initial capacity of the queue before
             a resize
             @param maxPriority is the maximum possible priority for
             an object
        </member>
        <member name="M:DotSpatial.Topology.KDTree.PriorityQueue.Init(System.Int32)">
             This is an initializer for the object. It basically initializes
             an array of long called value to represent the prioritys of
             the objects, it also creates an array of objects to be used
             in parallel with the array of longs, to represent the objects
             entered, these can be used to sequence the data.
            
             @param size the initial capacity of the queue, it can be
             resized
        </member>
        <member name="M:DotSpatial.Topology.KDTree.PriorityQueue.Add(System.Object,System.Double)">
             This function adds the given object into the <code>PriorityQueue</code>,
             its priority is the long priority. The way in which priority can be
             associated with the elements of the queue is by keeping the priority
             and the elements array entrys parallel.
            
             @param element is the object that is to be entered into this
             <code>PriorityQueue</code>
             @param priority this is the priority that the object holds in the
             <code>PriorityQueue</code>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.PriorityQueue.Remove">
             Remove is a function to remove the element in the queue with the
             maximum priority. Once the element is removed then it can never be
             recovered from the queue with further calls. The lowest priority
             object will leave last.
            
             @return the object with the highest priority or if it's empty
             null
        </member>
        <member name="M:DotSpatial.Topology.KDTree.PriorityQueue.BubbleDown(System.Int32)">
             Bubble down is used to put the element at subscript 'pos' into
             it's rightful place in the heap (i.e heap is another name
             for <code>PriorityQueue</code>). If the priority of an element
             at subscript 'pos' is less than it's children then it must
             be put under one of these children, i.e the ones with the
             maximum priority must come first.
            
             @param pos is the position within the arrays of the element
             and priority
        </member>
        <member name="M:DotSpatial.Topology.KDTree.PriorityQueue.BubbleUp(System.Int32)">
             Bubble up is used to place an element relatively low in the
             queue to it's rightful place higher in the queue, but only
             if it's priority allows it to do so, similar to bubbleDown
             only in the other direction this swaps out its parents.
            
             @param pos the position in the arrays of the object
             to be bubbled up
        </member>
        <member name="M:DotSpatial.Topology.KDTree.PriorityQueue.ExpandCapacity">
            This ensures that there is enough space to keep adding elements
            to the priority queue. It is however advised to make the capacity
            of the queue large enough so that this will not be used as it is
            an expensive method. This will copy across from 0 as 'off' equals
            0 is contains some important data.
        </member>
        <member name="M:DotSpatial.Topology.KDTree.PriorityQueue.Clear">
            This method will empty the queue. This also helps garbage
            collection by releasing any reference it has to the elements
            in the queue. This starts from offset 1 as off equals 0
            for the elements array.
        </member>
        <member name="M:DotSpatial.Topology.KDTree.PriorityQueue.Length">
             The number of elements in the queue. The length
             indicates the number of elements that are currently
             in the queue.
            
             @return the number of elements in the queue
        </member>
        <member name="T:DotSpatial.Topology.Index.Quadtree.DoubleBits">
            <summary>
            DoubleBits manipulates Double numbers
            by using bit manipulation and bit-field extraction.
            For some operations (such as determining the exponent)
            this is more accurate than using mathematical operations
            (which suffer from round-off error).
            The algorithms and constants in this class
            apply only to IEEE-754 double-precision floating point format.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Index.Quadtree.DoubleBits.EXPONENT_BIAS">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.DoubleBits.#ctor(System.Double)">
             <summary>
            
             </summary>
             <param name="x"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.DoubleBits.PowerOf2(System.Int32)">
             <summary>
            
             </summary>
             <param name="exp"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.DoubleBits.GetExponent(System.Double)">
             <summary>
            
             </summary>
             <param name="d"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.DoubleBits.TruncateToPowerOfTwo(System.Double)">
             <summary>
            
             </summary>
             <param name="d"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.DoubleBits.ToBinaryString(System.Double)">
             <summary>
            
             </summary>
             <param name="d"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.DoubleBits.MaximumCommonMantissa(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="d1"></param>
             <param name="d2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.DoubleBits.ZeroLowerBits(System.Int32)">
             <summary>
            
             </summary>
             <param name="nBits"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.DoubleBits.GetBit(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.DoubleBits.NumCommonMantissaBits(DotSpatial.Topology.Index.Quadtree.DoubleBits)">
            <summary>
            This computes the number of common most-significant bits in the mantissa.
            It does not count the hidden bit, which is always 1.
            It does not determine whether the numbers have the same exponent - if they do
            not, the value computed by this function is meaningless.
            </summary>
            <param name="db"></param>
            <returns> The number of common most-significant mantissa bits.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.DoubleBits.ToString">
            <summary>
            A representation of the Double bits formatted for easy readability.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.DoubleBits.Double">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.DoubleBits.BiasedExponent">
            <summary>
            Determines the exponent for the number.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.DoubleBits.Exponent">
            <summary>
            Determines the exponent for the number.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Quadtree.IntervalSize">
            <summary>
            Provides a test for whether an interval is
            so small it should be considered as zero for the purposes of
            inserting it into a binary tree.
            The reason this check is necessary is that round-off error can
            cause the algorithm used to subdivide an interval to fail, by
            computing a midpoint value which does not lie strictly between the
            endpoints.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Index.Quadtree.IntervalSize.MIN_BINARY_EXPONENT">
            <summary>
            This value is chosen to be a few powers of 2 less than the
            number of bits available in the double representation (i.e. 53).
            This should allow enough extra precision for simple computations to be correct,
            at least for comparison purposes.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.IntervalSize.IsZeroWidth(System.Double,System.Double)">
            <summary>
            Computes whether the interval [min, max] is effectively zero width.
            I.e. the width of the interval is so much less than the
            location of the interval that the midpoint of the interval cannot be
            represented precisely.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Quadtree.Key">
            <summary>
            A Key is a unique identifier for a node in a quadtree.
            It contains a lower-left point and a level number. The level number
            is the power of two for the size of the node envelope.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Key.#ctor(DotSpatial.Topology.IEnvelope)">
             <summary>
            
             </summary>
             <param name="itemEnv"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Key.ComputeQuadLevel(DotSpatial.Topology.IEnvelope)">
             <summary>
            
             </summary>
             <param name="env"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Key.ComputeKey(DotSpatial.Topology.IEnvelope)">
            <summary>
            Return a square envelope containing the argument envelope,
            whose extent is a power of two and which is based at a power of 2.
            </summary>
            <param name="itemEnv"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Key.ComputeKey(System.Int32,DotSpatial.Topology.IEnvelope)">
             <summary>
            
             </summary>
             <param name="level"></param>
             <param name="itemEnv"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.Key.Point">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.Key.Level">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.Key.Envelope">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.Key.Centre">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Quadtree.Node">
            <summary>
            Represents a node of a <c>Quadtree</c>.  Nodes contain
            items which have a spatial extent corresponding to the node's position
            in the quadtree.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Quadtree.NodeBase">
            <summary>
            The base class for nodes in a <c>Quadtree</c>.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Index.Quadtree.NodeBase._subnode">
            <summary>
            subquads are numbered as follows:
            2 | 3
            --+--
            0 | 1
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.NodeBase.Add(System.Object)">
            <summary>
            Adds a new item to this node.
            </summary>
            <param name="item">The item to add to this node</param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.NodeBase.AddAllItems(System.Collections.IList@)">
            <summary>
            Insert items in <c>this</c> into the parameter!
            </summary>
            <param name="resultItems">IList for adding items.</param>
            <returns>Parameter IList with <c>this</c> items.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.NodeBase.AddAllItemsFromOverlapping(DotSpatial.Topology.IEnvelope,System.Collections.IList@)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <param name="resultItems"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.NodeBase.Remove(DotSpatial.Topology.IEnvelope,System.Object)">
            <summary>
            Removes a single item from this subtree.
            </summary>
            <param name="itemEnv">The envelope containing the item.</param>
            <param name="item">The item to remove.</param>
            <returns><c>true</c> if the item was found and removed.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.NodeBase.Visit(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Index.IItemVisitor)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <param name="visitor"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.NodeBase.IsSearchMatch(DotSpatial.Topology.IEnvelope)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.NodeBase.VisitItems(DotSpatial.Topology.Index.IItemVisitor)">
             <summary>
            
             </summary>
             <param name="visitor"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.NodeBase.GetSubnodeIndex(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Coordinate)">
            <summary>
            Returns the index of the subquad that wholly contains the given envelope.
            If none does, returns -1.
            </summary>
            <param name="env"></param>
            <param name="centre"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.NodeBase.Count">
            <summary>
            Because more than one item can be stored in each node, this returns the total count of
            items contained by this node and its child nodes.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.NodeBase.Depth">
            <summary>
            Gets an integer representing how deem the deepest child of this node extends.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.NodeBase.Nodes">
            <summary>
            Gets or sets the array of 4 nodes represnting the spatial quadrants being used as children
            2 | 3
            --+--
            0 | 1
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.NodeBase.HasChildren">
            <summary>
            Gets a boolean indicating whehter or not this node links to any nodes below it in the tree
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.NodeBase.HasItems">
            <summary>
            Each node can store multiple items.  This tests whether or not there are items in this node.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.NodeBase.IsPrunable">
            <summary>
            If this node has no childern or items, then it can be pruned
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.NodeBase.IsEmpty">
            <summary>
            If this node has an item, or if any of the children of this node has an item, then this is false.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.NodeBase.Items">
            <summary>
            Gets or sets the list of items that are stored in this node
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.NodeBase.NodeCount">
            <summary>
            Gets an integer representing this node and the count of all of the children in its subnodes
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Node.#ctor(DotSpatial.Topology.IEnvelope,System.Int32)">
             <summary>
            
             </summary>
             <param name="env"></param>
             <param name="level"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Node.CreateNode(DotSpatial.Topology.IEnvelope)">
             <summary>
            
             </summary>
             <param name="env"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Node.CreateExpanded(DotSpatial.Topology.Index.Quadtree.Node,DotSpatial.Topology.IEnvelope)">
             <summary>
            
             </summary>
             <param name="node"></param>
             <param name="addEnv"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Node.IsSearchMatch(DotSpatial.Topology.IEnvelope)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Node.GetNode(DotSpatial.Topology.IEnvelope)">
            <summary>
            Returns the subquad containing the envelope.
            Creates the subquad if
            it does not already exist.
            </summary>
            <param name="searchEnv"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Node.Find(DotSpatial.Topology.IEnvelope)">
            <summary>
            Returns the smallest <i>existing</i>
            node containing the envelope.
            </summary>
            <param name="searchEnv"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Node.InsertNode(DotSpatial.Topology.Index.Quadtree.Node)">
             <summary>
            
             </summary>
             <param name="node"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Node.GetSubnode(System.Int32)">
            <summary>
            Get the subquad for the index.
            If it doesn't exist, create it.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Node.CreateSubnode(System.Int32)">
             <summary>
            
             </summary>
             <param name="index"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.Node.Envelope">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Quadtree.Quadtree">
            <summary>
            A Quadtree is a spatial index structure for efficient querying
            of 2D rectangles.  If other kinds of spatial objects
            need to be indexed they can be represented by their
            envelopes
            The quadtree structure is used to provide a primary filter
            for range rectangle queries.  The Query() method returns a list of
            all objects which may intersect the query rectangle.  Notice that
            it may return objects which do not in fact intersect.
            A secondary filter is required to test for exact intersection.
            Of course, this secondary filter may consist of other tests besides
            intersection, such as testing other kinds of spatial relationships.
            This implementation does not require specifying the extent of the inserted
            items beforehand.  It will automatically expand to accomodate any extent
            of dataset.
            This data structure is also known as an <c>MX-CIF quadtree</c>
            following the usage of Samet and others.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Index.Quadtree.Quadtree.Root">
            <summary>
            Root of Quadtree
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Index.Quadtree.Quadtree._minExtent">
            <summary>
            minExtent is the minimum envelope extent of all items
            inserted into the tree so far. It is used as a heuristic value
            to construct non-zero envelopes for features with zero X and/or Y extent.
            Start with a non-zero extent, in case the first feature inserted has
            a zero extent in both directions.  This value may be non-optimal, but
            only one feature will be inserted with this value.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Quadtree.#ctor">
            <summary>
            Constructs a Quadtree with zero items.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Quadtree.Insert(DotSpatial.Topology.IEnvelope,System.Object)">
             <summary>
            
             </summary>
             <param name="itemEnv"></param>
             <param name="item"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Quadtree.Remove(DotSpatial.Topology.IEnvelope,System.Object)">
            <summary>
            Removes a single item from the tree.
            </summary>
            <param name="itemEnv">The Envelope of the item to remove.</param>
            <param name="item">The item to remove.</param>
            <returns><c>true</c> if the item was found.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Quadtree.Query(DotSpatial.Topology.IEnvelope)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Quadtree.Query(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Index.IItemVisitor)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <param name="visitor"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Quadtree.EnsureExtent(DotSpatial.Topology.IEnvelope,System.Double)">
            <summary>
            Ensure that the envelope for the inserted item has non-zero extents.
            Use the current minExtent to pad the envelope, if necessary.
            </summary>
            <param name="itemEnv"></param>
            <param name="minExtent"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Quadtree.QueryAll">
            <summary>
            Return a list of all items in the Quadtree.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Quadtree.CollectStats(DotSpatial.Topology.IRectangle)">
             <summary>
            
             </summary>
             <param name="itemEnv"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.Quadtree.Depth">
            <summary>
            Returns the number of levels in the tree.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Quadtree.Quadtree.Count">
            <summary>
            Returns the number of items in the tree.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Quadtree.Root">
            <summary>
            QuadRoot is the root of a single Quadtree.
            It is centred at the origin,
            and does not have a defined extent.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Root.Insert(DotSpatial.Topology.IEnvelope,System.Object)">
            <summary>
            Insert an item into the quadtree this is the root of.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Root.InsertContained(DotSpatial.Topology.Index.Quadtree.Node,DotSpatial.Topology.IEnvelope,System.Object)">
            <summary>
            Insert an item which is known to be contained in the tree rooted at
            the given QuadNode root.  Lower levels of the tree will be created
            if necessary to hold the item.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Quadtree.Root.IsSearchMatch(DotSpatial.Topology.IEnvelope)">
             <summary>
            
             </summary>
             <param name="searchEnv"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.AbstractNode">
            <summary>
            A node of the STR tree. The children of this node are either more nodes
            (AbstractNodes) or real data (ItemBoundables). If this node contains real data
            (rather than nodes), then we say that this node is a "leaf node".
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.IBoundable">
            <summary>
            A spatial object in an AbstractSTRtree.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.IBoundable.Bounds">
            <summary>
            Returns a representation of space that encloses this Boundable, preferably
            not much bigger than this Boundable's boundary yet fast to test for intersection
            with the bounds of other Boundables. The class of object returned depends
            on the subclass of AbstractSTRtree.
            </summary>
            <returns>
            An Envelope (for STRtrees), an Interval (for SIRtrees), or other object
            (for other subclasses of AbstractSTRtree).
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractNode.#ctor(System.Int32)">
            <summary>
            Constructs an AbstractNode at the given level in the tree
            </summary>
            <param name="level">
            0 if this node is a leaf, 1 if a parent of a leaf, and so on; the
            root node will have the highest level.
            </param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractNode.ComputeBounds">
            <summary>
            Returns a representation of space that encloses this Boundable,
            preferably not much bigger than this Boundable's boundary yet fast to
            test for intersection with the bounds of other Boundables. The class of
            object returned depends on the subclass of AbstractSTRtree.
            </summary>
            <returns>
            An Envelope (for STRtrees), an Interval (for SIRtrees), or other
            object (for other subclasses of AbstractSTRtree).
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractNode.AddChildBoundable(DotSpatial.Topology.Index.Strtree.IBoundable)">
            <summary>
            Adds either an AbstractNode, or if this is a leaf node, a data object
            (wrapped in an ItemBoundable).
            </summary>
            <param name="childBoundable"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.AbstractNode.ChildBoundables">
            <summary>
            Returns either child AbstractNodes, or if this is a leaf node, real data (wrapped
            in ItemBoundables).
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.AbstractNode.Level">
            <summary>
            Returns 0 if this node is a leaf, 1 if a parent of a leaf, and so on; the
            root node will have the highest level.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.AbstractNode.Bounds">
            <summary>
            Returns object fromComputeBounds()
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.AbstractStRtree">
            <summary>
            Base class for STRtree and SIRtree. STR-packed R-trees are described in:
            P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
            Application To GIS. Morgan Kaufmann, San Francisco, 2002.
            <para>
            This implementation is based on Boundables rather than just AbstractNodes,
            because the STR algorithm operates on both nodes and
            data, both of which are treated here as Boundables.
            </para>
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.#ctor(System.Int32)">
            <summary>
            Constructs an AbstractSTRtree with the specified maximum number of child
            nodes that a node may have.
            </summary>
            <param name="nodeCapacity"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.Build">
            <summary>
            Creates parent nodes, grandparent nodes, and so forth up to the root
            node, for the data that has been inserted into the tree. Can only be
            called once, and thus can be called only after all of the data has been
            inserted into the tree.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.CreateNode(System.Int32)">
             <summary>
            
             </summary>
             <param name="level"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.CreateParentBoundables(System.Collections.IList,System.Int32)">
            <summary>
            Sorts the childBoundables then divides them into groups of size M, where
            M is the node capacity.
            </summary>
            <param name="childBoundables"></param>
            <param name="newLevel"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.LastNode(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="nodes"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.CompareDoubles(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="a"></param>
             <param name="b"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.CreateHigherLevels(System.Collections.IList,System.Int32)">
            <summary>
            Creates the levels higher than the given level.
            </summary>
            <param name="boundablesOfALevel">The level to build on.</param>
            <param name="level">the level of the Boundables, or -1 if the boundables are item
            boundables (that is, below level 0).</param>
            <returns>The root, which may be a ParentNode or a LeafNode.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.GetSize(DotSpatial.Topology.Index.Strtree.AbstractNode)">
             <summary>
            
             </summary>
             <param name="node"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.GetDepth(DotSpatial.Topology.Index.Strtree.AbstractNode)">
             <summary>
            
             </summary>
             <param name="node"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.Insert(System.Object,System.Object)">
             <summary>
            
             </summary>
             <param name="bounds"></param>
             <param name="item"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.Query(System.Object)">
            <summary>
            Also builds the tree, if necessary.
            </summary>
            <param name="searchBounds"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.Query(System.Object,DotSpatial.Topology.Index.IItemVisitor)">
            <summary>
            Also builds the tree, if necessary.
            </summary>
            <param name="searchBounds"></param>
            <param name="visitor"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.Query(System.Object,DotSpatial.Topology.Index.Strtree.AbstractNode,System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="searchBounds"></param>
             <param name="node"></param>
             <param name="matches"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.Query(System.Object,DotSpatial.Topology.Index.Strtree.AbstractNode,DotSpatial.Topology.Index.IItemVisitor)">
             <summary>
            
             </summary>
             <param name="searchBounds"></param>
             <param name="node"></param>
             <param name="visitor"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.Remove(System.Object,System.Object)">
            <summary>
            Also builds the tree, if necessary.
            </summary>
            <param name="searchBounds"></param>
            <param name="item"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.RemoveItem(DotSpatial.Topology.Index.Strtree.AbstractNode,System.Object)">
             <summary>
            
             </summary>
             <param name="node"></param>
             <param name="item"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.Remove(System.Object,DotSpatial.Topology.Index.Strtree.AbstractNode,System.Object)">
             <summary>
            
             </summary>
             <param name="searchBounds"></param>
             <param name="node"></param>
             <param name="item"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.BoundablesAtLevel(System.Int32)">
             <summary>
            
             </summary>
             <param name="level"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.BoundablesAtLevel(System.Int32,DotSpatial.Topology.Index.Strtree.AbstractNode,System.Collections.IList@)">
             <summary>
            
             </summary>
             <param name="level">-1 to get items.</param>
             <param name="top"></param>
             <param name="boundables"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.GetComparer">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.AbstractStRtree.Root">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.AbstractStRtree.NodeCapacity">
            <summary>
            Returns the maximum number of child nodes that a node may have.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.AbstractStRtree.Count">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.AbstractStRtree.Depth">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.AbstractStRtree.IntersectsOp">
            <returns>
            A test for intersection between two bounds, necessary because subclasses
            of AbstractSTRtree have different implementations of bounds.
            </returns>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.AbstractStRtree.IIntersectsOp">
            <returns>
            A test for intersection between two bounds, necessary because subclasses
            of AbstractSTRtree have different implementations of bounds.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.AbstractStRtree.IIntersectsOp.Intersects(System.Object,System.Object)">
            <summary>
            For STRtrees, the bounds will be Envelopes;
            for SIRtrees, Intervals;
            for other subclasses of AbstractSTRtree, some other class.
            </summary>
            <param name="aBounds">The bounds of one spatial object.</param>
            <param name="bBounds">The bounds of another spatial object.</param>
            <returns>Whether the two bounds intersect.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.Interval">
            <summary>
            A contiguous portion of 1D-space. Used internally by SIRtree.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.Interval.#ctor(DotSpatial.Topology.Index.Strtree.Interval)">
             <summary>
            
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.Interval.#ctor(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="min"></param>
             <param name="max"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.Interval.ExpandToInclude(DotSpatial.Topology.Index.Strtree.Interval)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <returns><c>this</c></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.Interval.Intersects(DotSpatial.Topology.Index.Strtree.Interval)">
             <summary>
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.Interval.Equals(System.Object)">
             <summary>
            
             </summary>
             <param name="o"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.Interval.GetHashCode">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.Interval.Centre">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.ItemBoundable">
            <summary>
            Boundable wrapper for a non-Boundable spatial object. Used internally by
            AbstractSTRtree.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.ItemBoundable.#ctor(System.Object,System.Object)">
             <summary>
            
             </summary>
             <param name="bounds"></param>
             <param name="item"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.ItemBoundable.Item">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.ItemBoundable.Bounds">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.SiRtree">
            <summary>
            One-dimensional version of an STR-packed R-tree. SIR stands for
            "Sort-Interval-Recursive". STR-packed R-trees are described in:
            P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
            Application To GIS. Morgan Kaufmann, San Francisco, 2002.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.SiRtree.#ctor">
            <summary>
            Constructs an SIRtree with the default (10) node capacity.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.SiRtree.#ctor(System.Int32)">
            <summary>
            Constructs an SIRtree with the given maximum number of child nodes that
            a node may have.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.SiRtree.CreateNode(System.Int32)">
             <summary>
            
             </summary>
             <param name="level"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.SiRtree.Insert(System.Double,System.Double,System.Object)">
            <summary>
            Inserts an item having the given bounds into the tree.
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <param name="item"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.SiRtree.Query(System.Double)">
            <summary>
            Returns items whose bounds intersect the given value.
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.SiRtree.Query(System.Double,System.Double)">
            <summary>
            Returns items whose bounds intersect the given bounds.
            </summary>
            <param name="x1">Possibly equal to x2.</param>
            <param name="x2">Possibly equal to x1.</param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.SiRtree.GetComparer">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.SiRtree.IntersectsOp">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.SiRtree.AnnonymousComparerImpl">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.SiRtree.AnnonymousComparerImpl.Compare(System.Object,System.Object)">
             <summary>
            
             </summary>
             <param name="o1"></param>
             <param name="o2"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.SiRtree.AnonymousAbstractNodeImpl">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.SiRtree.AnonymousAbstractNodeImpl.#ctor(System.Int32)">
             <summary>
            
             </summary>
             <param name="nodeCapacity"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.SiRtree.AnonymousAbstractNodeImpl.ComputeBounds">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.SiRtree.AnonymousIntersectsOpImpl">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.SiRtree.AnonymousIntersectsOpImpl.Intersects(System.Object,System.Object)">
             <summary>
            
             </summary>
             <param name="aBounds"></param>
             <param name="bBounds"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.StRtree">
            <summary>
            A query-only R-tree created using the Sort-Tile-Recursive (STR) algorithm.
            For two-dimensional spatial data.
            The STR packed R-tree is simple to implement and maximizes space
            utilization; that is, as many leaves as possible are filled to capacity.
            Overlap between nodes is far less than in a basic R-tree. However, once the
            tree has been built (explicitly or on the first call to #query), items may
            not be added or removed.
            Described in: P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
            Application To GIS. Morgan Kaufmann, San Francisco, 2002.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.#ctor">
            <summary>
            Constructs an STRtree with the default (10) node capacity.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.#ctor(System.Int32)">
            <summary>
            Constructs an STRtree with the given maximum number of child nodes that
            a node may have.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.Insert(DotSpatial.Topology.IEnvelope,System.Object)">
            <summary>
            Inserts an item having the given bounds into the tree.
            </summary>
            <param name="itemEnv"></param>
            <param name="item"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.Query(DotSpatial.Topology.IEnvelope)">
            <summary>
            Returns items whose bounds intersect the given envelope.
            </summary>
            <param name="searchEnv"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.Query(DotSpatial.Topology.IEnvelope,DotSpatial.Topology.Index.IItemVisitor)">
            <summary>
            Returns items whose bounds intersect the given envelope.
            </summary>
            <param name="searchEnv"></param>
            <param name="visitor"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.Remove(DotSpatial.Topology.IEnvelope,System.Object)">
            <summary>
            Removes a single item from the tree.
            </summary>
            <param name="itemEnv">The Envelope of the item to remove.</param>
            <param name="item">The item to remove.</param>
            <returns><c>true</c> if the item was found.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.Avg(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="a"></param>
             <param name="b"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.CentreX(DotSpatial.Topology.IEnvelope)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.CentreY(DotSpatial.Topology.IEnvelope)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.CreateParentBoundables(System.Collections.IList,System.Int32)">
            <summary>
            Creates the parent level for the given child level. First, orders the items
            by the x-values of the midpoints, and groups them into vertical slices.
            For each slice, orders the items by the y-values of the midpoints, and
            group them into runs of size M (the node capacity). For each run, creates
            a new (parent) node.
            </summary>
            <param name="childBoundables"></param>
            <param name="newLevel"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.CreateParentBoundablesFromVerticalSlices(System.Collections.IList[],System.Int32)">
             <summary>
            
             </summary>
             <param name="verticalSlices"></param>
             <param name="newLevel"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.CreateParentBoundablesFromVerticalSlice(System.Collections.IList,System.Int32)">
             <summary>
            
             </summary>
             <param name="childBoundables"></param>
             <param name="newLevel"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.VerticalSlices(System.Collections.IList,System.Int32)">
             <summary>
            
             </summary>
             <param name="childBoundables">Must be sorted by the x-value of the envelope midpoints.</param>
             <param name="sliceCount"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.CreateNode(System.Int32)">
             <summary>
            
             </summary>
             <param name="level"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.GetComparer">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Index.Strtree.StRtree.IntersectsOp">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.StRtree.AnonymousAbstractNodeImpl">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.AnonymousAbstractNodeImpl.#ctor(System.Int32)">
             <summary>
            
             </summary>
             <param name="nodeCapacity"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.AnonymousAbstractNodeImpl.ComputeBounds">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.StRtree.AnonymousIntersectsOpImpl">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.AnonymousIntersectsOpImpl.Intersects(System.Object,System.Object)">
             <summary>
            
             </summary>
             <param name="aBounds"></param>
             <param name="bBounds"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.StRtree.AnonymousXComparerImpl">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.AnonymousXComparerImpl.#ctor(DotSpatial.Topology.Index.Strtree.StRtree)">
             <summary>
            
             </summary>
             <param name="container"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.AnonymousXComparerImpl.Compare(System.Object,System.Object)">
             <summary>
            
             </summary>
             <param name="o1"></param>
             <param name="o2"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Index.Strtree.StRtree.AnonymousYComparerImpl">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.AnonymousYComparerImpl.#ctor(DotSpatial.Topology.Index.Strtree.StRtree)">
             <summary>
            
             </summary>
             <param name="container"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Strtree.StRtree.AnonymousYComparerImpl.Compare(System.Object,System.Object)">
             <summary>
            
             </summary>
             <param name="o1"></param>
             <param name="o2"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Index.Sweepline.ISweepLineOverlapAction">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Sweepline.ISweepLineOverlapAction.Overlap(DotSpatial.Topology.Index.Sweepline.SweepLineInterval,DotSpatial.Topology.Index.Sweepline.SweepLineInterval)">
             <summary>
            
             </summary>
             <param name="s0"></param>
             <param name="s1"></param>
        </member>
        <member name="T:DotSpatial.Topology.Index.Sweepline.SweepLineEvent">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Sweepline.SweepLineEvent.#ctor(System.Double,DotSpatial.Topology.Index.Sweepline.SweepLineEvent,DotSpatial.Topology.Index.Sweepline.SweepLineInterval)">
             <summary>
            
             </summary>
             <param name="x"></param>
             <param name="insertEvent"></param>
             <param name="sweepInt"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Sweepline.SweepLineEvent.CompareTo(System.Object)">
            <summary>
            ProjectionEvents are ordered first by their x-value, and then by their eventType.
            It is important that Insert events are sorted before Delete events, so that
            items whose Insert and Delete events occur at the same x-value will be
            correctly handled.
            </summary>
            <param name="o"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.Sweepline.SweepLineEvent.IsInsert">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Sweepline.SweepLineEvent.IsDelete">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Sweepline.SweepLineEvent.InsertEvent">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Sweepline.SweepLineEvent.DeleteEventIndex">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Sweepline.SweepLineEvent.Interval">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Sweepline.SweepLineEvent.SweepLineEventType">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Index.Sweepline.SweepLineEvent.SweepLineEventType.Insert">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Index.Sweepline.SweepLineEvent.SweepLineEventType.Delete">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Index.Sweepline.SweepLineIndex">
            <summary>
            A sweepline implements a sorted index on a set of intervals.
            It is used to compute all overlaps between the interval in the index.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Sweepline.SweepLineIndex.Add(DotSpatial.Topology.Index.Sweepline.SweepLineInterval)">
             <summary>
            
             </summary>
             <param name="sweepInt"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Sweepline.SweepLineIndex.BuildIndex">
            <summary>
            Because Delete Events have a link to their corresponding Insert event,
            it is possible to compute exactly the range of events which must be
            compared to a given Insert event object.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Sweepline.SweepLineIndex.ComputeOverlaps(DotSpatial.Topology.Index.Sweepline.ISweepLineOverlapAction)">
             <summary>
            
             </summary>
             <param name="action"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Sweepline.SweepLineIndex.ProcessOverlaps(System.Int32,System.Int32,DotSpatial.Topology.Index.Sweepline.SweepLineInterval,DotSpatial.Topology.Index.Sweepline.ISweepLineOverlapAction)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <param name="end"></param>
             <param name="s0"></param>
             <param name="action"></param>
        </member>
        <member name="T:DotSpatial.Topology.Index.Sweepline.SweepLineInterval">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Index.Sweepline.SweepLineInterval.#ctor(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="min"></param>
             <param name="max"></param>
        </member>
        <member name="M:DotSpatial.Topology.Index.Sweepline.SweepLineInterval.#ctor(System.Double,System.Double,System.Object)">
             <summary>
            
             </summary>
             <param name="min"></param>
             <param name="max"></param>
             <param name="item"></param>
        </member>
        <member name="P:DotSpatial.Topology.Index.Sweepline.SweepLineInterval.Min">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Sweepline.SweepLineInterval.Max">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Index.Sweepline.SweepLineInterval.Item">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.KDTree.NegativeArgumentException">
            <summary>
            NegativeInvalidException
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.KDTree.NegativeArgumentException.#ctor(System.String)">
            <summary>
            This creates a new instance of an exception that occurs if a negative value was passed as an argument and this is invalid
            </summary>
            <param name="parameterName">The name of the parameter that was negative</param>
        </member>
        <member name="T:DotSpatial.Topology.Noding.INoder">
            <summary>
            Computes all intersections between segments in a set of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            Intersections found are represented as <see cref="T:DotSpatial.Topology.Noding.SegmentNode"/>s and added to the
            <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s in which they occur.
            As a final step in the noding a new set of segment strings split at the nodes may be returned.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.INoder.ComputeNodes(System.Collections.IList)">
            <summary>
            Computes the noding for a collection of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="segStrings"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.INoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            The <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Noding.IntersectionAdder">
            <summary>
            Computes the intersections between two line segments in <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s
            and adds them to each string.
            The <see cref="T:DotSpatial.Topology.Noding.ISegmentIntersector"/> is passed to a <see cref="T:DotSpatial.Topology.Noding.INoder"/>.
            The <see cref="M:DotSpatial.Topology.Noding.SegmentString.AddIntersections(DotSpatial.Topology.Algorithm.LineIntersector,System.Int32)"/> method is called whenever the <see cref="T:DotSpatial.Topology.Noding.INoder"/>
            detects that two <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s might intersect.
            This class is an example of the Strategy pattern.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.ISegmentIntersector">
            <summary>
            Computes the intersections between two line segments in <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s
            and adds them to each string.
            The <see cref="T:DotSpatial.Topology.Noding.ISegmentIntersector"/> is passed to a <see cref="T:DotSpatial.Topology.Noding.INoder"/>.
            The <see cref="M:DotSpatial.Topology.Noding.SegmentString.AddIntersections(DotSpatial.Topology.Algorithm.LineIntersector,System.Int32)"/>  method is called whenever the <see cref="T:DotSpatial.Topology.Noding.INoder"/>
            detects that two <see cref="T:DotSpatial.Topology.Noding.SegmentString"/> s might intersect.
            This class is an example of the Strategy pattern.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.ISegmentIntersector.ProcessIntersections(DotSpatial.Topology.Noding.SegmentString,System.Int32,DotSpatial.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:DotSpatial.Topology.Noding.ISegmentIntersector"/> interface to process
            intersections for two segments of the <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s being intersected.
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="F:DotSpatial.Topology.Noding.IntersectionAdder._li">
            These variables keep track of what types of intersections were
            found during ALL edges that have been intersected.
        </member>
        <member name="F:DotSpatial.Topology.Noding.IntersectionAdder.NumInteriorIntersections">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.IntersectionAdder.#ctor(DotSpatial.Topology.Algorithm.LineIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.IntersectionAdder"/> class.
            </summary>
            <param name="li"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.IntersectionAdder.ProcessIntersections(DotSpatial.Topology.Noding.SegmentString,System.Int32,DotSpatial.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:DotSpatial.Topology.Noding.ISegmentIntersector"/> class to process
            intersections for two segments of the <see cref="T:DotSpatial.Topology.Noding.SegmentString"/> being intersected.
            Notice that some clients (such as <see cref="T:DotSpatial.Topology.Index.Chain.MonotoneChain"/>s) may optimize away
            this call for segment pairs which they have determined do not intersect
            (e.g. by an disjoint envelope test).
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.IntersectionAdder.IsAdjacentSegments(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="i1"></param>
             <param name="i2"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.IntersectionAdder.IsTrivialIntersection(DotSpatial.Topology.Noding.SegmentString,System.Int32,DotSpatial.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            A trivial intersection is an apparent self-intersection which in fact
            is simply the point shared by adjacent line segments.
            Notice that closed edges require a special check for the point shared by the beginning and end segments.
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Noding.IntersectionAdder.LineIntersector">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Noding.IntersectionAdder.HasIntersection">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Noding.IntersectionAdder.HasProperIntersection">
            <summary>
            A proper intersection is an intersection which is interior to at least two
            line segments.  Notice that a proper intersection is not necessarily
            in the interior of the entire <see cref="T:DotSpatial.Topology.Geometry"/>, since another edge may have
            an endpoint equal to the intersection, which according to SFS semantics
            can result in the point being on the Boundary of the <see cref="T:DotSpatial.Topology.Geometry"/>.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Noding.IntersectionAdder.HasProperInteriorIntersection">
            <summary>
            A proper interior intersection is a proper intersection which is not
            contained in the set of boundary nodes set for this <see cref="T:DotSpatial.Topology.Noding.ISegmentIntersector"/>.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Noding.IntersectionAdder.HasInteriorIntersection">
            <summary>
            An interior intersection is an intersection which is
            in the interior of some segment.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.IntersectionFinderAdder">
            <summary>
            Finds proper and interior intersections in a set of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s,
            and adds them as nodes.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.IntersectionFinderAdder.#ctor(DotSpatial.Topology.Algorithm.LineIntersector)">
            <summary>
            Creates an intersection finder which finds all proper intersections.
            </summary>
            <param name="li">The <see cref="T:DotSpatial.Topology.Algorithm.LineIntersector"/> to use.</param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.IntersectionFinderAdder.ProcessIntersections(DotSpatial.Topology.Noding.SegmentString,System.Int32,DotSpatial.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:DotSpatial.Topology.Noding.ISegmentIntersector"/> class to process
            intersections for two segments of the <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s being intersected.
            Notice that some clients (such as <see cref="T:DotSpatial.Topology.Index.Chain.MonotoneChain"/>s) may optimize away
            this call for segment pairs which they have determined do not intersect
            (e.g. by an disjoint envelope test).
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="P:DotSpatial.Topology.Noding.IntersectionFinderAdder.InteriorIntersections">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.InvalidOctantException">
            <summary>
            A InvalidOctantException Class
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.InvalidOctantException.#ctor(System.String)">
            <summary>
            Creates a new instance of InvalidOctantException
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.IteratedNoder">
            <summary>
            Nodes a set of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s completely.
            The set of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s is fully noded;
            i.e. noding is repeated until no further intersections are detected.
            <para>
            Iterated noding using a <see cref="F:DotSpatial.Topology.PrecisionModelType.Floating"/> precision model is not guaranteed to converge,
            due to roundoff error. This problem is detected and an exception is thrown.
            Clients can choose to rerun the noding using a lower precision model.
            </para>
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Noding.IteratedNoder.MAX_ITERATIONS">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.IteratedNoder.#ctor(DotSpatial.Topology.PrecisionModel)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.IteratedNoder"/> class.
            </summary>
            <param name="pm"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.IteratedNoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            The <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.IteratedNoder.ComputeNodes(System.Collections.IList)">
            <summary>
            Fully nodes a list of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s, i.e. peforms noding iteratively
            until no intersections are found between segments.
            Maintains labelling of edges correctly through the noding.
            </summary>
            <param name="segStrings">A collection of SegmentStrings to be noded.</param>
            <exception cref="T:DotSpatial.Topology.TopologyException">If the iterated noding fails to converge.</exception>
        </member>
        <member name="M:DotSpatial.Topology.Noding.IteratedNoder.Node(System.Collections.IList,System.Int32[])">
            <summary>
            Node the input segment strings once
            and create the split edges between the nodes.
            </summary>
            <param name="segStrings"></param>
            <param name="numInteriorIntersections"></param>
        </member>
        <member name="P:DotSpatial.Topology.Noding.IteratedNoder.MaximumIterations">
            <summary>
            Gets/Sets the maximum number of noding iterations performed before
            the noding is aborted. Experience suggests that this should rarely need to be changed
            from the default. The default is <see cref="F:DotSpatial.Topology.Noding.IteratedNoder.MAX_ITERATIONS"/>.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.McIndexNoder">
            <summary>
            Nodes a set of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s using a index based
            on <see cref="T:DotSpatial.Topology.Index.Chain.MonotoneChain"/>s and a <see cref="T:DotSpatial.Topology.Index.ISpatialIndex"/>.
            The <see cref="T:DotSpatial.Topology.Index.ISpatialIndex"/> used should be something that supports
            envelope (range) queries efficiently (such as a <see cref="T:DotSpatial.Topology.Index.Quadtree.Quadtree"/>
            or <see cref="T:DotSpatial.Topology.Index.Strtree.StRtree"/>.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.SinglePassNoder">
            <summary>
            Base class for <see cref="T:DotSpatial.Topology.Noding.INoder"/>s which make a single pass to find intersections.
            This allows using a custom <see cref="T:DotSpatial.Topology.Noding.ISegmentIntersector"/>
            (which for instance may simply identify intersections, rather than insert them).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SinglePassNoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.SinglePassNoder"/> class.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SinglePassNoder.#ctor(DotSpatial.Topology.Noding.ISegmentIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.SinglePassNoder"/> class.
            </summary>
            <param name="segInt">The <see cref="T:DotSpatial.Topology.Noding.ISegmentIntersector"/> to use.</param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SinglePassNoder.ComputeNodes(System.Collections.IList)">
            <summary>
            Computes the noding for a collection of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="segStrings"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SinglePassNoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            The <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Noding.SinglePassNoder.SegmentIntersector">
            <summary>
            Gets/sets the <see cref="T:DotSpatial.Topology.Noding.ISegmentIntersector"/> to use with this noder.
            A <see cref="T:DotSpatial.Topology.Noding.ISegmentIntersector"/>  will normally add intersection nodes
            to the input segment strings, but it may not - it may
            simply record the presence of intersections.
            However, some <see cref="T:DotSpatial.Topology.Noding.INoder"/>s may require that intersections be added.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.McIndexNoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.McIndexNoder"/> class.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.McIndexNoder.#ctor(DotSpatial.Topology.Noding.ISegmentIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.McIndexNoder"/> class.
            </summary>
            <param name="segInt">The <see cref="T:DotSpatial.Topology.Noding.ISegmentIntersector"/> to use.</param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.McIndexNoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            The <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.McIndexNoder.ComputeNodes(System.Collections.IList)">
            <summary>
            Computes the noding for a collection of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="inputSegStrings"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.McIndexNoder.IntersectChains">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.McIndexNoder.Add(DotSpatial.Topology.Noding.SegmentString)">
             <summary>
            
             </summary>
             <param name="segStr"></param>
        </member>
        <member name="P:DotSpatial.Topology.Noding.McIndexNoder.MonotoneChains">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Noding.McIndexNoder.Index">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.McIndexNoder.SegmentOverlapAction">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.McIndexNoder.SegmentOverlapAction.#ctor(DotSpatial.Topology.Noding.ISegmentIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.McIndexNoder.SegmentOverlapAction"/> class.
            </summary>
            <param name="si">The <see cref="T:DotSpatial.Topology.Noding.ISegmentIntersector"/></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.McIndexNoder.SegmentOverlapAction.Overlap(DotSpatial.Topology.Index.Chain.MonotoneChain,System.Int32,DotSpatial.Topology.Index.Chain.MonotoneChain,System.Int32)">
             <summary>
            
             </summary>
             <param name="mc1"></param>
             <param name="start1"></param>
             <param name="mc2"></param>
             <param name="start2"></param>
        </member>
        <member name="T:DotSpatial.Topology.Noding.NodingValidator">
            <summary>
            Validates that a collection of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s is correctly noded.
            Throws an appropriate exception if an noding error is found.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodingValidator.#ctor(System.Collections.IList)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.NodingValidator"/> class.
            </summary>
            <param name="segStrings">The seg strings.</param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodingValidator.CheckValid">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodingValidator.CheckCollapses">
            <summary>
            Checks if a segment string contains a segment pattern a-b-a (which implies a self-intersection).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodingValidator.CheckCollapses(DotSpatial.Topology.Noding.SegmentString)">
             <summary>
            
             </summary>
             <param name="ss"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodingValidator.CheckCollapse(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
             <param name="p2"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodingValidator.CheckInteriorIntersections">
            <summary>
            Checks all pairs of segments for intersections at an interior point of a segment.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodingValidator.CheckInteriorIntersections(DotSpatial.Topology.Noding.SegmentString,DotSpatial.Topology.Noding.SegmentString)">
             <summary>
            
             </summary>
             <param name="ss0"></param>
             <param name="ss1"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodingValidator.CheckInteriorIntersections(DotSpatial.Topology.Noding.SegmentString,System.Int32,DotSpatial.Topology.Noding.SegmentString,System.Int32)">
             <summary>
            
             </summary>
             <param name="e0"></param>
             <param name="segIndex0"></param>
             <param name="e1"></param>
             <param name="segIndex1"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodingValidator.HasInteriorIntersection(DotSpatial.Topology.Algorithm.LineIntersector,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="li"></param>
             <param name="p0"></param>
             <param name="p1"></param>
             <returns><c>true</c> if there is an intersection point which is not an endpoint of the segment p0-p1.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodingValidator.CheckEndPtVertexIntersections">
            <summary>
            Checks for intersections between an endpoint of a segment string
            and an interior vertex of another segment string
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodingValidator.CheckEndPtVertexIntersections(DotSpatial.Topology.Coordinate,System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="testPt"></param>
             <param name="segStrings"></param>
        </member>
        <member name="T:DotSpatial.Topology.Noding.OctantDirection">
            <summary>
            Octants in the Cartesian plane.
            Octants are numbered as follows:
             <para>
              \2|1/
             3 \|/ 0
             ---+--
             4 /|\ 7
              /5|6\
            </para>
             If line segments lie along a coordinate axis, the octant is the lower of the two possible values.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Noding.OctantDirection.Null">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Noding.OctantDirection.Zero">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Noding.OctantDirection.One">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Noding.OctantDirection.Two">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Noding.OctantDirection.Three">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Noding.OctantDirection.Four">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Noding.OctantDirection.Five">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Noding.OctantDirection.Six">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Noding.OctantDirection.Seven">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.Octant">
            <summary>
             Methods for computing and working with <see cref="T:DotSpatial.Topology.Noding.OctantDirection"/> of the Cartesian plane.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Octant.GetOctant(System.Double,System.Double)">
            <summary>
            Returns the octant of a directed line segment (specified as x and y
            displacements, which cannot both be 0).
            </summary>
            <param name="dx"></param>
            <param name="dy"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Octant.GetOctant(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Returns the octant of a directed line segment from p0 to p1.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Noding.OrientedCoordinateArray">
            <summary>
             Allows comparing <see cref="T:DotSpatial.Topology.Coordinate"/> arrays in an orientation-independent way.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.OrientedCoordinateArray.#ctor(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Creates a new <see cref="T:DotSpatial.Topology.Noding.OrientedCoordinateArray"/>}
            for the given <see cref="T:DotSpatial.Topology.Coordinate"/> array.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.OrientedCoordinateArray.CompareTo(System.Object)">
            <summary>
            Compares two <see cref="T:DotSpatial.Topology.Noding.OrientedCoordinateArray"/>s for their relative order.
            </summary>
            <param name="o1"></param>
            <returns>
            -1 this one is smaller, or
             0 the two objects are equal, or
             1 this one is greater.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.OrientedCoordinateArray.Orientation(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Computes the canonical orientation for a coordinate array.
            </summary>
            <param name="pts"></param>
            <returns>
            <c>true</c> if the points are oriented forwards, or
            <c>false</c>if the points are oriented in reverse.
            </returns>
        </member>
        <member name="T:DotSpatial.Topology.Noding.ScaledNoder">
            <summary>
            Wraps a <see cref="T:DotSpatial.Topology.Noding.INoder"/> and transforms its input into the integer domain.
            This is intended for use with Snap-Rounding noders,
            which typically are only intended to work in the integer domain.
            Offsets can be provided to increase the number of digits of available precision.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.ScaledNoder.#ctor(DotSpatial.Topology.Noding.INoder,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.ScaledNoder"/> class.
            </summary>
            <param name="noder"></param>
            <param name="scaleFactor"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.ScaledNoder.#ctor(DotSpatial.Topology.Noding.INoder,System.Double,System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="noder"></param>
             <param name="scaleFactor"></param>
             <param name="offsetX"></param>
             <param name="offsetY"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.ScaledNoder.GetNodedSubstrings">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.ScaledNoder.ComputeNodes(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="inputSegStrings"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.ScaledNoder.Scale(System.Collections.ICollection)">
             <summary>
            
             </summary>
             <param name="segStrings"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.ScaledNoder.Scale(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.ScaledNoder.Rescale(System.Collections.ICollection)">
             <summary>
            
             </summary>
             <param name="segStrings"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.ScaledNoder.Rescale(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="pts"></param>
        </member>
        <member name="P:DotSpatial.Topology.Noding.ScaledNoder.IsIntegerPrecision">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.SegmentNode">
            <summary>
            Represents an intersection point between two <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Noding.SegmentNode.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Noding.SegmentNode.SegmentIndex">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNode.#ctor(DotSpatial.Topology.Noding.SegmentString,DotSpatial.Topology.Coordinate,System.Int32,DotSpatial.Topology.Noding.OctantDirection)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.SegmentNode"/> class.
            </summary>
            <param name="segString"></param>
            <param name="coord"></param>
            <param name="segmentIndex"></param>
            <param name="segmentOctant"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNode.CompareTo(System.Object)">
            <summary>
            </summary>
            <param name="obj"></param>
            <returns>
            -1 this SegmentNode is located before the argument location, or
             0 this SegmentNode is at the argument location, or
             1 this SegmentNode is located after the argument location.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNode.IsEndPoint(System.Int32)">
             <summary>
            
             </summary>
             <param name="maxSegmentIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNode.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="P:DotSpatial.Topology.Noding.SegmentNode.IsInterior">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Noding.SegmentNodeList">
            <summary>
            A list of the <see cref="T:DotSpatial.Topology.Noding.SegmentNode"/>s present along a noded <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNodeList.#ctor(DotSpatial.Topology.Noding.SegmentString)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.SegmentNodeList"/> class.
            </summary>
            <param name="edge">The edge.</param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNodeList.GetEnumerator">
            <summary>
            Returns an iterator of SegmentNodes.
            </summary>
            <returns>An iterator of SegmentNodes.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNodeList.Add(DotSpatial.Topology.Coordinate,System.Int32)">
            <summary>
            Adds an intersection into the list, if it isn't already there.
            The input segmentIndex and dist are expected to be normalized.
            </summary>
            <param name="intPt"></param>
            <param name="segmentIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNodeList.AddEndPoints">
            <summary>
            Adds nodes for the first and last points of the edge.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNodeList.AddCollapsedNodes">
            <summary>
            Adds nodes for any collapsed edge pairs.
            Collapsed edge pairs can be caused by inserted nodes, or they can be
            pre-existing in the edge vertex list.
            In order to provide the correct fully noded semantics,
            the vertex at the base of a collapsed pair must also be added as a node.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNodeList.FindCollapsesFromExistingVertices(System.Collections.IList)">
            <summary>
            Adds nodes for any collapsed edge pairs
            which are pre-existing in the vertex list.
            </summary>
            <param name="collapsedVertexIndexes"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNodeList.FindCollapsesFromInsertedNodes(System.Collections.IList)">
            <summary>
            Adds nodes for any collapsed edge pairs caused by inserted nodes
            Collapsed edge pairs occur when the same coordinate is inserted as a node
            both before and after an existing edge vertex.
            To provide the correct fully noded semantics,
            the vertex must be added as a node as well.
            </summary>
            <param name="collapsedVertexIndexes"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNodeList.FindCollapseIndex(DotSpatial.Topology.Noding.SegmentNode,DotSpatial.Topology.Noding.SegmentNode,System.Int32[])">
             <summary>
            
             </summary>
             <param name="ei0"></param>
             <param name="ei1"></param>
             <param name="collapsedVertexIndex"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNodeList.AddSplitEdges(System.Collections.IList)">
            <summary>
            Creates new edges for all the edges that the intersections in this
            list split the parent edge into.
            Adds the edges to the provided argument list
            (this is so a single list can be used to accumulate all split edges
            for a set of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s).
            </summary>
            <param name="edgeList"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNodeList.CreateSplitEdge(DotSpatial.Topology.Noding.SegmentNode,DotSpatial.Topology.Noding.SegmentNode)">
            <summary>
             Create a new "split edge" with the section of points between
            (and including) the two intersections.
            The label for the new edge is the same as the label for the parent edge.
            </summary>
            <param name="ei0"></param>
            <param name="ei1"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentNodeList.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="P:DotSpatial.Topology.Noding.SegmentNodeList.Edge">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="T:DotSpatial.Topology.Noding.NodeVertexIterator">
            <summary>
            INCOMPLETE!!!
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodeVertexIterator.MoveNext">
            <summary>
            Consente di spostare l'enumeratore all'elemento successivo dell'insieme.
            </summary>
            <returns>
            true se l'enumeratore  stato spostato correttamente in avanti in corrispondenza dell'elemento successivo; false se l'enumeratore ha raggiunto la fine dell'insieme.
            </returns>
            <exception cref="T:System.InvalidOperationException">L'insieme  stato modificato dopo la creazione dell'enumeratore. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodeVertexIterator.Reset">
            <summary>
            Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nell'insieme.
            </summary>
            <exception cref="T:System.InvalidOperationException">L'insieme  stato modificato dopo la creazione dell'enumeratore. </exception>
        </member>
        <member name="M:DotSpatial.Topology.Noding.NodeVertexIterator.Remove">
            <summary>
            Not implemented.
            </summary>
            <exception cref="T:System.NotSupportedException">This method is not implemented.</exception>
        </member>
        <member name="P:DotSpatial.Topology.Noding.NodeVertexIterator.Current">
            <summary>
            Ottiene l'elemento corrente dell'insieme.
            </summary>
            <value></value>
            <returns>Elemento corrente nell'insieme.</returns>
            <exception cref="T:System.InvalidOperationException">L'enumeratore  posizionato prima del primo elemento o dopo l'ultimo elemento dell'insieme. </exception>
        </member>
        <member name="T:DotSpatial.Topology.Noding.SegmentPointComparator">
            <summary>
            Implements a robust method of comparing the relative position of two points along the same segment.
            The coordinates are assumed to lie "near" the segment.
            This means that this algorithm will only return correct results
            if the input coordinates have the same precision and correspond to rounded values
            of exact coordinates lying on the segment.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentPointComparator.Compare(DotSpatial.Topology.Noding.OctantDirection,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
             Compares two <see cref="T:DotSpatial.Topology.Coordinate"/>s for their relative position along a segment
            lying in the specified <see cref="T:DotSpatial.Topology.Noding.Octant"/>.
            </summary>
            <param name="octant"></param>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns>
            -1 if node0 occurs first, or
             0 if the two nodes are equal, or
             1 if node1 occurs first.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentPointComparator.RelativeSign(System.Double,System.Double)">
             <summary>
            
             </summary>
             <param name="x0"></param>
             <param name="x1"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentPointComparator.CompareValue(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="compareSign0"></param>
             <param name="compareSign1"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Noding.SegmentString">
            <summary>
            Represents a list of contiguous line segments, and supports noding the segments.
            The line segments are represented by an array of <see cref="T:DotSpatial.Topology.Coordinate"/>s.
            Intended to optimize the noding of contiguous segments by
            reducing the number of allocated objects.
            <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s can carry a context object, which is useful
            for preserving topological or parentage information.
            All noded substrings are initialized with the same context object.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentString.GetNodedSubstrings(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="segStrings"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentString.GetNodedSubstrings(System.Collections.IList,System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="segStrings"></param>
             <param name="resultEdgelist"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentString.#ctor(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Object)">
            <summary>
            Creates a new segment string from a list of vertices.
            </summary>
            <param name="pts">The vertices of the segment string.</param>
            <param name="data">The user-defined data of this segment string (may be null).</param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentString.GetCoordinate(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentString.GetSegmentOctant(System.Int32)">
            <summary>
             Gets the octant of the segment starting at vertex <c>index</c>.
            </summary>
            <param name="index">
            The index of the vertex starting the segment.
            Must not be the last index in the vertex list
            </param>
            <returns>The octant of the segment at the vertex</returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentString.AddIntersections(DotSpatial.Topology.Algorithm.LineIntersector,System.Int32)">
            <summary>
            Adds EdgeIntersections for one or both
            intersections found for a segment of an edge to the edge intersection list.
            </summary>
            <param name="li"></param>
            <param name="segmentIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentString.AddIntersection(DotSpatial.Topology.Algorithm.LineIntersector,System.Int32,System.Int32)">
            <summary>
            Add an <see cref="T:DotSpatial.Topology.Noding.SegmentNode"/> for intersection intIndex.
            An intersection that falls exactly on a vertex
            of the <see cref="T:DotSpatial.Topology.Noding.SegmentString"/> is normalized
            to use the higher of the two possible segmentIndexes.
            </summary>
            <param name="li"></param>
            <param name="segmentIndex"></param>
            <param name="intIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentString.AddIntersection(DotSpatial.Topology.Coordinate,System.Int32)">
             <summary>
            
             </summary>
             <param name="intPt"></param>
             <param name="segmentIndex"></param>
        </member>
        <member name="P:DotSpatial.Topology.Noding.SegmentString.Data">
            <summary>
            Gets/Sets the user-defined data for this segment string.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Noding.SegmentString.NodeList">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Noding.SegmentString.Count">
             <summary>
            
             </summary>
             <value></value>
        </member>
        <member name="P:DotSpatial.Topology.Noding.SegmentString.Coordinates">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Noding.SegmentString.IsClosed">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.SegmentStringDissolver">
             <summary>
             Dissolves a noded collection of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s to produce
             a set of merged linework with unique segments.
             A custom merging strategy can be applied when two identical (up to orientation)
             strings are dissolved together.
             The default merging strategy is simply to discard the merged string.
            <para>
             A common use for this class is to merge noded edges
             while preserving topological labelling.
             </para>
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentStringDissolver.#ctor(DotSpatial.Topology.Noding.SegmentStringDissolver.ISegmentStringMerger)">
            <summary>
            Creates a dissolver with a user-defined merge strategy.
            </summary>
            <param name="merger"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentStringDissolver.#ctor">
            <summary>
            Creates a dissolver with the default merging strategy.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentStringDissolver.Dissolve(System.Collections.ICollection)">
            <summary>
            Dissolve all <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s in the input <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <param name="segStrings"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentStringDissolver.Add(DotSpatial.Topology.Noding.OrientedCoordinateArray,DotSpatial.Topology.Noding.SegmentString)">
             <summary>
            
             </summary>
             <param name="oca"></param>
             <param name="segString"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentStringDissolver.Dissolve(DotSpatial.Topology.Noding.SegmentString)">
            <summary>
            Dissolve the given <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>.
            </summary>
            <param name="segString"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentStringDissolver.FindMatching(DotSpatial.Topology.Noding.OrientedCoordinateArray)">
             <summary>
            
             </summary>
             <param name="oca"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Noding.SegmentStringDissolver.Dissolved">
            <summary>
            Gets the collection of dissolved (i.e. unique) <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.SegmentStringDissolver.ISegmentStringMerger">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SegmentStringDissolver.ISegmentStringMerger.Merge(DotSpatial.Topology.Noding.SegmentString,DotSpatial.Topology.Noding.SegmentString,System.Boolean)">
            <summary>
            Updates the context data of a <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>
            when an identical (up to orientation) one is found during dissolving.
            </summary>
            <param name="mergeTarget">The segment string to update.</param>
            <param name="ssToMerge">The segment string being dissolved.</param>
            <param name="isSameOrientation">
            <c>true</c> if the strings are in the same direction,
            <c>false</c> if they are opposite.
            </param>
        </member>
        <member name="T:DotSpatial.Topology.Noding.SimpleNoder">
            <summary>
            Nodes a set of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s by
            performing a brute-force comparison of every segment to every other one.
            This has n^2 performance, so is too slow for use on large numbers of segments.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SimpleNoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.SimpleNoder"/> class.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SimpleNoder.#ctor(DotSpatial.Topology.Noding.ISegmentIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.SimpleNoder"/> class.
            </summary>
            <param name="segInt"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SimpleNoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            The <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SimpleNoder.ComputeNodes(System.Collections.IList)">
            <summary>
            Computes the noding for a collection of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="inputSegStrings"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.SimpleNoder.ComputeIntersects(DotSpatial.Topology.Noding.SegmentString,DotSpatial.Topology.Noding.SegmentString)">
             <summary>
            
             </summary>
             <param name="e0"></param>
             <param name="e1"></param>
        </member>
        <member name="T:DotSpatial.Topology.Noding.Snapround.HotPixel">
            <summary>
            Implements a "hot pixel" as used in the Snap Rounding algorithm.
            A hot pixel contains the interior of the tolerance square and the boundary
            minus the top and right segments.
            The hot pixel operations are all computed in the integer domain
            to avoid rounding problems.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.HotPixel.#ctor(DotSpatial.Topology.Coordinate,System.Double,DotSpatial.Topology.Algorithm.LineIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.Snapround.HotPixel"/> class.
            </summary>
            <param name="pt"></param>
            <param name="scaleFactor"></param>
            <param name="li"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.HotPixel.GetSafeEnvelope">
            <summary>
            Returns a "safe" envelope that is guaranteed to contain the hot pixel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.HotPixel.InitCorners(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="pt"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.HotPixel.Scale(System.Double)">
             <summary>
            
             </summary>
             <param name="val"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.HotPixel.Intersects(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.HotPixel.CopyScaled(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="pScaled"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.HotPixel.IntersectsScaled(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.HotPixel.IntersectsToleranceSquare(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Tests whether the segment p0-p1 intersects the hot pixel tolerance square.
            Because the tolerance square point set is partially open (along the
            top and right) the test needs to be more sophisticated than
            simply checking for any intersection.  However, it
            can take advantage of the fact that because the hot pixel edges
            do not lie on the coordinate grid.  It is sufficient to check
            if there is at least one of:
             - a proper intersection with the segment and any hot pixel edge.
             - an intersection between the segment and both the left and bottom edges.
             - an intersection between a segment endpoint and the hot pixel coordinate.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Noding.Snapround.HotPixel.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper">
            <summary>
            "Snaps" all <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s in a <see cref="T:DotSpatial.Topology.Index.ISpatialIndex"/> containing
            <see cref="T:DotSpatial.Topology.Index.Chain.MonotoneChain"/>s to a given <see cref="T:DotSpatial.Topology.Noding.Snapround.HotPixel"/>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper.#ctor(DotSpatial.Topology.Index.ISpatialIndex)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper"/> class.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper.Snap(DotSpatial.Topology.Noding.Snapround.HotPixel,DotSpatial.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            Snaps (nodes) all interacting segments to this hot pixel.
            The hot pixel may represent a vertex of an edge,
            in which case this routine uses the optimization
            of not noding the vertex itself
            </summary>
            <param name="hotPixel">The hot pixel to snap to.</param>
            <param name="parentEdge">The edge containing the vertex, if applicable, or <c>null</c>.</param>
            <param name="vertexIndex"></param>
            <returns><c>true</c> if a node was added for this pixel.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper.Snap(DotSpatial.Topology.Noding.Snapround.HotPixel)">
             <summary>
            
             </summary>
             <param name="hotPixel"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper.HotPixelSnapAction">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper.HotPixelSnapAction.#ctor(DotSpatial.Topology.Noding.Snapround.HotPixel,DotSpatial.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper.HotPixelSnapAction"/> class.
            </summary>
            <param name="hotPixel"></param>
            <param name="parentEdge"></param>
            <param name="vertexIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper.HotPixelSnapAction.Select(DotSpatial.Topology.Index.Chain.MonotoneChain,System.Int32)">
             <summary>
            
             </summary>
             <param name="mc"></param>
             <param name="startIndex"></param>
        </member>
        <member name="P:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper.HotPixelSnapAction.IsNodeAdded">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper.QueryVisitor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper.QueryVisitor.#ctor(DotSpatial.Topology.Envelope,DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper.HotPixelSnapAction)">
             <summary>
            
             </summary>
             <param name="env"></param>
             <param name="action"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexPointSnapper.QueryVisitor.VisitItem(System.Object)">
            <summary>
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:DotSpatial.Topology.Noding.Snapround.McIndexSnapRounder">
            <summary>
            Uses Snap Rounding to compute a rounded,
            fully noded arrangement from a set of {@link SegmentString}s.
            Implements the Snap Rounding technique described in Hobby, Guibas and Marimont, and Goodrich et al.
            Snap Rounding assumes that all vertices lie on a uniform grid
            (hence the precision model of the input must be fixed precision,
            and all the input vertices must be rounded to that precision).
            <para>
            This implementation uses a monotone chains and a spatial index to
            speed up the intersection tests.
            This implementation appears to be fully robust using an integer precision model.
            It will function with non-integer precision models, but the
            results are not 100% guaranteed to be correctly noded.
            </para>
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexSnapRounder.#ctor(DotSpatial.Topology.PrecisionModel)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.Snapround.McIndexSnapRounder"/> class.
            </summary>
            <param name="pm">The <see cref="T:DotSpatial.Topology.PrecisionModel"/> to use.</param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexSnapRounder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            The <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexSnapRounder.ComputeNodes(System.Collections.IList)">
            <summary>
            Computes the noding for a collection of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="inputSegmentStrings"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexSnapRounder.SnapRound(System.Collections.IList,DotSpatial.Topology.Algorithm.LineIntersector)">
             <summary>
            
             </summary>
             <param name="segStrings"></param>
             <param name="li"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexSnapRounder.FindInteriorIntersections(System.Collections.IList,DotSpatial.Topology.Algorithm.LineIntersector)">
             <summary>
             Computes all interior intersections in the collection of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s,
             and returns their <see cref="T:DotSpatial.Topology.Coordinate"/>s.
            
             Does NOT node the segStrings.
             </summary>
             <param name="segStrings"></param>
             <param name="li"></param>
             <returns>A list of Coordinates for the intersections.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexSnapRounder.ComputeIntersectionSnaps(System.Collections.IList)">
            <summary>
            Computes nodes introduced as a result of snapping segments to snap points (hot pixels).
            </summary>
            <param name="snapPts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexSnapRounder.ComputeVertexSnaps(System.Collections.IList)">
            <summary>
            Computes nodes introduced as a result of
            snapping segments to vertices of other segments.
            </summary>
            <param name="edges"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.McIndexSnapRounder.ComputeVertexSnaps(DotSpatial.Topology.Noding.SegmentString)">
            <summary>
            Performs a brute-force comparison of every segment in each <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>.
            This has n^2 performance.
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:DotSpatial.Topology.Noding.Snapround.SimpleSnapRounder">
            <summary>
            Uses Snap Rounding to compute a rounded,
            fully noded arrangement from a set of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            Implements the Snap Rounding technique described in Hobby, Guibas and Marimont, and Goodrich et al.
            Snap Rounding assumes that all vertices lie on a uniform grid
            (hence the precision model of the input must be fixed precision,
            and all the input vertices must be rounded to that precision).
            <para>
            This implementation uses simple iteration over the line segments.
            This implementation appears to be fully robust using an integer precision model.
            It will function with non-integer precision models, but the
            results are not 100% guaranteed to be correctly noded.
            </para>
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.SimpleSnapRounder.#ctor(DotSpatial.Topology.PrecisionModel)">
            <summary>
            Initializes a new instance of the <see cref="T:DotSpatial.Topology.Noding.Snapround.SimpleSnapRounder"/> class.
            </summary>
            <param name="pm">The <see cref="T:DotSpatial.Topology.PrecisionModel"/> to use.</param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.SimpleSnapRounder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            The <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.SimpleSnapRounder.ComputeNodes(System.Collections.IList)">
            <summary>
            Computes the noding for a collection of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="inputSegmentStrings"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.SimpleSnapRounder.SnapRound(System.Collections.IList,DotSpatial.Topology.Algorithm.LineIntersector)">
             <summary>
            
             </summary>
             <param name="segStrings"></param>
             <param name="li"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.SimpleSnapRounder.FindInteriorIntersections(System.Collections.IList,DotSpatial.Topology.Algorithm.LineIntersector)">
            <summary>
            Computes all interior intersections in the collection of <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>s,
            and returns their <see cref="T:DotSpatial.Topology.Coordinate"/>s.
            Does NOT node the segStrings.
            </summary>
            <param name="segStrings"></param>
            <param name="li"></param>
            <returns>A list of <see cref="T:DotSpatial.Topology.Coordinate"/>s for the intersections.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.SimpleSnapRounder.ComputeSnaps(System.Collections.IList,System.Collections.IList)">
            <summary>
            Computes nodes introduced as a result of snapping segments to snap points (hot pixels).
            </summary>
            <param name="segStrings"></param>
            <param name="snapPts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.SimpleSnapRounder.ComputeSnaps(DotSpatial.Topology.Noding.SegmentString,System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="ss"></param>
             <param name="snapPts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.SimpleSnapRounder.ComputeVertexSnaps(System.Collections.IList)">
            <summary>
            Computes nodes introduced as a result of
            snapping segments to vertices of other segments.
            </summary>
            <param name="edges"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.SimpleSnapRounder.ComputeVertexSnaps(DotSpatial.Topology.Noding.SegmentString,DotSpatial.Topology.Noding.SegmentString)">
            <summary>
            Performs a brute-force comparison of every segment in each <see cref="T:DotSpatial.Topology.Noding.SegmentString"/>.
            This has n^2 performance.
            </summary>
            <param name="e0"></param>
            <param name="e1"></param>
        </member>
        <member name="M:DotSpatial.Topology.Noding.Snapround.SimpleSnapRounder.AddSnappedNode(DotSpatial.Topology.Noding.Snapround.HotPixel,DotSpatial.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            Adds a new node (equal to the snap pt) to the segment
            if the segment passes through the hot pixel.
            </summary>
            <param name="hotPix"></param>
            <param name="segStr"></param>
            <param name="segIndex"></param>
            <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Buffer.BufferBuilder">
            <summary>
            Builds the buffer point for a given input point and precision model.
            Allows setting the level of approximation for circular arcs,
            and the precision model in which to carry out the computation.
            When computing buffers in floating point double-precision
            it can happen that the process of iterated noding can fail to converge (terminate).
            In this case a TopologyException will be thrown.
            Retrying the computation in a fixed precision
            can produce more robust results.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferBuilder.DepthDelta(DotSpatial.Topology.GeometriesGraph.Label)">
            <summary>
            Compute the change in depth as an edge is crossed from R to L.
            </summary>
            <param name="label"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferBuilder.Buffer(DotSpatial.Topology.IGeometry,System.Double)">
             <summary>
            
             </summary>
             <param name="g"></param>
             <param name="distance"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferBuilder.GetNoder(DotSpatial.Topology.PrecisionModel)">
             <summary>
            
             </summary>
             <param name="precisionModel"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferBuilder.ComputeNodedEdges(System.Collections.IList,DotSpatial.Topology.PrecisionModel)">
             <summary>
            
             </summary>
             <param name="bufferSegStrList"></param>
             <param name="precisionModel"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferBuilder.InsertEdge(DotSpatial.Topology.GeometriesGraph.Edge)">
            <summary>
            Inserted edges are checked to see if an identical edge already exists.
            If so, the edge is not inserted, but its label is merged
            with the existing edge.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferBuilder.BuildSubgraphs(System.Collections.IList,DotSpatial.Topology.Operation.Overlay.PolygonBuilder)">
            <summary>
            Completes the building of the input subgraphs by depth-labelling them,
            and adds them to the <see cref="T:DotSpatial.Topology.Operation.Overlay.PolygonBuilder"/>.
            The subgraph list must be sorted in rightmost-coordinate order.
            </summary>
            <param name="subgraphList">The subgraphs to build.</param>
            <param name="polyBuilder">The PolygonBuilder which will build the final polygons.</param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.BufferBuilder.QuadrantSegments">
            <summary>
            Gets/Sets the number of segments used to approximate a angle fillet.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.BufferBuilder.WorkingPrecisionModel">
            <summary>
            Gets/Sets the precision model to use during the curve computation and noding,
            if it is different to the precision model of the Geometry.
            If the precision model is less than the precision of the Geometry precision model,
            the Geometry must have previously been rounded to that precision.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.BufferBuilder.EndCapStyle">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Buffer.BufferOp">
            <summary>
            Computes the buffer of a point, for both positive and negative buffer distances.
            In GIS, the buffer of a point is defined as
            the Minkowski sum or difference of the point
            with a circle with radius equal to the absolute value of the buffer distance.
            In the CAD/CAM world buffers are known as offset curves.
            Since true buffer curves may contain circular arcs,
            computed buffer polygons can only be approximations to the true point.
            The user can control the accuracy of the curve approximation by specifying
            the number of linear segments with which to approximate a curve.
            The end cap endCapStyle of a linear buffer may be specified. The
            following end cap styles are supported:
            <para>
            {CAP_ROUND} - the usual round end caps
            {CAP_BUTT} - end caps are truncated flat at the line ends
            {CAP_SQUARE} - end caps are squared off at the buffer distance beyond the line ends
            </para>
            The computation uses an algorithm involving iterated noding and precision reduction
            to provide a high degree of robustness.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferOp.#ctor(DotSpatial.Topology.IGeometry)">
            <summary>
            Initializes a buffer computation for the given point.
            </summary>
            <param name="g">The point to buffer.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferOp.PrecisionScaleFactor(DotSpatial.Topology.IGeometry,System.Double,System.Int32)">
            <summary>
            Compute a reasonable scale factor to limit the precision of
            a given combination of Geometry and buffer distance.
            The scale factor is based on a heuristic.
            </summary>
            <param name="g">The Geometry being buffered.</param>
            <param name="distance">The buffer distance.</param>
            <param name="maxPrecisionDigits">The mzx # of digits that should be allowed by
            the precision determined by the computed scale factor.</param>
            <returns>A scale factor that allows a reasonable amount of precision for the buffer computation.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferOp.Buffer(DotSpatial.Topology.IGeometry,System.Double)">
            <summary>
            Computes the buffer of a point for a given buffer distance.
            </summary>
            <param name="g">The point to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <returns> The buffer of the input point.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferOp.Buffer(DotSpatial.Topology.Geometry,System.Double,DotSpatial.Topology.BufferStyle)">
            <summary>
            Computes the buffer of a point for a given buffer distance,
            using the given Cap Style for borders of the point.
            </summary>
            <param name="g">The point to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns> The buffer of the input point.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferOp.Buffer(DotSpatial.Topology.Geometry,System.Double,System.Int32)">
            <summary>
            Computes the buffer for a point for a given buffer distance
            and accuracy of approximation.
            </summary>
            <param name="g">The point to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <param name="quadrantSegments">The number of segments used to approximate a quarter circle.</param>
            <returns>The buffer of the input point.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferOp.Buffer(DotSpatial.Topology.IGeometry,System.Double,System.Int32,DotSpatial.Topology.BufferStyle)">
            <summary>
            Computes the buffer for a point for a given buffer distance
            and accuracy of approximation.
            </summary>
            <param name="g">The point to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <param name="quadrantSegments">The number of segments used to approximate a quarter circle.</param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>The buffer of the input point.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferOp.GetResultGeometry(System.Double)">
             <summary>
            
             </summary>
             <param name="distance"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferOp.GetResultGeometry(System.Double,System.Int32)">
             <summary>
            
             </summary>
             <param name="distance"></param>
             <param name="quadrantSegments"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferOp.ComputeGeometry">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferOp.BufferOriginalPrecision">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferOp.BufferFixedPrecision(System.Int32)">
             <summary>
            
             </summary>
             <param name="precisionDigits"></param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.BufferOp.EndCapStyle">
            <summary>
            Specifies the end cap endCapStyle of the generated buffer.
            The styles supported are CapRound, CapButt, and CapSquare.
            The default is CapRound.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.BufferOp.QuadrantSegments">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Buffer.BufferSubgraph">
            <summary>
            A connected subset of the graph of
            <c>DirectedEdges</c> and <c>Node</c>s.
            Its edges will generate either
            a single polygon in the complete buffer, with zero or more holes, or
            one or more connected holes.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.CompareTo(System.Object)">
            <summary>
            BufferSubgraphs are compared on the x-value of their rightmost Coordinate.
            This defines a partial ordering on the graphs such that:
            g1 >= g2 - Ring(g2) does not contain Ring(g1)
            where Polygon(g) is the buffer polygon that is built from g.
            This relationship is used to sort the BufferSubgraphs so that shells are guaranteed to
            be built before holes.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.Create(DotSpatial.Topology.GeometriesGraph.Node)">
            <summary>
            Creates the subgraph consisting of all edges reachable from this node.
            Finds the edges in the graph and the rightmost coordinate.
            </summary>
            <param name="node">A node to start the graph traversal from.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.AddReachable(DotSpatial.Topology.GeometriesGraph.Node)">
            <summary>
            Adds all nodes and edges reachable from this node to the subgraph.
            Uses an explicit stack to avoid a large depth of recursion.
            </summary>
            <param name="startNode">A node known to be in the subgraph.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.Add(DotSpatial.Topology.GeometriesGraph.Node,System.Collections.Stack)">
            <summary>
            Adds the argument node and all its out edges to the subgraph
            </summary>
            <param name="node">The node to add.</param>
            <param name="nodeStack">The current set of nodes being traversed.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.ClearVisitedEdges">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.ComputeDepth(System.Int32)">
             <summary>
            
             </summary>
             <param name="outsideDepth"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.ComputeDepths(DotSpatial.Topology.GeometriesGraph.DirectedEdge)">
            <summary>
            Compute depths for all dirEdges via breadth-first traversal of nodes in graph.
            </summary>
            <param name="startEdge">Edge to start processing with.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.ComputeNodeDepth(DotSpatial.Topology.GeometriesGraph.Node)">
             <summary>
            
             </summary>
             <param name="n"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.CopySymDepths(DotSpatial.Topology.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="de"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.FindResultEdges">
            <summary>
            Find all edges whose depths indicates that they are in the result area(s).
            Since we want polygon shells to be
            oriented CW, choose dirEdges with the interior of the result on the RHS.
            Mark them as being in the result.
            Interior Area edges are the result of dimensional collapses.
            They do not form part of the result area boundary.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.DirectedEdges">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.Nodes">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.BufferSubgraph.RightMostCoordinate">
            <summary>
            Gets the rightmost coordinate in the edges of the subgraph.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder">
            <summary>
            Computes the raw offset curve for a
            single <c>Geometry</c> component (ring, line or point).
            A raw offset curve line is not noded -
            it may contain self-intersections (and usually will).
            The final buffer polygon is computed by forming a topological graph
            of all the noded raw curves and tracing outside contours.
            The points in the raw curve are rounded to the required precision model.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.DEFAULT_QUADRANT_SEGMENTS">
            <summary>
            The default number of facets into which to divide a fillet of 90 degrees.
            A value of 8 gives less than 2% max error in the buffer distance.
            For a max error smaller of 1%, use QS = 12
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.#ctor(DotSpatial.Topology.PrecisionModel)">
             <summary>
            
             </summary>
             <param name="precisionModel"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.#ctor(DotSpatial.Topology.PrecisionModel,System.Int32)">
             <summary>
            
             </summary>
             <param name="precisionModel"></param>
             <param name="quadrantSegments"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.GetLineCurve(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Double)">
            <summary>
            This method handles single points as well as lines.
            Lines are assumed to not be closed (the function will not
            fail for closed lines, but will generate superfluous line caps).
            </summary>
            <param name="inputPts"></param>
            <param name="distance"></param>
            <returns> A List of Coordinate[].</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.GetRingCurve(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},DotSpatial.Topology.GeometriesGraph.PositionType,System.Double)">
            <summary>
            This method handles the degenerate cases of single points and lines,
            as well as rings.
            </summary>
            <returns>A List of Coordinate[].</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.CopyCoordinates(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.Init(System.Double)">
             <summary>
            
             </summary>
             <param name="distance"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.ComputeLineBufferCurve(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="inputPts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.ComputeRingBufferCurve(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},DotSpatial.Topology.GeometriesGraph.PositionType)">
             <summary>
            
             </summary>
             <param name="inputPts"></param>
             <param name="side"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.AddPt(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="pt"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.ClosePts">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.InitSideSegments(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.GeometriesGraph.PositionType)">
             <summary>
            
             </summary>
             <param name="s1"></param>
             <param name="s2"></param>
             <param name="side"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.AddNextSegment(DotSpatial.Topology.Coordinate,System.Boolean)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <param name="addStartPoint"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.AddLastSegment">
            <summary>
            Add last offset point.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.ComputeOffsetSegment(DotSpatial.Topology.ILineSegmentBase,DotSpatial.Topology.GeometriesGraph.PositionType,System.Double,DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Compute an offset segment for an input segment on a given side and at a given distance.
            The offset points are computed in full double precision, for accuracy.
            </summary>
            <param name="seg">The segment to offset.</param>
            <param name="side">The side of the segment the offset lies on.</param>
            <param name="distance">The offset distance.</param>
            <param name="offset">The points computed for the offset segment.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.AddLineEndCap(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
            <summary>
            Add an end cap around point p1, terminating a line segment coming from p0.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.AddFillet(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,System.Int32,System.Double)">
             <summary>
            
             </summary>
             <param name="p">Base point of curve.</param>
             <param name="p0">Start point of fillet curve.</param>
             <param name="p1">Endpoint of fillet curve.</param>
             <param name="direction"></param>
             <param name="distance"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.AddFillet(DotSpatial.Topology.Coordinate,System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Adds points for a fillet.  The start and end point for the fillet are not added -
            the caller must add them if required.
            </summary>
            <param name="p"></param>
            <param name="startAngle"></param>
            <param name="endAngle"></param>
            <param name="direction">Is -1 for a CW angle, 1 for a CCW angle.</param>
            <param name="distance"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.AddCircle(DotSpatial.Topology.Coordinate,System.Double)">
            <summary>
            Adds a CW circle around a point.
            </summary>
            <param name="p"></param>
            <param name="distance"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.AddSquare(DotSpatial.Topology.Coordinate,System.Double)">
            <summary>
            Adds a CW square around a point
            </summary>
            <param name="p"></param>
            <param name="distance"></param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.EndCapStyle">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder.Coordinates">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder">
            <summary>
            Creates all the raw offset curves for a buffer of a <c>Geometry</c>.
            Raw curves need to be noded together and polygonized to form the final buffer area.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder.#ctor(DotSpatial.Topology.IGeometry,System.Double,DotSpatial.Topology.Operation.Buffer.OffsetCurveBuilder)">
             <summary>
            
             </summary>
             <param name="inputGeom"></param>
             <param name="distance"></param>
             <param name="curveBuilder"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder.GetCurves">
            <summary>
            Computes the set of raw offset curves for the buffer.
            Each offset curve has an attached {Label} indicating
            its left and right location.
            </summary>
            <returns>A Collection of SegmentStrings representing the raw buffer curves.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddCurves(System.Collections.IEnumerable,DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType)">
             <summary>
            
             </summary>
             <param name="lineList"></param>
             <param name="leftLoc"></param>
             <param name="rightLoc"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddCurve(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType)">
            <summary>
            Creates a {SegmentString} for a coordinate list which is a raw offset curve,
            and adds it to the list of buffer curves.
            The SegmentString is tagged with a Label giving the topology of the curve.
            The curve may be oriented in either direction.
            If the curve is oriented CW, the locations will be:
            Left: Location.Exterior.
            Right: Location.Interior.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder.Add(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddCollection(DotSpatial.Topology.IGeometryCollection)">
             <summary>
            
             </summary>
             <param name="gc"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddPoint(DotSpatial.Topology.IPoint)">
            <summary>
            Add a Point to the graph.
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddLineString(DotSpatial.Topology.ILineString)">
             <summary>
            
             </summary>
             <param name="line"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddPolygon(DotSpatial.Topology.IPolygon)">
             <summary>
            
             </summary>
             <param name="p"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddPolygonRing(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Double,DotSpatial.Topology.GeometriesGraph.PositionType,DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType)">
            <summary>
            Add an offset curve for a ring.
            The side and left and right topological location arguments
            assume that the ring is oriented CW.
            If the ring is in the opposite orientation,
            the left and right locations must be interchanged and the side flipped.
            </summary>
            <param name="coord">The coordinates of the ring (must not contain repeated points).</param>
            <param name="offsetDistance">The distance at which to create the buffer.</param>
            <param name="side">The side of the ring on which to construct the buffer line.</param>
            <param name="cwLeftLoc">The location on the L side of the ring (if it is CW).</param>
            <param name="cwRightLoc">The location on the R side of the ring (if it is CW).</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder.IsErodedCompletely(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Double)">
            <summary>
            The ringCoord is assumed to contain no repeated points.
            It may be degenerate (i.e. contain only 1, 2, or 3 points).
            In this case it has no area, and hence has a minimum diameter of 0.
            </summary>
            <param name="ringCoord"></param>
            <param name="bufferDistance"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.OffsetCurveSetBuilder.IsTriangleErodedCompletely(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Double)">
            <summary>
            Tests whether a triangular ring would be eroded completely by the given
            buffer distance.
            This is a precise test.  It uses the fact that the inner buffer of a
            triangle converges on the inCentre of the triangle (the point
            equidistant from all sides).  If the buffer distance is greater than the
            distance of the inCentre from a side, the triangle will be eroded completely.
            This test is important, since it removes a problematic case where
            the buffer distance is slightly larger than the inCentre distance.
            In this case the triangle buffer curve "inverts" with incorrect topology,
            producing an incorrect hole in the buffer.
            </summary>
            <param name="triangleCoord"></param>
            <param name="bufferDistance"></param>
            <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Buffer.RightmostEdgeFinder">
            <summary>
            A RightmostEdgeFinder find the DirectedEdge in a list which has the highest coordinate,
            and which is oriented L to R at that point. (I.e. the right side is on the RHS of the edge.)
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.RightmostEdgeFinder.FindEdge(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="dirEdgeList"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.RightmostEdgeFinder.FindRightmostEdgeAtNode">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.RightmostEdgeFinder.FindRightmostEdgeAtVertex">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.RightmostEdgeFinder.CheckForRightmostCoordinate(DotSpatial.Topology.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="de"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.RightmostEdgeFinder.GetRightmostSide(DotSpatial.Topology.GeometriesGraph.DirectedEdge,System.Int32)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <param name="index"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.RightmostEdgeFinder.GetRightmostSideOfSegment(DotSpatial.Topology.GeometriesGraph.EdgeEnd,System.Int32)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.RightmostEdgeFinder.Edge">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.RightmostEdgeFinder.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Buffer.SubgraphDepthLocater">
            <summary>
            Locates a subgraph inside a set of subgraphs,
            in order to determine the outside depth of the subgraph.
            The input subgraphs are assumed to have had depths
            already calculated for their edges.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.SubgraphDepthLocater.#ctor(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="subgraphs"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.SubgraphDepthLocater.GetDepth(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.SubgraphDepthLocater.FindStabbedSegments(DotSpatial.Topology.Coordinate)">
            <summary>
            Finds all non-horizontal segments intersecting the stabbing line.
            The stabbing line is the ray to the right of stabbingRayLeftPt.
            </summary>
            <param name="stabbingRayLeftPt">The left-hand origin of the stabbing line.</param>
            <returns>A List of {DepthSegments} intersecting the stabbing line.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.SubgraphDepthLocater.FindStabbedSegments(DotSpatial.Topology.Coordinate,System.Collections.IEnumerable,System.Collections.IList)">
            <summary>
            Finds all non-horizontal segments intersecting the stabbing line
            in the list of dirEdges.
            The stabbing line is the ray to the right of stabbingRayLeftPt.
            </summary>
            <param name="stabbingRayLeftPt">The left-hand origin of the stabbing line.</param>
            <param name="dirEdges"></param>
            <param name="stabbedSegments">The current list of DepthSegments intersecting the stabbing line.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.SubgraphDepthLocater.FindStabbedSegments(DotSpatial.Topology.Coordinate,DotSpatial.Topology.GeometriesGraph.DirectedEdge,System.Collections.IList)">
            <summary>
            Finds all non-horizontal segments intersecting the stabbing line
            in the input dirEdge.
            The stabbing line is the ray to the right of stabbingRayLeftPt.
            </summary>
            <param name="stabbingRayLeftPt">The left-hand origin of the stabbing line.</param>
            <param name="dirEdge"></param>
            <param name="stabbedSegments">The current list of DepthSegments intersecting the stabbing line.</param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Buffer.SubgraphDepthLocater.DepthSegment">
            <summary>
            A segment from a directed edge which has been assigned a depth value
            for its sides.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.SubgraphDepthLocater.DepthSegment.#ctor(DotSpatial.Topology.ILineSegmentBase,System.Int32)">
             <summary>
            
             </summary>
             <param name="seg"></param>
             <param name="depth"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.SubgraphDepthLocater.DepthSegment.CompareTo(System.Object)">
            <summary>
            Defines a comparision operation on DepthSegments
            which orders them left to right:
            DS1 smaller DS2   if   DS1.seg is left of DS2.seg.
            DS1 bigger  DS2   if   DS1.seg is right of DS2.seg.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Buffer.SubgraphDepthLocater.DepthSegment.CompareX(DotSpatial.Topology.ILineSegmentBase,DotSpatial.Topology.ILineSegmentBase)">
            <summary>
            Compare two collinear segments for left-most ordering.
            If segs are vertical, use vertical ordering for comparison.
            If segs are equal, return 0.
            Segments are assumed to be directed so that the second coordinate is >= to the first
            (e.g. up and to the right).
            </summary>
            <param name="seg0">The left hand side segment to compare.</param>
            <param name="seg1">The riht hand side segment to compare.</param>
            <returns>An integer, -1 if seg0 is less, 0 if they are the same, and 1 if seg0 is greater.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Buffer.SubgraphDepthLocater.DepthSegment.LeftDepth">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Distance.ConnectedElementLocationFilter">
            <summary>
            A ConnectedElementPointFilter extracts a single point
            from each connected element in a Geometry
            (e.g. a polygon, linestring or point)
            and returns them in a list. The elements of the list are
            <c>com.vividsolutions.jts.operation.distance.GeometryLocation</c>s.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.ConnectedElementLocationFilter.#ctor(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="locations"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.ConnectedElementLocationFilter.Filter(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.ConnectedElementLocationFilter.GetLocations(DotSpatial.Topology.IGeometry)">
            <summary>
            Returns a list containing a point from each Polygon, LineString, and Point
            found inside the specified point. Thus, if the specified point is
            not a GeometryCollection, an empty list will be returned. The elements of the list
            are <c>com.vividsolutions.jts.operation.distance.GeometryLocation</c>s.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Distance.ConnectedElementPointFilter">
            <summary>
            Extracts a single point
            from each connected element in a Geometry
            (e.g. a polygon, linestring or point)
            and returns them in a list
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.ConnectedElementPointFilter.#ctor(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="pts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.ConnectedElementPointFilter.Filter(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.ConnectedElementPointFilter.GetCoordinates(DotSpatial.Topology.Geometry)">
            <summary>
            Returns a list containing a Coordinate from each Polygon, LineString, and Point
            found inside the specified point. Thus, if the specified point is
            not a GeometryCollection, an empty list will be returned.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Distance.DistanceOp">
            <summary>
            Computes the distance and
            closest points between two <c>Geometry</c>s.
            The distance computation finds a pair of points in the input geometries
            which have minimum distance between them.  These points may
            not be vertices of the geometries, but may lie in the interior of
            a line segment. In this case the coordinate computed is a close
            approximation to the exact point.
            The algorithms used are straightforward O(n^2)
            comparisons.  This worst-case performance could be improved on
            by using Voronoi techniques.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.#ctor(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
            <summary>
            Constructs a <see cref="T:DotSpatial.Topology.Operation.Distance.DistanceOp"/>  that computes the distance and closest points between
            the two specified geometries.
            </summary>
            <param name="g0"></param>
            <param name="g1"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.#ctor(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry,System.Double)">
            <summary>
            Constructs a <see cref="T:DotSpatial.Topology.Operation.Distance.DistanceOp"/> that computes the distance and closest points between
            the two specified geometries.
            </summary>
            <param name="g0"></param>
            <param name="g1"></param>
            <param name="terminateDistance">The distance on which to terminate the search.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.Distance(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
            <summary>
            Compute the distance between the closest points of two geometries.
            </summary>
            <param name="g0">A <c>Geometry</c>.</param>
            <param name="g1">Another <c>Geometry</c>.</param>
            <returns>The distance between the geometries.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.IsWithinDistance(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry,System.Double)">
            <summary>
            Test whether two geometries lie within a given distance of each other.
            </summary>
            <param name="g0"></param>
            <param name="g1"></param>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ClosestPoints(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
            <summary>
            Compute the the closest points of two geometries.
            The points are presented in the same order as the input Geometries.
            </summary>
            <param name="g0">A <c>Geometry</c>.</param>
            <param name="g1">Another <c>Geometry</c>.</param>
            <returns>The closest points in the geometries.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.Distance">
            <summary>
            Report the distance between the closest points on the input geometries.
            </summary>
            <returns>The distance between the geometries.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ClosestPoints">
            <summary>
            Report the coordinates of the closest points in the input geometries.
            The points are presented in the same order as the input Geometries.
            </summary>
            <returns>A pair of <c>Coordinate</c>s of the closest points.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ClosestLocations">
            <summary>
            Report the locations of the closest points in the input geometries.
            The locations are presented in the same order as the input Geometries.
            </summary>
            <returns>A pair of {GeometryLocation}s for the closest points.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.UpdateMinDistance(DotSpatial.Topology.Operation.Distance.GeometryLocation[],System.Boolean)">
             <summary>
            
             </summary>
             <param name="locGeom"></param>
             <param name="flip"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ComputeMinDistance">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ComputeContainmentDistance">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ComputeInside(System.Collections.IList,System.Collections.IList,DotSpatial.Topology.Operation.Distance.GeometryLocation[])">
             <summary>
            
             </summary>
             <param name="locs"></param>
             <param name="polys"></param>
             <param name="locPtPoly"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ComputeInside(DotSpatial.Topology.Operation.Distance.GeometryLocation,DotSpatial.Topology.IGeometry,DotSpatial.Topology.Operation.Distance.GeometryLocation[])">
             <summary>
            
             </summary>
             <param name="ptLoc"></param>
             <param name="poly"></param>
             <param name="locPtPoly"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ComputeLineDistance">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ComputeMinDistanceLines(System.Collections.IList,System.Collections.IList,DotSpatial.Topology.Operation.Distance.GeometryLocation[])">
             <summary>
            
             </summary>
             <param name="lines0"></param>
             <param name="lines1"></param>
             <param name="locGeom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ComputeMinDistancePoints(System.Collections.IList,System.Collections.IList,DotSpatial.Topology.Operation.Distance.GeometryLocation[])">
             <summary>
            
             </summary>
             <param name="points0"></param>
             <param name="points1"></param>
             <param name="locGeom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ComputeMinDistanceLinesPoints(System.Collections.IList,System.Collections.IList,DotSpatial.Topology.Operation.Distance.GeometryLocation[])">
             <summary>
            
             </summary>
             <param name="lines"></param>
             <param name="points"></param>
             <param name="locGeom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ComputeMinDistance(DotSpatial.Topology.ILineString,DotSpatial.Topology.ILineString,DotSpatial.Topology.Operation.Distance.GeometryLocation[])">
             <summary>
            
             </summary>
             <param name="line0"></param>
             <param name="line1"></param>
             <param name="locGeom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.DistanceOp.ComputeMinDistance(DotSpatial.Topology.ILineString,DotSpatial.Topology.Point,DotSpatial.Topology.Operation.Distance.GeometryLocation[])">
             <summary>
            
             </summary>
             <param name="line"></param>
             <param name="pt"></param>
             <param name="locGeom"></param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Distance.GeometryLocation">
            <summary>
            Represents the location of a point on a Geometry.
            Maintains both the actual point location (which of course
            may not be exact) as well as information about the component
            and segment index where the point occurs.
            Locations inside area Geometrys will not have an associated segment index,
            so in this case the segment index will have the sentinel value of InsideArea.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Distance.GeometryLocation.INSIDE_AREA">
            <summary>
            Special value of segment-index for locations inside area geometries. These
            locations do not have an associated segment index.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.GeometryLocation.#ctor(DotSpatial.Topology.IGeometry,System.Int32,DotSpatial.Topology.Coordinate)">
            <summary>
            Constructs a GeometryLocation specifying a point on a point, as well as the
            segment that the point is on (or InsideArea if the point is not on a segment).
            </summary>
            <param name="component"></param>
            <param name="segIndex"></param>
            <param name="pt"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Distance.GeometryLocation.#ctor(DotSpatial.Topology.IGeometry,DotSpatial.Topology.Coordinate)">
            <summary>
            Constructs a GeometryLocation specifying a point inside an area point.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Distance.GeometryLocation.GeometryComponent">
            <summary>
            Returns the point associated with this location.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Distance.GeometryLocation.SegmentIndex">
            <summary>
            Returns the segment index for this location. If the location is inside an
            area, the index will have the value InsideArea;
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Distance.GeometryLocation.Coordinate">
            <summary>
            Returns the location.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Distance.GeometryLocation.IsInsideArea">
            <summary>
            Returns whether this GeometryLocation represents a point inside an area point.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.GeometryGraphOperation">
            <summary>
            The base class for operations that require <c>GeometryGraph</c>s.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.GeometryGraphOperation.Arg">
            <summary>
            The operation args into an array so they can be accessed by index.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.GeometryGraphOperation.#ctor(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="g0"></param>
             <param name="g1"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.GeometryGraphOperation.#ctor(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="g0"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.GeometryGraphOperation.GetArgGeometry(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.GeometryGraphOperation.LineIntersector">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.GeometryGraphOperation.ResultPrecisionModel">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.GeometryGraphOperation.ComputationPrecision">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.IsSimpleOp">
            <summary>
            Tests whether a <c>Geometry</c> is simple.
            Only <c>Geometry</c>s whose definition allows them
            to be simple or non-simple are tested.  (E.g. Polygons must be simple
            by definition, so no test is provided.  To test whether a given Polygon is valid,
            use <c>Geometry.IsValid</c>)
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.IsSimpleOp.IsSimple(DotSpatial.Topology.LineString)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.IsSimpleOp.IsSimple(DotSpatial.Topology.MultiLineString)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.IsSimpleOp.IsSimple(DotSpatial.Topology.MultiPoint)">
            <summary>
            A MultiPoint is simple if it has no repeated points.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.IsSimpleOp.IsSimpleLinearGeometry(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.IsSimpleOp.HasNonEndpointIntersection(DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            For all edges, check if there are any intersections which are NOT at an endpoint.
            The Geometry is not simple if there are intersections not at endpoints.
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.IsSimpleOp.HasClosedEndpointIntersection(DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Test that no edge intersection is the
            endpoint of a closed line.  To check this we compute the
            degree of each endpoint. The degree of endpoints of closed lines
            must be exactly 2.
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.IsSimpleOp.AddEndpoint(System.Collections.IDictionary,DotSpatial.Topology.Coordinate,System.Boolean)">
            <summary>
            Add an endpoint to the map, creating an entry for it if none exists.
            </summary>
            <param name="endPoints"></param>
            <param name="p"></param>
            <param name="isClosed"></param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.IsSimpleOp.EndpointInfo">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.IsSimpleOp.EndpointInfo.#ctor(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="pt"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.IsSimpleOp.EndpointInfo.AddEndpoint(System.Boolean)">
             <summary>
            
             </summary>
             <param name="isClosed"></param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.IsSimpleOp.EndpointInfo.Point">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.IsSimpleOp.EndpointInfo.IsClosed">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.IsSimpleOp.EndpointInfo.Degree">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Linemerge.EdgeString">
            <summary>
            A sequence of <c>LineMergeDirectedEdge</c>s forming one of the lines that will
            be output by the line-merging process.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.EdgeString.#ctor(DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Constructs an EdgeString with the given factory used to convert this EdgeString
            to a LineString.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.EdgeString.Add(DotSpatial.Topology.Operation.Linemerge.LineMergeDirectedEdge)">
            <summary>
            Adds a directed edge which is known to form part of this line.
            </summary>
            <param name="directedEdge"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.EdgeString.ToLineString">
            <summary>
            Converts this EdgeString into a LineString.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Linemerge.EdgeString.Coordinates">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Linemerge.LineMergeDirectedEdge">
            <summary>
            A <c>com.vividsolutions.jts.planargraph.DirectedEdge</c> of a <c>LineMergeGraph</c>.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Planargraph.DirectedEdge">
            <summary>
            Represents a directed edge in a <c>PlanarGraph</c>. A DirectedEdge may or
            may not have a reference to a parent Edge (some applications of
            planar graphs may not require explicit Edge objects to be created). Usually
            a client using a <c>PlanarGraph</c> will subclass <c>DirectedEdge</c>
            to add its own application-specific data and methods.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Planargraph.GraphComponent">
            <summary>
            The base class for all graph component classes.
            Maintains flags of use in generic graph algorithms.
            Provides two flags:
            marked - typically this is used to indicate a state that persists
            for the course of the graph's lifetime.  For instance, it can be
            used to indicate that a component has been logically deleted from the graph.
            visited - this is used to indicate that a component has been processed
            or visited by an single graph algorithm.  For instance, a breadth-first traversal of the
            graph might use this to indicate that a node has already been traversed.
            The visited flag may be set and cleared many times during the lifetime of a graph.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.GraphComponent.SetVisited(System.Collections.IEnumerator,System.Boolean)">
            <summary>
            Sets the <see cref="P:DotSpatial.Topology.Planargraph.GraphComponent.IsVisited"/> state
            for all <see cref="T:DotSpatial.Topology.Planargraph.GraphComponent"/>s in an <see cref="T:System.Collections.IEnumerator"/>.
            </summary>
            <param name="i">A <see cref="T:System.Collections.IEnumerator"/> to scan.</param>
            <param name="visited">The state to set the <see cref="P:DotSpatial.Topology.Planargraph.GraphComponent.IsVisited"/> flag to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.GraphComponent.SetMarked(System.Collections.IEnumerator,System.Boolean)">
            <summary>
            Sets the <see cref="P:DotSpatial.Topology.Planargraph.GraphComponent.IsMarked"/> state
            for all <see cref="T:DotSpatial.Topology.Planargraph.GraphComponent"/>s in an <see cref="T:System.Collections.IEnumerator"/>.
            </summary>
            <param name="i">A <see cref="T:System.Collections.IEnumerator"/> to scan.</param>
            <param name="marked">The state to set the <see cref="P:DotSpatial.Topology.Planargraph.GraphComponent.IsMarked"/> flag to.</param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.GraphComponent.GetComponentWithVisitedState(System.Collections.IEnumerator,System.Boolean)">
            <summary>
            Finds the first <see cref="T:DotSpatial.Topology.Planargraph.GraphComponent"/>
            in a <see cref="T:System.Collections.IEnumerator"/> set
            which has the specified <see cref="P:DotSpatial.Topology.Planargraph.GraphComponent.IsVisited"/> state.
            </summary>
            <param name="i">A <see cref="T:System.Collections.IEnumerator"/> to scan.</param>
            <param name="visitedState">The <see cref="P:DotSpatial.Topology.Planargraph.GraphComponent.IsVisited"/> state to test.</param>
            <returns>The first <see cref="T:DotSpatial.Topology.Planargraph.GraphComponent"/> found, or <c>null</c> if none found.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.GraphComponent.IsVisited">
            <summary>
            Tests if a component has been visited during the course of a graph algorithm.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.GraphComponent.IsMarked">
            <summary>
            Tests if a component has been marked at some point during the processing
            involving this graph.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.GraphComponent.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdge.#ctor(DotSpatial.Topology.Planargraph.Node,DotSpatial.Topology.Planargraph.Node,DotSpatial.Topology.Coordinate,System.Boolean)">
            <summary>
            Constructs a DirectedEdge connecting the <c>from</c> node to the
            <c>to</c> node.
            </summary>
            <param name="inFrom"></param>
            <param name="inTo"></param>
            <param name="directionPt">
            Specifies this DirectedEdge's direction (given by an imaginary
            line from the <c>from</c> node to <c>directionPt</c>).
            </param>
            <param name="inEdgeDirection">
            Whether this DirectedEdge's direction is the same as or
            opposite to that of the parent Edge (if any).
            </param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdge.CompareTo(System.Object)">
            <summary>
            Returns 1 if this DirectedEdge has a greater angle with the
            positive x-axis than b", 0 if the DirectedEdges are collinear, and -1 otherwise.
            Using the obvious algorithm of simply computing the angle is not robust,
            since the angle calculation is susceptible to roundoff. A robust algorithm
            is:
            first compare the quadrants. If the quadrants are different, it it
            trivial to determine which vector is "greater".
            if the vectors lie in the same quadrant, the robust
            <c>RobustCgAlgorithms.ComputeOrientation(Coordinate, Coordinate, Coordinate)</c>
            function can be used to decide the relative orientation of the vectors.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdge.ToEdges(System.Collections.IList)">
            <summary>
            Returns a List containing the parent Edge (possibly null) for each of the given
            DirectedEdges.
            </summary>
            <param name="dirEdges"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdge.CompareDirection(DotSpatial.Topology.Planargraph.DirectedEdge)">
            <summary>
            Returns 1 if this DirectedEdge has a greater angle with the
            positive x-axis than b", 0 if the DirectedEdges are collinear, and -1 otherwise.
            Using the obvious algorithm of simply computing the angle is not robust,
            since the angle calculation is susceptible to roundoff. A robust algorithm
            is:
            first compare the quadrants. If the quadrants are different, it it
            trivial to determine which vector is "greater".
            if the vectors lie in the same quadrant, the robust
            <c>RobustCgAlgorithms.ComputeOrientation(Coordinate, Coordinate, Coordinate)</c>
            function can be used to decide the relative orientation of the vectors.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdge.Write(System.IO.StreamWriter)">
            <summary>
            Writes a detailed string representation of this DirectedEdge to the given PrintStream.
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdge.Remove">
            <summary>
            Removes this directed edge from its containing graph.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdge.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdge.Edge">
            <summary>
            Returns this DirectedEdge's parent Edge, or null if it has none.
            Associates this DirectedEdge with an Edge (possibly null, indicating no associated
            Edge).
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdge.Quadrant">
            <summary>
            Returns 0, 1, 2, or 3, indicating the quadrant in which this DirectedEdge's
            orientation lies.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdge.StartPoint">
            <summary>
            returns a point representing the starting point for a line being drawn
            in order to indicate the directed edges vector direction.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdge.EndPoint">
            <summary>
            Returns a point to which an imaginary line is drawn from the from-node to
            specify this DirectedEdge's orientation.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdge.EdgeDirection">
            <summary>
            Returns whether the direction of the parent Edge (if any) is the same as that
            of this Directed Edge.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdge.FromNode">
            <summary>
            Returns the node from which this DirectedEdge leaves.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdge.ToNode">
            <summary>
            Returns the node to which this DirectedEdge goes.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdge.Coordinate">
            <summary>
            Returns the coordinate of the from-node.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdge.Angle">
            <summary>
            Returns the angle that the start of this DirectedEdge makes with the
            positive x-axis, in radians.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdge.Sym">
            <summary>
            Returns the symmetric DirectedEdge -- the other DirectedEdge associated with
            this DirectedEdge's parent Edge.
            Sets this DirectedEdge's symmetric DirectedEdge, which runs in the opposite
            direction.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdge.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
            <value></value>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMergeDirectedEdge.#ctor(DotSpatial.Topology.Planargraph.Node,DotSpatial.Topology.Planargraph.Node,DotSpatial.Topology.Coordinate,System.Boolean)">
            <summary>
            Constructs a LineMergeDirectedEdge connecting the <c>from</c> node to the <c>to</c> node.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="directionPt">
            specifies this DirectedEdge's direction (given by an imaginary
            line from the <c>from</c> node to <c>directionPt</c>).
            </param>
            <param name="edgeDirection">
            whether this DirectedEdge's direction is the same as or
            opposite to that of the parent Edge (if any).
            </param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Linemerge.LineMergeDirectedEdge.Next">
            <summary>
            Returns the directed edge that starts at this directed edge's end point, or null
            if there are zero or multiple directed edges starting there.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Linemerge.LineMergeEdge">
            <summary>
            An edge of a <c>LineMergeGraph</c>. The <c>marked</c> field indicates
            whether this Edge has been logically deleted from the graph.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Planargraph.Edge">
            <summary>
            Represents an undirected edge of a {PlanarGraph}. An undirected edge
            in fact simply acts as a central point of reference for two opposite
            <c>DirectedEdge</c>s.
            Usually a client using a <c>PlanarGraph</c> will subclass <c>Edge</c>
            to add its own application-specific data and methods.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Edge.#ctor">
            <summary>
            Constructs an Edge whose DirectedEdges are not yet set. Be sure to call
            <c>SetDirectedEdges(DirectedEdge, DirectedEdge)</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Edge.#ctor(DotSpatial.Topology.Planargraph.DirectedEdge,DotSpatial.Topology.Planargraph.DirectedEdge)">
            <summary>
            Constructs an Edge initialized with the given DirectedEdges, and for each
            DirectedEdge: sets the Edge, sets the symmetric DirectedEdge, and adds
            this Edge to its from-Node.
            </summary>
            <param name="de0"></param>
            <param name="de1"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Edge.SetDirectedEdges(DotSpatial.Topology.Planargraph.DirectedEdge,DotSpatial.Topology.Planargraph.DirectedEdge)">
            <summary>
            Initializes this Edge's two DirectedEdges, and for each DirectedEdge: sets the
            Edge, sets the symmetric DirectedEdge, and adds this Edge to its from-Node.
            </summary>
            <param name="de0"></param>
            <param name="de1"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Edge.GetDirEdge(System.Int32)">
            <summary>
            Returns one of the DirectedEdges associated with this Edge.
            </summary>
            <param name="i">0 or 1.</param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Edge.GetDirEdge(DotSpatial.Topology.Planargraph.Node)">
            <summary>
            Returns the DirectedEdge that starts from the given node, or null if the
            node is not one of the two nodes associated with this Edge.
            </summary>
            <param name="fromNode"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Edge.GetOppositeNode(DotSpatial.Topology.Planargraph.Node)">
            <summary>
            If <c>node</c> is one of the two nodes associated with this Edge,
            returns the other node; otherwise returns null.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Edge.Remove">
            <summary>
            Removes this edge from its containing graph.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.Edge.DirEdge">
            <summary>
            The two DirectedEdges associated with this Edge.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.Edge.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
            <value></value>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.Edge.IsVisited">
            <summary>
            The line sequencer class seems to need to se this directly
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMergeEdge.#ctor(DotSpatial.Topology.LineString)">
            <summary>
            Constructs a LineMergeEdge with vertices given by the specified LineString.
            </summary>
            <param name="line"></param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Linemerge.LineMergeEdge.Line">
            <summary>
            Returns the LineString specifying the vertices of this edge.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Linemerge.LineMergeGraph">
            <summary>
            A planar graph of edges that is analyzed to sew the edges together. The
            <c>marked</c> flag on <c>com.vividsolutions.planargraph.Edge</c>s
            and <c>com.vividsolutions.planargraph.Node</c>s indicates whether they have been
            logically deleted from the graph.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Planargraph.PlanarGraph">
            <summary>
            Represents a directed graph which is embeddable in a planar surface.
            This class and the other classes in this package serve as a framework for
            building planar graphs for specific algorithms. This class must be
            subclassed to expose appropriate methods to construct the graph. This allows
            controlling the types of graph components ({DirectedEdge}s,
            <c>Edge</c>s and <c>Node</c>s) which can be added to the graph. An
            application which uses the graph framework will almost always provide
            subclasses for one or more graph components, which hold application-specific
            data and graph algorithms.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.PlanarGraph.FindNode(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns the Node at the given location, or null if no Node was there.
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.PlanarGraph.Add(DotSpatial.Topology.Planargraph.Node)">
            <summary>
            Adds a node to the map, replacing any that is already at that location.
            Only subclasses can add Nodes, to ensure Nodes are of the right type.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.PlanarGraph.Add(DotSpatial.Topology.Planargraph.Edge)">
            <summary>
            Adds the Edge and its DirectedEdges with this PlanarGraph.
            Assumes that the Edge has already been created with its associated DirectEdges.
            Only subclasses can add Edges, to ensure the edges added are of the right class.
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.PlanarGraph.Add(DotSpatial.Topology.Planargraph.DirectedEdge)">
            <summary>
            Adds the Edge to this PlanarGraph; only subclasses can add DirectedEdges,
            to ensure the edges added are of the right class.
            </summary>
            <param name="dirEdge"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.PlanarGraph.GetNodeEnumerator">
            <summary>
            Returns an IEnumerator over the Nodes in this PlanarGraph.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.PlanarGraph.GetDirEdgeEnumerator">
            <summary>
            Returns an Iterator over the DirectedEdges in this PlanarGraph, in the order in which they
            were added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.PlanarGraph.GetEdgeEnumerator">
            <summary>
            Returns an Iterator over the Edges in this PlanarGraph, in the order in which they
            were added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.PlanarGraph.Remove(DotSpatial.Topology.Planargraph.Edge)">
            <summary>
            Removes an Edge and its associated DirectedEdges from their from-Nodes and
            from this PlanarGraph. Notice: This method does not remove the Nodes associated
            with the Edge, even if the removal of the Edge reduces the degree of a
            Node to zero.
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.PlanarGraph.Remove(DotSpatial.Topology.Planargraph.DirectedEdge)">
            <summary>
            Removes DirectedEdge from its from-Node and from this PlanarGraph. Notice:
            This method does not remove the Nodes associated with the DirectedEdge,
            even if the removal of the DirectedEdge reduces the degree of a Node to
            zero.
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.PlanarGraph.Remove(DotSpatial.Topology.Planargraph.Node)">
            <summary>
            Removes a node from the graph, along with any associated DirectedEdges and
            Edges.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.PlanarGraph.FindNodesOfDegree(System.Int32)">
            <summary>
            Returns all Nodes with the given number of Edges around it.
            </summary>
            <param name="degree"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.PlanarGraph.DirectedEdges">
            <summary>
            Gets or sets the IList of directed edges
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.PlanarGraph.Nodes">
            <summary>
            Returns the Nodes in this PlanarGraph.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.PlanarGraph.Edges">
            <summary>
            Returns the Edges that have been added to this PlanarGraph.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMergeGraph.AddEdge(DotSpatial.Topology.LineString)">
            <summary>
            Adds an Edge, DirectedEdges, and Nodes for the given LineString representation
            of an edge.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMergeGraph.GetNode(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="coordinate"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Linemerge.LineMerger">
            <summary>
            Sews together a set of fully noded LineStrings. Sewing stops at nodes of degree 1
            or 3 or more -- the exception is an isolated loop, which only has degree-2 nodes,
            in which case a node is simply chosen as a starting point. The direction of each
            merged LineString will be that of the majority of the LineStrings from which it
            was derived.
            Any dimension of Geometry is handled -- the constituent linework is extracted to
            form the edges. The edges must be correctly noded; that is, they must only meet
            at their endpoints.  The LineMerger will still run on incorrectly noded input
            but will not form polygons from incorrected noded edges.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMerger.Add(System.Collections.IList)">
            <summary>
            Adds a collection of Geometries to be processed. May be called multiple times.
            Any dimension of Geometry may be added; the constituent linework will be
            extracted.
            </summary>
            <param name="geometries"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMerger.Add(DotSpatial.Topology.Geometry)">
            <summary>
            Adds a Geometry to be processed. May be called multiple times.
            Any dimension of Geometry may be added; the constituent linework will be
            extracted.
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMerger.Add(DotSpatial.Topology.LineString)">
             <summary>
            
             </summary>
             <param name="lineString"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMerger.Merge">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMerger.BuildEdgeStringsForObviousStartNodes">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMerger.BuildEdgeStringsForIsolatedLoops">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMerger.BuildEdgeStringsForUnprocessedNodes">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMerger.BuildEdgeStringsForNonDegree2Nodes">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMerger.BuildEdgeStringsStartingAt(DotSpatial.Topology.Planargraph.Node)">
             <summary>
            
             </summary>
             <param name="node"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMerger.BuildEdgeStringStartingWith(DotSpatial.Topology.Operation.Linemerge.LineMergeDirectedEdge)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Linemerge.LineMerger.MergedLineStrings">
            <summary>
            Returns the LineStrings built by the merging process.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Linemerge.LineMerger.AnonymousGeometryComponentFilterImpl">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMerger.AnonymousGeometryComponentFilterImpl.#ctor(DotSpatial.Topology.Operation.Linemerge.LineMerger)">
             <summary>
            
             </summary>
             <param name="container"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Linemerge.LineMerger.AnonymousGeometryComponentFilterImpl.Filter(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="component"></param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Overlay.EdgeSetNoder">
            <summary>
            Nodes a set of edges.
            Takes one or more sets of edges and constructs a
            new set of edges consisting of all the split edges created by
            noding the input edges together.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.EdgeSetNoder.#ctor(DotSpatial.Topology.Algorithm.LineIntersector)">
             <summary>
            
             </summary>
             <param name="li"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.EdgeSetNoder.AddEdges(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="edges"></param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Overlay.EdgeSetNoder.NodedEdges">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Overlay.LineBuilder">
            <summary>
            Forms NTS LineStrings out of a the graph of <c>DirectedEdge</c>s
            created by an <c>OverlayOp</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.LineBuilder.#ctor(DotSpatial.Topology.Operation.Overlay.OverlayOp,DotSpatial.Topology.IGeometryFactory,DotSpatial.Topology.Algorithm.PointLocator)">
             <summary>
            
             </summary>
             <param name="op"></param>
             <param name="geometryFactory"></param>
             <param name="ptLocator"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.LineBuilder.Build(DotSpatial.Topology.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="opCode"></param>
             <returns>
             A list of the LineStrings in the result of the specified overlay operation.
             </returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.LineBuilder.FindCoveredLineEdges">
            <summary>
            Find and mark L edges which are "covered" by the result area (if any).
            L edges at nodes which also have A edges can be checked by checking
            their depth at that node.
            L edges at nodes which do not have A edges can be checked by doing a
            point-in-polygon test with the previously computed result areas.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.LineBuilder.CollectLines(DotSpatial.Topology.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="opCode"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.LineBuilder.CollectLineEdge(DotSpatial.Topology.GeometriesGraph.DirectedEdge,DotSpatial.Topology.Operation.Overlay.SpatialFunction,System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <param name="opCode"></param>
             <param name="edges"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.LineBuilder.CollectBoundaryTouchEdge(DotSpatial.Topology.GeometriesGraph.DirectedEdge,DotSpatial.Topology.Operation.Overlay.SpatialFunction,System.Collections.IList)">
            <summary>
            Collect edges from Area inputs which should be in the result but
            which have not been included in a result area.
            This happens ONLY:
            during an intersection when the boundaries of two
            areas touch in a line segment
            OR as a result of a dimensional collapse.
            </summary>
            <param name="de"></param>
            <param name="opCode"></param>
            <param name="edges"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.LineBuilder.BuildLines(DotSpatial.Topology.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="opCode"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.LineBuilder.LabelIsolatedLines(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="edgesList"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.LineBuilder.LabelIsolatedLine(DotSpatial.Topology.GeometriesGraph.Edge,System.Int32)">
            <summary>
            Label an isolated node with its relationship to the target point.
            </summary>
            <param name="e"></param>
            <param name="targetIndex"></param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Overlay.MaximalEdgeRing">
            <summary>
            A ring of edges which may contain nodes of degree > 2.
            A MaximalEdgeRing may represent two different spatial entities:
            a single polygon possibly containing inversions (if the ring is oriented CW)
            a single hole possibly containing exversions (if the ring is oriented CCW)
            If the MaximalEdgeRing represents a polygon,
            the interior of the polygon is strongly connected.
            These are the form of rings used to define polygons under some spatial data models.
            However, under the OGC SFS model, MinimalEdgeRings are required.
            A MaximalEdgeRing can be converted to a list of MinimalEdgeRings using the
            <c>BuildMinimalRings()</c> method.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.MaximalEdgeRing.#ctor(DotSpatial.Topology.GeometriesGraph.DirectedEdge,DotSpatial.Topology.IGeometryFactory)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <param name="geometryFactory"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.MaximalEdgeRing.GetNext(DotSpatial.Topology.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.MaximalEdgeRing.SetEdgeRing(DotSpatial.Topology.GeometriesGraph.DirectedEdge,DotSpatial.Topology.GeometriesGraph.EdgeRing)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <param name="er"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.MaximalEdgeRing.LinkDirectedEdgesForMinimalEdgeRings">
            <summary>
            For all nodes in this EdgeRing,
            link the DirectedEdges at the node to form minimalEdgeRings
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.MaximalEdgeRing.BuildMinimalRings">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Overlay.MinimalEdgeRing">
            <summary>
            A ring of edges with the property that no node
            has degree greater than 2.  These are the form of rings required
            to represent polygons under the OGC SFS spatial data model.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.MinimalEdgeRing.#ctor(DotSpatial.Topology.GeometriesGraph.DirectedEdge,DotSpatial.Topology.IGeometryFactory)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <param name="geometryFactory"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.MinimalEdgeRing.GetNext(DotSpatial.Topology.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.MinimalEdgeRing.SetEdgeRing(DotSpatial.Topology.GeometriesGraph.DirectedEdge,DotSpatial.Topology.GeometriesGraph.EdgeRing)">
             <summary>
            
             </summary>
             <param name="de"></param>
             <param name="er"></param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Overlay.OverlayNodeFactory">
            <summary>
            Creates nodes for use in the <c>PlanarGraph</c>s constructed during
            overlay operations.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayNodeFactory.CreateNode(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Overlay.SpatialFunction">
            <summary>
            The spatial functions supported by this class.
            These operations implement various bool combinations of the resultants of the overlay.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Overlay.SpatialFunction.Intersection">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Overlay.SpatialFunction.Union">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Overlay.SpatialFunction.Difference">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Overlay.SpatialFunction.SymDifference">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Overlay.OverlayOp">
            <summary>
            Computes the overlay of two <c>Geometry</c>s.  The overlay
            can be used to determine any bool combination of the geometries.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.#ctor(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="g0"></param>
             <param name="g1"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.Overlay(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry,DotSpatial.Topology.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="geom0"></param>
             <param name="geom1"></param>
             <param name="opCode"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.IsResultOfOp(DotSpatial.Topology.GeometriesGraph.Label,DotSpatial.Topology.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="label"></param>
             <param name="opCode"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.IsResultOfOp(DotSpatial.Topology.LocationType,DotSpatial.Topology.LocationType,DotSpatial.Topology.Operation.Overlay.SpatialFunction)">
            <summary>
            This method will handle arguments of Location.NULL correctly.
            </summary>
            <returns><c>true</c> if the locations correspond to the opCode.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.GetResultGeometry(DotSpatial.Topology.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="funcCode"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.ComputeOverlay(DotSpatial.Topology.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="opCode"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.InsertUniqueEdges(System.Collections.IEnumerable)">
             <summary>
            
             </summary>
             <param name="edges"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.InsertUniqueEdge(DotSpatial.Topology.GeometriesGraph.Edge)">
            <summary>
            Insert an edge from one of the noded input graphs.
            Checks edges that are inserted to see if an
            identical edge already exists.
            If so, the edge is not inserted, but its label is merged
            with the existing edge.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.ComputeLabelsFromDepths">
            <summary>
            Update the labels for edges according to their depths.
            For each edge, the depths are first normalized.
            Then, if the depths for the edge are equal,
            this edge must have collapsed into a line edge.
            If the depths are not equal, update the label
            with the locations corresponding to the depths
            (i.e. a depth of 0 corresponds to a Location of Exterior,
            a depth of 1 corresponds to Interior)
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.ReplaceCollapsedEdges">
            <summary>
            If edges which have undergone dimensional collapse are found,
            replace them with a new edge which is a L edge
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.CopyPoints(System.Int32)">
            <summary>
            Copy all nodes from an arg point into this graph.
            The node label in the arg point overrides any previously computed
            label for that argIndex.
            (E.g. a node may be an intersection node with
            a previously computed label of Boundary,
            but in the original arg Geometry it is actually
            in the interior due to the Boundary Determination Rule)
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.ComputeLabelling">
            <summary>
            Compute initial labelling for all DirectedEdges at each node.
            In this step, DirectedEdges will acquire a complete labelling
            (i.e. one with labels for both Geometries)
            only if they
            are incident on a node which has edges for both Geometries
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.MergeSymLabels">
            <summary>
            For nodes which have edges from only one Geometry incident on them,
            the previous step will have left their dirEdges with no labelling for the other
            Geometry.  However, the sym dirEdge may have a labelling for the other
            Geometry, so merge the two labels.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.UpdateNodeLabelling">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.LabelIncompleteNodes">
            <summary>
            Incomplete nodes are nodes whose labels are incomplete.
            (e.g. the location for one Geometry is null).
            These are either isolated nodes,
            or nodes which have edges from only a single Geometry incident on them.
            Isolated nodes are found because nodes in one graph which don't intersect
            nodes in the other are not completely labelled by the initial process
            of adding nodes to the nodeList.
            To complete the labelling we need to check for nodes that lie in the
            interior of edges, and in the interior of areas.
            When each node labelling is completed, the labelling of the incident
            edges is updated, to complete their labelling as well.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.LabelIncompleteNode(DotSpatial.Topology.GeometriesGraph.Node,System.Int32)">
            <summary>
            Label an isolated node with its relationship to the target point.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.FindResultAreaEdges(DotSpatial.Topology.Operation.Overlay.SpatialFunction)">
            <summary>
            Find all edges whose label indicates that they are in the result area(s),
            according to the operation being performed.  Since we want polygon shells to be
            oriented CW, choose dirEdges with the interior of the result on the RHS.
            Mark them as being in the result.
            Interior Area edges are the result of dimensional collapses.
            They do not form part of the result area boundary.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.CancelDuplicateResultEdges">
            <summary>
            If both a dirEdge and its sym are marked as being in the result, cancel
            them out.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.IsCoveredByLa(DotSpatial.Topology.Coordinate)">
            <summary>
            This method is used to decide if a point node should be included in the result or not.
            </summary>
            <returns><c>true</c> if the coord point is covered by a result Line or Area point.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.IsCoveredByA(DotSpatial.Topology.Coordinate)">
            <summary>
            This method is used to decide if an L edge should be included in the result or not.
            </summary>
            <returns><c>true</c> if the coord point is covered by a result Area point.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.IsCovered(DotSpatial.Topology.Coordinate,System.Collections.IEnumerable)">
            <returns>
            <c>true</c> if the coord is located in the interior or boundary of
            a point in the list.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.OverlayOp.ComputeGeometry(System.Collections.IList,System.Collections.IList,System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="resultPointList"></param>
             <param name="resultLineList"></param>
             <param name="resultPolyList"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Overlay.OverlayOp.Graph">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Overlay.PointBuilder">
            <summary>
            Constructs <c>Point</c>s from the nodes of an overlay graph.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PointBuilder.#ctor(DotSpatial.Topology.Operation.Overlay.OverlayOp,DotSpatial.Topology.IGeometryFactory)">
             <summary>
            
             </summary>
             <param name="op"></param>
             <param name="geometryFactory"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PointBuilder.Build(DotSpatial.Topology.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="opCode"></param>
             <returns>
             A list of the Points in the result of the specified overlay operation.
             </returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PointBuilder.CollectNodes(DotSpatial.Topology.Operation.Overlay.SpatialFunction)">
             <summary>
            
             </summary>
             <param name="opCode"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PointBuilder.SimplifyPoints(System.Collections.IEnumerable)">
            <summary>
            This method simplifies the resultant Geometry by finding and eliminating
            "covered" points.
            A point is covered if it is contained in another element Geometry
            with higher dimension (e.g. a point might be contained in a polygon,
            in which case the point can be eliminated from the resultant).
            </summary>
            <param name="resultNodeList"></param>
            <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Overlay.PolygonBuilder">
            <summary>
            Forms <c>Polygon</c>s out of a graph of {DirectedEdge}s.
            The edges to use are marked as being in the result Area.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.#ctor(DotSpatial.Topology.IGeometryFactory)">
             <summary>
            
             </summary>
             <param name="geometryFactory"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.Add(DotSpatial.Topology.GeometriesGraph.PlanarGraph)">
            <summary>
            Add a complete graph.
            The graph is assumed to contain one or more polygons,
            possibly with holes.
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.Add(System.Collections.IList,System.Collections.IList)">
            <summary>
            Add a set of edges and nodes, which form a graph.
            The graph is assumed to contain one or more polygons,
            possibly with holes.
            </summary>
            <param name="dirEdges"></param>
            <param name="nodes"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.BuildMaximalEdgeRings(System.Collections.IEnumerable)">
            <summary>
            For all DirectedEdges in result, form them into MaximalEdgeRings.
            </summary>
            <param name="dirEdges"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.BuildMinimalEdgeRings(System.Collections.IEnumerable,System.Collections.IList,System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="maxEdgeRings"></param>
             <param name="shellList"></param>
             <param name="freeHoleList"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.FindShell(System.Collections.IEnumerable)">
            <summary>
            This method takes a list of MinimalEdgeRings derived from a MaximalEdgeRing,
            and tests whether they form a Polygon.  This is the case if there is a single shell
            in the list.  In this case the shell is returned.
            The other possibility is that they are a series of connected holes, in which case
            no shell is returned.
            </summary>
            <returns>The shell EdgeRing, if there is one.</returns>
            <returns><c>null</c>, if all the rings are holes.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.PlacePolygonHoles(DotSpatial.Topology.GeometriesGraph.EdgeRing,System.Collections.IEnumerable)">
            <summary>
            This method assigns the holes for a Polygon (formed from a list of
            MinimalEdgeRings) to its shell.
            Determining the holes for a MinimalEdgeRing polygon serves two purposes:
            it is faster than using a point-in-polygon check later on.
            it ensures correctness, since if the PIP test was used the point
            chosen might lie on the shell, which might return an incorrect result from the
            PIP test.
            </summary>
            <param name="shell"></param>
            <param name="minEdgeRings"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.SortShellsAndHoles(System.Collections.IEnumerable,System.Collections.IList,System.Collections.IList)">
            <summary>
            For all rings in the input list,
            determine whether the ring is a shell or a hole
            and add it to the appropriate list.
            Due to the way the DirectedEdges were linked,
            a ring is a shell if it is oriented CW, a hole otherwise.
            </summary>
            <param name="edgeRings"></param>
            <param name="shellList"></param>
            <param name="freeHoleList"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.PlaceFreeHoles(System.Collections.IEnumerable,System.Collections.IEnumerable)">
            <summary>
            This method determines finds a containing shell for all holes
            which have not yet been assigned to a shell.
            These "free" holes should
            all be properly contained in their parent shells, so it is safe to use the
            <c>findEdgeRingContaining</c> method.
            (This is the case because any holes which are NOT
            properly contained (i.e. are connected to their
            parent shell) would have formed part of a MaximalEdgeRing
            and been handled in a previous step).
            </summary>
            <param name="shellList"></param>
            <param name="freeHoleList"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.FindEdgeRingContaining(DotSpatial.Topology.GeometriesGraph.EdgeRing,System.Collections.IEnumerable)">
            <summary>
            Find the innermost enclosing shell EdgeRing containing the argument EdgeRing, if any.
            The innermost enclosing ring is the <i>smallest</i> enclosing ring.
            The algorithm used depends on the fact that:
            ring A contains ring B iff envelope(ring A) contains envelope(ring B).
            This routine is only safe to use if the chosen point of the hole
            is known to be properly contained in a shell
            (which is guaranteed to be the case if the hole does not touch its shell).
            </summary>
            <param name="testEr"></param>
            <param name="shellList"></param>
            <returns>Containing EdgeRing, if there is one, OR
            null if no containing EdgeRing is found.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.ComputePolygons(System.Collections.IEnumerable)">
             <summary>
            
             </summary>
             <param name="shellList"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.ContainsPoint(DotSpatial.Topology.Coordinate)">
            <summary>
            Checks the current set of shells (with their associated holes) to
            see if any of them contain the point.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Overlay.PolygonBuilder.Polygons">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Polygonize.DuplicateEdgeException">
            <summary>
            This exception occurs when the same directed edge appears more than once in the same list
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.DuplicateEdgeException.#ctor">
            <summary>
            Creates a new instance of the Duplicate Edge Exception
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Polygonize.EdgeRing">
            <summary>
            Represents a ring of <c>PolygonizeDirectedEdge</c>s which form
            a ring of a polygon.  The ring may be either an outer shell or a hole.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.EdgeRing.#ctor(DotSpatial.Topology.IGeometryFactory)">
             <summary>
            
             </summary>
             <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.EdgeRing.FindEdgeRingContaining(DotSpatial.Topology.Operation.Polygonize.EdgeRing,System.Collections.IList)">
            <summary>
            Find the innermost enclosing shell EdgeRing containing the argument EdgeRing, if any.
            The innermost enclosing ring is the <i>smallest</i> enclosing ring.
            The algorithm used depends on the fact that:
            ring A contains ring B iff envelope(ring A) contains envelope(ring B).
            This routine is only safe to use if the chosen point of the hole
            is known to be properly contained in a shell
            (which is guaranteed to be the case if the hole does not touch its shell).
            </summary>
            <param name="testEr">The EdgeRing to test.</param>
            <param name="shellList">The list of shells to test.</param>
            <returns>Containing EdgeRing, if there is one, OR
            null if no containing EdgeRing is found.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.EdgeRing.PtNotInList(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Finds a point in a list of points which is not contained in another list of points.
            </summary>
            <param name="testPts">The <c>Coordinate</c>s to test.</param>
            <param name="pts">An array of <c>Coordinate</c>s to test the input points against.</param>
            <returns>A <c>Coordinate</c> from <c>testPts</c> which is not in <c>pts</c>,
            or <c>null</c>.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.EdgeRing.IsInList(DotSpatial.Topology.Coordinate,System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
            <summary>
            Tests whether a given point is in an array of points.
            Uses a value-based test.
            </summary>
            <param name="pt">A <c>Coordinate</c> for the test point.</param>
            <param name="pts">An array of <c>Coordinate</c>s to test,</param>
            <returns><c>true</c> if the point is in the array.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.EdgeRing.Add(DotSpatial.Topology.Planargraph.DirectedEdge)">
            <summary>
            Adds a DirectedEdge which is known to form part of this ring.
            </summary>
            <param name="de">The DirectedEdge to add.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.EdgeRing.AddHole(DotSpatial.Topology.ILinearRing)">
            <summary>
            Adds a hole to the polygon formed by this ring.
            </summary>
            <param name="hole">The LinearRing forming the hole.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.EdgeRing.AddEdge(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Boolean,DotSpatial.Topology.CoordinateList)">
             <summary>
            
             </summary>
             <param name="coords"></param>
             <param name="isForward"></param>
             <param name="coordList"></param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.EdgeRing.IsHole">
            <summary>
            Tests whether this ring is a hole.
            Due to the way the edges in the polyongization graph are linked,
            a ring is a hole if it is oriented counter-clockwise.
            </summary>
            <returns><c>true</c> if this ring is a hole.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.EdgeRing.Polygon">
            <summary>
            Computes and returns the Polygon formed by this ring and any contained holes.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.EdgeRing.IsValid">
            <summary>
            Tests if the LinearRing ring formed by this edge ring is topologically valid.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.EdgeRing.Coordinates">
            <summary>
            Computes and returns the list of coordinates which are contained in this ring.
            The coordinatea are computed once only and cached.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.EdgeRing.LineString">
            <summary>
            Gets the coordinates for this ring as a <c>LineString</c>.
            Used to return the coordinates in this ring
            as a valid point, when it has been detected that the ring is topologically
            invalid.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.EdgeRing.Ring">
            <summary>
            Returns this ring as a LinearRing, or null if an Exception occurs while
            creating it (such as a topology problem). Details of problems are written to
            standard output.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Polygonize.LineStringAdder">
            <summary>
            Add every linear element in a point into the polygonizer graph.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.LineStringAdder.#ctor(DotSpatial.Topology.Operation.Polygonize.Polygonizer)">
            <summary>
            Creates a new instance of LineStringAdder
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.LineStringAdder.Filter(DotSpatial.Topology.IGeometry)">
            <summary>
            Applies the Filter to the specified geometry
            </summary>
            <param name="g"></param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Polygonize.NullEdgeException">
            <summary>
            A null directed edge exception
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.NullEdgeException.#ctor">
            <summary>
            An exception for when the directed edge was null
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Polygonize.PolygonizeDirectedEdge">
            <summary>
            A <c>DirectedEdge</c> of a <c>PolygonizeGraph</c>, which represents
            an edge of a polygon formed by the graph.
            May be logically deleted from the graph by setting the <c>marked</c> flag.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeDirectedEdge.#ctor(DotSpatial.Topology.Planargraph.Node,DotSpatial.Topology.Planargraph.Node,DotSpatial.Topology.Coordinate,System.Boolean)">
            <summary>
            Constructs a directed edge connecting the <c>from</c> node to the
            <c>to</c> node.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="directionPt">
            Specifies this DirectedEdge's direction (given by an imaginary
            line from the <c>from</c> node to <c>directionPt</c>).
            </param>
            <param name="edgeDirection">
            Whether this DirectedEdge's direction is the same as or
            opposite to that of the parent Edge (if any).
            </param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.PolygonizeDirectedEdge.Label">
            <summary>
            Returns the identifier attached to this directed edge.
            Attaches an identifier to this directed edge.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.PolygonizeDirectedEdge.Next">
            <summary>
            Returns the next directed edge in the EdgeRing that this directed edge is a member of.
            Sets the next directed edge in the EdgeRing that this directed edge is a member of.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.PolygonizeDirectedEdge.IsInRing">
            <summary>
            Returns the ring of directed edges that this directed edge is
            a member of, or null if the ring has not been set.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.PolygonizeDirectedEdge.Ring">
            <summary>
            Gets/Sets the ring of directed edges that this directed edge is
            a member of.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Polygonize.PolygonizeEdge">
            <summary>
            An edge of a polygonization graph.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeEdge.#ctor(DotSpatial.Topology.LineString)">
             <summary>
            
             </summary>
             <param name="line"></param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.PolygonizeEdge.Line">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph">
            <summary>
            Represents a planar graph of edges that can be used to compute a
            polygonization, and implements the algorithms to compute the
            EdgeRings formed by the graph.
            The marked flag on DirectedEdges is used to indicate that a directed edge
            has be logically deleted from the graph.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.#ctor(DotSpatial.Topology.IGeometryFactory)">
            <summary>
            Create a new polygonization graph.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.GetDegreeNonDeleted(DotSpatial.Topology.Planargraph.Node)">
             <summary>
            
             </summary>
             <param name="node"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.GetDegree(DotSpatial.Topology.Planargraph.Node,System.Int64)">
             <summary>
            
             </summary>
             <param name="node"></param>
             <param name="label"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.DeleteAllEdges(DotSpatial.Topology.Planargraph.Node)">
            <summary>
            Deletes all edges at a node.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.AddEdge(DotSpatial.Topology.LineString)">
            <summary>
            Add a <c>LineString</c> forming an edge of the polygon graph.
            </summary>
            <param name="line">The line to add.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.GetNode(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="pt"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.ComputeNextCwEdges">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.ConvertMaximalToMinimalEdgeRings(System.Collections.IEnumerable)">
            <summary>
            Convert the maximal edge rings found by the initial graph traversal
            into the minimal edge rings required by NTS polygon topology rules.
            </summary>
            <param name="ringEdges">The list of start edges for the edgeRings to convert.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.FindIntersectionNodes(DotSpatial.Topology.Operation.Polygonize.PolygonizeDirectedEdge,System.Int64)">
            <summary>
            Finds all nodes in a maximal edgering which are self-intersection nodes
            </summary>
            <param name="startDe"></param>
            <param name="label"></param>
            <returns>
            The list of intersection nodes found,
            or null if no intersection nodes were found.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.GetEdgeRings">
            <summary>
            Computes the EdgeRings formed by the edges in this graph.
            </summary>
            <returns>A list of the{EdgeRings found by the polygonization process.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.FindLabeledEdgeRings(System.Collections.IEnumerable)">
             <summary>
            
             </summary>
             <param name="dirEdges">A List of the DirectedEdges in the graph.</param>
             <returns>A List of DirectedEdges, one for each edge ring found.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.DeleteCutEdges">
            <summary>
            Finds and removes all cut edges from the graph.
            </summary>
            <returns>A list of the <c>LineString</c>s forming the removed cut edges.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.Label(System.Collections.IEnumerable,System.Int64)">
             <summary>
            
             </summary>
             <param name="dirEdges"></param>
             <param name="label"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.ComputeNextCwEdges(DotSpatial.Topology.Planargraph.Node)">
             <summary>
            
             </summary>
             <param name="node"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.ComputeNextCcwEdges(DotSpatial.Topology.Planargraph.Node,System.Int64)">
            <summary>
            Computes the next edge pointers going CCW around the given node, for the
            given edgering label.
            This algorithm has the effect of converting maximal edgerings into minimal edgerings
            </summary>
            <param name="node"></param>
            <param name="label"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.FindDirEdgesInRing(DotSpatial.Topology.Operation.Polygonize.PolygonizeDirectedEdge)">
            <summary>
            Traverse a ring of DirectedEdges, accumulating them into a list.
            This assumes that all dangling directed edges have been removed
            from the graph, so that there is always a next dirEdge.
            </summary>
            <param name="startDe">The DirectedEdge to start traversing at.</param>
            <returns>A List of DirectedEdges that form a ring.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.FindEdgeRing(DotSpatial.Topology.Operation.Polygonize.PolygonizeDirectedEdge)">
             <summary>
            
             </summary>
             <param name="startDe"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.PolygonizeGraph.DeleteDangles">
            <summary>
            Marks all edges from the graph which are "dangles".
            Dangles are which are incident on a node with degree 1.
            This process is recursive, since removing a dangling edge
            may result in another edge becoming a dangle.
            In order to handle large recursion depths efficiently,
            an explicit recursion stack is used.
            </summary>
            <returns>A List containing the LineStrings that formed dangles.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Polygonize.Polygonizer">
            <summary>
            Polygonizes a set of Geometrys which contain linework that
            represents the edges of a planar graph.
            Any dimension of Geometry is handled - the constituent linework is extracted
            to form the edges.
            The edges must be correctly noded; that is, they must only meet
            at their endpoints.  The Polygonizer will still run on incorrectly noded input
            but will not form polygons from incorrected noded edges.
            The Polygonizer reports the follow kinds of errors:
            Dangles - edges which have one or both ends which are not incident on another edge endpoint
            Cut Edges - edges which are connected at both ends but which do not form part of polygon
            Invalid Ring Lines - edges which form rings which are invalid
            (e.g. the component lines contain a self-intersection).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.Polygonizer.#ctor">
            <summary>
            Create a polygonizer with the same {GeometryFactory}
            as the input <c>Geometry</c>s.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.Polygonizer.Add(System.Collections.IList)">
            <summary>
            Add a collection of geometries to be polygonized.
            May be called multiple times.
            Any dimension of Geometry may be added;
            the constituent linework will be extracted and used.
            </summary>
            <param name="geomList">A list of <c>Geometry</c>s with linework to be polygonized.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.Polygonizer.Add(DotSpatial.Topology.IGeometry)">
            <summary>
            Add a point to the linework to be polygonized.
            May be called multiple times.
            Any dimension of Geometry may be added;
            the constituent linework will be extracted and used
            </summary>
            <param name="g">A <c>Geometry</c> with linework to be polygonized.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.Polygonizer.Polygonize">
            <summary>
            Perform the polygonization, if it has not already been carried out.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.Polygonizer.FindValidRings(System.Collections.IEnumerable,System.Collections.IList,System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="edgeRingList"></param>
             <param name="validEdgeRingList"></param>
             <param name="invalidRingList"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.Polygonizer.FindShellsAndHoles(System.Collections.IEnumerable)">
             <summary>
            
             </summary>
             <param name="edgeRingList"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.Polygonizer.AssignHolesToShells(System.Collections.IEnumerable,System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="holeList"></param>
             <param name="shellList"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Polygonize.Polygonizer.AssignHoleToShell(DotSpatial.Topology.Operation.Polygonize.EdgeRing,System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="holeEr"></param>
             <param name="shellList"></param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.Polygonizer.Polygons">
            <summary>
            Compute and returns the list of polygons formed by the polygonization.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.Polygonizer.Dangles">
            <summary>
            Compute and returns the list of dangling lines found during polygonization.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.Polygonizer.CutEdges">
            <summary>
            Compute and returns the list of cut edges found during polygonization.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Polygonize.Polygonizer.InvalidRingLines">
            <summary>
            Compute and returns the list of lines forming invalid rings found during polygonization.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Predicate.RectangleContains">
            <summary>
            Optimized implementation of spatial predicate "contains"
            for cases where the first <c>Geometry</c> is a rectangle.
            As a further optimization,
            this class can be used directly to test many geometries against a single rectangle.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.RectangleContains.#ctor(DotSpatial.Topology.Polygon)">
            <summary>
            Create a new contains computer for two geometries.
            </summary>
            <param name="rectangle">A rectangular geometry.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.RectangleContains.Contains(DotSpatial.Topology.Polygon,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="rectangle"></param>
             <param name="b"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.RectangleContains.Contains(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.RectangleContains.IsContainedInBoundary(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.RectangleContains.IsPointContainedInBoundary(DotSpatial.Topology.Coordinate)">
            <summary>
            Given any valid implementation of ICoordinate, which
            will basically provide an X, Y or Z values, this will determine
            if the rectangle contains the point.
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.RectangleContains.IsLineStringContainedInBoundary(DotSpatial.Topology.IBasicGeometry)">
             <summary>
            
             </summary>
             <param name="line"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.RectangleContains.IsLineSegmentContainedInBoundary(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Predicate.RectangleIntersects">
            <summary>
            Optimized implementation of spatial predicate "intersects"
            for cases where the first {@link Geometry} is a rectangle.
            As a further optimization,
            this class can be used directly to test many geometries against a single
            rectangle.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Predicate.RectangleIntersects.MAXIMUM_SCAN_SEGMENT_COUNT">
            <summary>
            Crossover size at which brute-force intersection scanning
            is slower than indexed intersection detection.
            Must be determined empirically.  Should err on the
            safe side by making value smaller rather than larger.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.RectangleIntersects.#ctor(DotSpatial.Topology.IPolygon)">
            <summary>
            Create a new intersects computer for a rectangle.
            </summary>
            <param name="rectangle">A rectangular geometry.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.RectangleIntersects.Intersects(DotSpatial.Topology.Polygon,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="rectangle"></param>
             <param name="b"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.RectangleIntersects.Intersects(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Predicate.EnvelopeIntersectsVisitor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.EnvelopeIntersectsVisitor.#ctor(DotSpatial.Topology.IEnvelope)">
             <summary>
            
             </summary>
             <param name="rectEnv"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.EnvelopeIntersectsVisitor.Intersects">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.EnvelopeIntersectsVisitor.Visit(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="element"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.EnvelopeIntersectsVisitor.IsDone">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Predicate.ContainsPointVisitor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.ContainsPointVisitor.#ctor(DotSpatial.Topology.IPolygon)">
             <summary>
            
             </summary>
             <param name="rectangle"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.ContainsPointVisitor.ContainsPoint">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.ContainsPointVisitor.Visit(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.ContainsPointVisitor.IsDone">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Predicate.LineIntersectsVisitor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.LineIntersectsVisitor.#ctor(DotSpatial.Topology.IPolygon)">
             <summary>
            
             </summary>
             <param name="rectangle"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.LineIntersectsVisitor.Intersects">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.LineIntersectsVisitor.Visit(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.LineIntersectsVisitor.ComputeSegmentIntersection(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.LineIntersectsVisitor.IsDone">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Predicate.SegmentIntersectionTester">
            <summary>
            Tests if any line segments in two sets of CoordinateSequences intersect.
            Optimized for small geometry size.
            Short-circuited to return as soon an intersection is found.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.SegmentIntersectionTester.HasIntersectionWithLineStrings(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="seq"></param>
             <param name="lines"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Predicate.SegmentIntersectionTester.HasIntersection(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="seq0"></param>
             <param name="seq1"></param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Relate.EdgeEndBuilder">
            <summary>
            An EdgeEndBuilder creates EdgeEnds for all the "split edges"
            created by the intersections determined for an Edge.
            Computes the <c>EdgeEnd</c>s which arise from a noded <c>Edge</c>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBuilder.ComputeEdgeEnds(System.Collections.IEnumerator)">
             <summary>
            
             </summary>
             <param name="edges"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBuilder.ComputeEdgeEnds(DotSpatial.Topology.GeometriesGraph.Edge,System.Collections.IList)">
            <summary>
            Creates stub edges for all the intersections in this
            Edge (if any) and inserts them into the graph.
            </summary>
            <param name="edge"></param>
            <param name="l"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBuilder.CreateEdgeEndForPrev(DotSpatial.Topology.GeometriesGraph.Edge,System.Collections.IList,DotSpatial.Topology.GeometriesGraph.EdgeIntersection,DotSpatial.Topology.GeometriesGraph.EdgeIntersection)">
            <summary>
            Create a EdgeStub for the edge before the intersection eiCurr.
            The previous intersection is provided
            in case it is the endpoint for the stub edge.
            Otherwise, the previous point from the parent edge will be the endpoint.
            eiCurr will always be an EdgeIntersection, but eiPrev may be null.
            </summary>
            <param name="edge"></param>
            <param name="l"></param>
            <param name="eiCurr"></param>
            <param name="eiPrev"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBuilder.CreateEdgeEndForNext(DotSpatial.Topology.GeometriesGraph.Edge,System.Collections.IList,DotSpatial.Topology.GeometriesGraph.EdgeIntersection,DotSpatial.Topology.GeometriesGraph.EdgeIntersection)">
            <summary>
            Create a StubEdge for the edge after the intersection eiCurr.
            The next intersection is provided
            in case it is the endpoint for the stub edge.
            Otherwise, the next point from the parent edge will be the endpoint.
            eiCurr will always be an EdgeIntersection, but eiNext may be null.
            </summary>
            <param name="edge"></param>
            <param name="l"></param>
            <param name="eiCurr"></param>
            <param name="eiNext"></param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Relate.EdgeEndBundle">
            <summary>
            A collection of EdgeStubs which obey the following invariant:
            They originate at the same node and have the same direction.
            Contains all <c>EdgeEnd</c>s which start at the same point and are parallel.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBundle.#ctor(DotSpatial.Topology.GeometriesGraph.EdgeEnd)">
             <summary>
            
             </summary>
             <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBundle.GetEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBundle.Insert(DotSpatial.Topology.GeometriesGraph.EdgeEnd)">
             <summary>
            
             </summary>
             <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBundle.ComputeLabel">
            <summary>
            This computes the overall edge label for the set of
            edges in this EdgeStubBundle.  It essentially merges
            the ON and side labels for each edge.
            These labels must be compatible
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBundle.ComputeLabelOn(System.Int32)">
            <summary>
            Compute the overall ON location for the list of EdgeStubs.
            (This is essentially equivalent to computing the self-overlay of a single Geometry)
            edgeStubs can be either on the boundary (eg Polygon edge)
            OR in the interior (e.g. segment of a LineString)
            of their parent Geometry.
            In addition, GeometryCollections use the mod-2 rule to determine
            whether a segment is on the boundary or not.
            Finally, in GeometryCollections it can still occur that an edge is both
            on the boundary and in the interior (e.g. a LineString segment lying on
            top of a Polygon edge.) In this case as usual the Boundary is given precendence.
            These observations result in the following rules for computing the ON location:
             if there are an odd number of Bdy edges, the attribute is Bdy
             if there are an even number >= 2 of Bdy edges, the attribute is Int
             if there are any Int edges, the attribute is Int
             otherwise, the attribute is Null.
            </summary>
            <param name="geomIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBundle.ComputeLabelSides(System.Int32)">
            <summary>
            Compute the labelling for each side
            </summary>
            <param name="geomIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBundle.ComputeLabelSide(System.Int32,DotSpatial.Topology.GeometriesGraph.PositionType)">
            <summary>
            To compute the summary label for a side, the algorithm is:
            FOR all edges
            IF any edge's location is Interior for the side, side location = Interior
            ELSE IF there is at least one Exterior attribute, side location = Exterior
            ELSE  side location = Null
            Notice that it is possible for two sides to have apparently contradictory information
            i.e. one edge side may indicate that it is in the interior of a point, while
            another edge side may indicate the exterior of the same point.  This is
            not an incompatibility - GeometryCollections may contain two Polygons that touch
            along an edge.  This is the reason for Interior-primacy rule above - it
            results in the summary label having the Geometry interior on both sides.
            </summary>
            <param name="geomIndex"></param>
            <param name="side"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBundle.UpdateIm(DotSpatial.Topology.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for the computed label for the EdgeStubs.
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBundle.Write(System.IO.StreamWriter)">
             <summary>
            
             </summary>
             <param name="outstream"></param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Relate.EdgeEndBundle.EdgeEnds">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Relate.EdgeEndBundleStar">
            <summary>
            An ordered list of <c>EdgeEndBundle</c>s around a <c>RelateNode</c>.
            They are maintained in CCW order (starting with the positive x-axis) around the node
            for efficient lookup and topology building.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBundleStar.Insert(DotSpatial.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            Insert a EdgeEnd in order in the list.
            If there is an existing EdgeStubBundle which is parallel, the EdgeEnd is
            added to the bundle.  Otherwise, a new EdgeEndBundle is created
            to contain the EdgeEnd.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.EdgeEndBundleStar.UpdateIm(DotSpatial.Topology.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for the EdgeStubs around the node.
            </summary>
            <param name="im"></param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Relate.RelateComputer">
            <summary>
            Computes the topological relationship between two Geometries.
            RelateComputer does not need to build a complete graph structure to compute
            the IntersectionMatrix.  The relationship between the geometries can
            be computed by simply examining the labelling of edges incident on each node.
            RelateComputer does not currently support arbitrary GeometryCollections.
            This is because GeometryCollections can contain overlapping Polygons.
            In order to correct compute relate on overlapping Polygons, they
            would first need to be noded and merged (if not explicitly, at least
            implicitly).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.#ctor(DotSpatial.Topology.GeometriesGraph.GeometryGraph[])">
             <summary>
            
             </summary>
             <param name="arg"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.ComputeIm">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.InsertEdgeEnds(System.Collections.IEnumerable)">
             <summary>
            
             </summary>
             <param name="ee"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.ComputeProperIntersectionIm(DotSpatial.Topology.GeometriesGraph.Index.SegmentIntersector,DotSpatial.Topology.IIntersectionMatrix)">
             <summary>
            
             </summary>
             <param name="intersector"></param>
             <param name="im"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.CopyNodesAndLabels(System.Int32)">
            <summary>
            Copy all nodes from an arg point into this graph.
            The node label in the arg point overrides any previously computed
            label for that argIndex.
            (E.g. a node may be an intersection node with
            a computed label of Boundary,
            but in the original arg Geometry it is actually
            in the interior due to the Boundary Determination Rule)
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.ComputeIntersectionNodes(System.Int32)">
            <summary>
            Insert nodes for all intersections on the edges of a Geometry.
            Label the created nodes the same as the edge label if they do not already have a label.
            This allows nodes created by either self-intersections or
            mutual intersections to be labelled.
            Endpoint nodes will already be labelled from when they were inserted.
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.ComputeDisjointIm(DotSpatial.Topology.IIntersectionMatrix)">
            <summary>
            If the Geometries are disjoint, we need to enter their dimension and
            boundary dimension in the Ext rows in the IM
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.LabelNodeEdges">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.UpdateIm(DotSpatial.Topology.IntersectionMatrix)">
            <summary>
            Update the IM with the sum of the IMs for each component.
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.LabelIsolatedEdges(System.Int32,System.Int32)">
            <summary>
            Processes isolated edges by computing their labelling and adding them
            to the isolated edges list.
            Isolated edges are guaranteed not to touch the boundary of the target (since if they
            did, they would have caused an intersection to be computed and hence would
            not be isolated).
            </summary>
            <param name="thisIndex"></param>
            <param name="targetIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.LabelIsolatedEdge(DotSpatial.Topology.GeometriesGraph.GraphComponent,System.Int32,DotSpatial.Topology.IGeometry)">
            <summary>
            Label an isolated edge of a graph with its relationship to the target point.
            If the target has dim 2 or 1, the edge can either be in the interior or the exterior.
            If the target has dim 0, the edge must be in the exterior.
            </summary>
            <param name="e"></param>
            <param name="targetIndex"></param>
            <param name="target"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.LabelIsolatedNodes">
            <summary>
            Isolated nodes are nodes whose labels are incomplete
            (e.g. the location for one Geometry is null).
            This is the case because nodes in one graph which don't intersect
            nodes in the other are not completely labelled by the initial process
            of adding nodes to the nodeList.
            To complete the labelling we need to check for nodes that lie in the
            interior of edges, and in the interior of areas.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateComputer.LabelIsolatedNode(DotSpatial.Topology.GeometriesGraph.GraphComponent,System.Int32)">
            <summary>
            Label an isolated node with its relationship to the target point.
            </summary>
            <param name="n"></param>
            <param name="targetIndex"></param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Relate.RelateNode">
            <summary>
            A RelateNode is a Node that maintains a list of EdgeStubs
            for the edges that are incident on it.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateNode.#ctor(DotSpatial.Topology.Coordinate,DotSpatial.Topology.GeometriesGraph.EdgeEndStar)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <param name="edges"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateNode.ComputeIm(DotSpatial.Topology.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for this component.
            A component only contributes if it has a labelling for both parent geometries.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateNode.UpdateImFromEdges(DotSpatial.Topology.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for the EdgeEnds incident on this node.
            </summary>
            <param name="im"></param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Relate.RelateNodeFactory">
            <summary>
            Used by the <c>NodeMap</c> in a <c>RelateNodeGraph</c> to create <c>RelateNode</c>s.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateNodeFactory.CreateNode(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Relate.RelateNodeGraph">
            <summary>
            Implements the simple graph of Nodes and EdgeEnd which is all that is
            required to determine topological relationships between Geometries.
            Also supports building a topological graph of a single Geometry, to
            allow verification of valid topology.
            It is not necessary to create a fully linked
            PlanarGraph to determine relationships, since it is sufficient
            to know how the Geometries interact locally around the nodes.
            In fact, this is not even feasible, since it is not possible to compute
            exact intersection points, and hence the topology around those nodes
            cannot be computed robustly.
            The only Nodes that are created are for improper intersections;
            that is, nodes which occur at existing vertices of the Geometries.
            Proper intersections (e.g. ones which occur between the interior of line segments)
            have their topology determined implicitly, without creating a Node object
            to represent them.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateNodeGraph.GetNodeEnumerator">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateNodeGraph.Build(DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
             <param name="geomGraph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateNodeGraph.ComputeIntersectionNodes(DotSpatial.Topology.GeometriesGraph.GeometryGraph,System.Int32)">
            <summary>
            Insert nodes for all intersections on the edges of a Geometry.
            Label the created nodes the same as the edge label if they do not already have a label.
            This allows nodes created by either self-intersections or
            mutual intersections to be labelled.
            Endpoint nodes will already be labelled from when they were inserted.
            Precondition: edge intersections have been computed.
            </summary>
            <param name="geomGraph"></param>
            <param name="argIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateNodeGraph.CopyNodesAndLabels(DotSpatial.Topology.GeometriesGraph.GeometryGraph,System.Int32)">
            <summary>
            Copy all nodes from an arg point into this graph.
            The node label in the arg point overrides any previously computed
            label for that argIndex.
            (E.g. a node may be an intersection node with
            a computed label of Boundary,
            but in the original arg Geometry it is actually
            in the interior due to the Boundary Determination Rule).
            </summary>
            <param name="geomGraph"></param>
            <param name="argIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateNodeGraph.InsertEdgeEnds(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="ee"></param>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Relate.RelateOp">
            <summary>
            Implements the <c>Relate()</c> operation on <c>Geometry</c>s.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateOp.#ctor(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="g0"></param>
             <param name="g1"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Relate.RelateOp.Relate(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="a"></param>
             <param name="b"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Relate.RelateOp.IntersectionMatrix">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Valid.ConnectedInteriorTester">
            <summary>
            This class tests that the interior of an area <see cref="T:DotSpatial.Topology.Geometry"/>
            (<see cref="T:DotSpatial.Topology.Polygon"/> or <see cref="T:DotSpatial.Topology.MultiPolygon"/>)
            is connected.  An area Geometry is invalid if the interior is disconnected.
            This can happen if:
            - a shell self-intersects,
            - one or more holes form a connected chain touching a shell at two different points,
            - one or more holes form a ring around a subset of the interior.
            If a disconnected situation is found the location of the problem is recorded.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.ConnectedInteriorTester.#ctor(DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
             <param name="geomGraph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.ConnectedInteriorTester.FindDifferentPoint(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate},DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <param name="pt"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.ConnectedInteriorTester.IsInteriorsConnected">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.ConnectedInteriorTester.SetInteriorEdgesInResult(DotSpatial.Topology.GeometriesGraph.PlanarGraph)">
             <summary>
            
             </summary>
             <param name="graph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.ConnectedInteriorTester.BuildEdgeRings(System.Collections.IList)">
            <summary>
            Form <see cref="T:DotSpatial.Topology.GeometriesGraph.DirectedEdge"/>s in graph into Minimal EdgeRings.
            (Minimal Edgerings must be used, because only they are guaranteed to provide
            a correct isHole computation).
            </summary>
            <param name="dirEdges"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.ConnectedInteriorTester.VisitShellInteriors(DotSpatial.Topology.IGeometry,DotSpatial.Topology.GeometriesGraph.PlanarGraph)">
            <summary>
            Mark all the edges for the edgeRings corresponding to the shells of the input polygons.
            Only ONE ring gets marked for each shell - if there are others which remain unmarked
            this indicates a disconnected interior.
            </summary>
            <param name="g"></param>
            <param name="graph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.ConnectedInteriorTester.VisitInteriorRing(DotSpatial.Topology.IBasicGeometry,DotSpatial.Topology.GeometriesGraph.PlanarGraph)">
             <summary>
            
             </summary>
             <param name="ring"></param>
             <param name="graph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.ConnectedInteriorTester.VisitLinkedDirectedEdges(DotSpatial.Topology.GeometriesGraph.DirectedEdge)">
             <summary>
            
             </summary>
             <param name="start"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.ConnectedInteriorTester.HasUnvisitedShellEdge(System.Collections.IList)">
            <summary>
            Check if any shell ring has an unvisited edge.
            A shell ring is a ring which is not a hole and which has the interior
            of the parent area on the RHS.
            (Notice that there may be non-hole rings with the interior on the LHS,
            since the interior of holes will also be polygonized into CW rings
            by the <c>LinkAllDirectedEdges()</c> step).
            </summary>
            <param name="edgeRings"></param>
            <returns><c>true</c> if there is an unvisited edge in a non-hole ring.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.ConnectedInteriorTester.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Valid.ConsistentAreaTester">
            <summary>
            Checks that a {GeometryGraph} representing an area
            (a <c>Polygon</c> or <c>MultiPolygon</c> )
            is consistent with the SFS semantics for area geometries.
            Checks include:
            Testing for rings which self-intersect (both properly and at nodes).
            Testing for duplicate rings.
            If an inconsistency if found the location of the problem is recorded.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.ConsistentAreaTester.#ctor(DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
             <param name="geomGraph"></param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.ConsistentAreaTester.InvalidPoint">
            <summary>
            Returns the intersection point, or <c>null</c> if none was found.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.ConsistentAreaTester.IsNodeConsistentArea">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.ConsistentAreaTester.IsNodeEdgeAreaLabelsConsistent">
            <summary>
            Check all nodes to see if their labels are consistent.
            If any are not, return false.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.ConsistentAreaTester.HasDuplicateRings">
            <summary>
            Checks for two duplicate rings in an area.
            Duplicate rings are rings that are topologically equal
            (that is, which have the same sequence of points up to point order).
            If the area is topologically consistent (determined by calling the
            <c>isNodeConsistentArea</c>,
            duplicate rings can be found by checking for EdgeBundles which contain more than one EdgeEnd.
            (This is because topologically consistent areas cannot have two rings sharing
            the same line segment, unless the rings are equal).
            The start point of one of the equal rings will be placed in invalidPoint.
            Returns <c>true</c> if this area Geometry is topologically consistent but has two duplicate rings.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Valid.IsValidOp">
            <summary>
            Implements the algorithsm required to compute the <see cref="P:DotSpatial.Topology.Geometry.IsValid"/>
            method for <see cref="T:DotSpatial.Topology.Geometry"/>s.
            See the documentation for the various geometry types for a specification of validity.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.IsValidOp._isSelfTouchingRingFormingHoleValid">
            If the following condition is TRUE JTS will validate inverted shells and exverted holes (the Esri SDE model).
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.#ctor(DotSpatial.Topology.Geometry)">
             <summary>
            
             </summary>
             <param name="parentGeometry"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.IsValidCoordinate(DotSpatial.Topology.Coordinate)">
            <summary>
            Checks whether a coordinate is valid for processing.
            Coordinates are valid iff their x and y ordinates are in the
            range of the floating point representation.
            </summary>
            <param name="coord">The coordinate to validate.</param>
            <returns><c>true</c> if the coordinate is valid.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.FindPointNotNode(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},DotSpatial.Topology.ILinearRing,DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Find a point from the list of testCoords
            that is NOT a node in the edge for the list of searchCoords.
            </summary>
            <param name="testCoords"></param>
            <param name="searchRing"></param>
            <param name="graph"></param>
            <returns>The point found, or <c>null</c> if none found.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckValid(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckValidCoordinates(DotSpatial.Topology.IBasicGeometry)">
            <summary>
            Checks validity of a Point.
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckValidLineString(DotSpatial.Topology.IGeometry)">
            <summary>
            Checks validity of a LineString.
            Almost anything goes for lineStrings!
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckValidRing(DotSpatial.Topology.ILinearRing)">
            <summary>
            Checks validity of a LinearRing.
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckValidPolygon(DotSpatial.Topology.IPolygon)">
            <summary>
            Checks the validity of a polygon and sets the validErr flag.
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckValidMultipolygon(DotSpatial.Topology.IMultiPolygon)">
             <summary>
            
             </summary>
             <param name="g"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckValidCollection(DotSpatial.Topology.IGeometryCollection)">
             <summary>
            
             </summary>
             <param name="gc"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckInvalidCoordinates(System.Collections.Generic.IEnumerable{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="coords"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckInvalidCoordinates(DotSpatial.Topology.IPolygon)">
             <summary>
            
             </summary>
             <param name="poly"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckClosedRings(DotSpatial.Topology.IPolygon)">
             <summary>
            
             </summary>
             <param name="poly"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckClosedRing(DotSpatial.Topology.ILinearRing)">
             <summary>
            
             </summary>
             <param name="ring"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckTooFewPoints(DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
             <param name="graph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckConsistentArea(DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
             <param name="graph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckNoSelfIntersectingRings(DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Check that there is no ring which self-intersects (except of course at its endpoints).
            This is required by OGC topology rules (but not by other models
            such as Esri SDE, which allow inverted shells and exverted holes).
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckNoSelfIntersectingRing(DotSpatial.Topology.GeometriesGraph.EdgeIntersectionList)">
            <summary>
            Check that a ring does not self-intersect, except at its endpoints.
            Algorithm is to count the number of times each node along edge occurs.
            If any occur more than once, that must be a self-intersection.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckHolesInShell(DotSpatial.Topology.IPolygon,DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Tests that each hole is inside the polygon shell.
            This routine assumes that the holes have previously been tested
            to ensure that all vertices lie on the shell or inside it.
            A simple test of a single point in the hole can be used,
            provide the point is chosen such that it does not lie on the
            boundary of the shell.
            </summary>
            <param name="p">The polygon to be tested for hole inclusion.</param>
            <param name="graph">A GeometryGraph incorporating the polygon.</param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckHolesNotNested(DotSpatial.Topology.IPolygon,DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Tests that no hole is nested inside another hole.
            This routine assumes that the holes are disjoint.
            To ensure this, holes have previously been tested
            to ensure that:
            They do not partially overlap
            (checked by <c>checkRelateConsistency</c>).
            They are not identical
            (checked by <c>checkRelateConsistency</c>).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckShellsNotNested(DotSpatial.Topology.IGeometry,DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Tests that no element polygon is wholly in the interior of another element polygon.
            Preconditions:
            Shells do not partially overlap.
            Shells do not touch along an edge.
            No duplicate rings exists.
            This routine relies on the fact that while polygon shells may touch at one or
            more vertices, they cannot touch at ALL vertices.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckShellNotNested(DotSpatial.Topology.LinearRing,DotSpatial.Topology.Polygon,DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Check if a shell is incorrectly nested within a polygon.  This is the case
            if the shell is inside the polygon shell, but not inside a polygon hole.
            (If the shell is inside a polygon hole, the nesting is valid.)
            The algorithm used relies on the fact that the rings must be properly contained.
            E.g. they cannot partially overlap (this has been previously checked by
            <c>CheckRelateConsistency</c>).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckShellInsideHole(DotSpatial.Topology.LinearRing,DotSpatial.Topology.LinearRing,DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            This routine checks to see if a shell is properly contained in a hole.
            It assumes that the edges of the shell and hole do not
            properly intersect.
            </summary>
            <param name="shell"></param>
            <param name="hole"></param>
            <param name="graph"></param>
            <returns>
            <c>null</c> if the shell is properly contained, or
            a Coordinate which is not inside the hole if it is not.
            </returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.IsValidOp.CheckConnectedInteriors(DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
             <param name="graph"></param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.IsValidOp.IsSelfTouchingRingFormingHoleValid">
            <summary>
            <para>
            Gets/Sets whether polygons using Self-Touching Rings to form
            holes are reported as valid.
            If this flag is set, the following Self-Touching conditions
            are treated as being valid:
            - The shell ring self-touches to create a hole touching the shell.
            - A hole ring self-touches to create two holes touching at a point.
            </para>
            <para>
            The default (following the OGC SFS standard)
            is that this condition is not valid (<c>false</c>).
            </para>
            <para>
            This does not affect whether Self-Touching Rings
            disconnecting the polygon interior are considered valid
            (these are considered to be invalid under the SFS, and many other
            spatial models as well).
            This includes "bow-tie" shells,
            which self-touch at a single point causing the interior to be disconnected,
            and "C-shaped" holes which self-touch at a single point causing an island to be formed.
            </para>
            </summary>
            <value>States whether geometry with this condition is valid.</value>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.IsValidOp.IsValid">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.IsValidOp.ValidationError">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Valid.QuadtreeNestedRingTester">
            <summary>
            Tests whether any of a set of <c>LinearRing</c>s are
            nested inside another ring in the set, using a <c>Quadtree</c>
            index to speed up the comparisons.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.QuadtreeNestedRingTester.#ctor(DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
             <param name="graph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.QuadtreeNestedRingTester.Add(DotSpatial.Topology.LinearRing)">
             <summary>
            
             </summary>
             <param name="ring"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.QuadtreeNestedRingTester.IsNonNested">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.QuadtreeNestedRingTester.BuildQuadtree">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.QuadtreeNestedRingTester.NestedPoint">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Valid.RepeatedPointTester">
            <summary>
            Implements the appropriate checks for repeated points
            (consecutive identical coordinates) as defined in the
            NTS spec.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.RepeatedPointTester.HasRepeatedPoint(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="g"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.RepeatedPointTester.HasRepeatedPoint(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="coord"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.RepeatedPointTester.HasRepeatedPoint(DotSpatial.Topology.IPolygon)">
             <summary>
            
             </summary>
             <param name="p"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.RepeatedPointTester.HasRepeatedPoint(DotSpatial.Topology.IGeometryCollection)">
             <summary>
            
             </summary>
             <param name="gc"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.RepeatedPointTester.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Valid.ShellHoleIdentityException">
            <summary>
            A ShellHoleIdentityException Class
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.ShellHoleIdentityException.#ctor">
            <summary>
            Creates a new instance of ShellHoleIdentityException
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Valid.SimpleNestedRingTester">
            <summary>
            Tests whether any of a set of <c>LinearRing</c>s are
            nested inside another ring in the set, using a simple O(n^2)
            comparison.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.SimpleNestedRingTester.#ctor(DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
             <param name="graph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.SimpleNestedRingTester.Add(DotSpatial.Topology.LinearRing)">
             <summary>
            
             </summary>
             <param name="ring"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.SimpleNestedRingTester.IsNonNested">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.SimpleNestedRingTester.NestedPoint">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Valid.SweeplineNestedRingTester">
            <summary>
            Tests whether any of a set of <c>LinearRing</c>s are
            nested inside another ring in the set, using a <c>SweepLineIndex</c>
            index to speed up the comparisons.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.SweeplineNestedRingTester.#ctor(DotSpatial.Topology.GeometriesGraph.GeometryGraph)">
             <summary>
            
             </summary>
             <param name="graph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.SweeplineNestedRingTester.Add(DotSpatial.Topology.LinearRing)">
             <summary>
            
             </summary>
             <param name="ring"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.SweeplineNestedRingTester.IsNonNested">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.SweeplineNestedRingTester.BuildIndex">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.SweeplineNestedRingTester.IsInside(DotSpatial.Topology.ILinearRing,DotSpatial.Topology.ILinearRing)">
             <summary>
            
             </summary>
             <param name="innerRing"></param>
             <param name="searchRing"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.SweeplineNestedRingTester.NestedPoint">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Valid.SweeplineNestedRingTester.OverlapAction">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.SweeplineNestedRingTester.OverlapAction.#ctor(DotSpatial.Topology.Operation.Valid.SweeplineNestedRingTester)">
             <summary>
            
             </summary>
             <param name="container"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.SweeplineNestedRingTester.OverlapAction.Overlap(DotSpatial.Topology.Index.Sweepline.SweepLineInterval,DotSpatial.Topology.Index.Sweepline.SweepLineInterval)">
             <summary>
            
             </summary>
             <param name="s0"></param>
             <param name="s1"></param>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.SweeplineNestedRingTester.OverlapAction.IsNonNested">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Valid.TopologyValidationError">
            <summary>
            Contains information about the nature and location of a <c>Geometry</c>
            validation error.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationError.ErrMsg">
            <summary>
            These messages must synch up with the indexes above
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.TopologyValidationError.#ctor(DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="errorType"></param>
             <param name="pt"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.TopologyValidationError.#ctor(DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType)">
             <summary>
            
             </summary>
             <param name="errorType"></param>
        </member>
        <member name="M:DotSpatial.Topology.Operation.Valid.TopologyValidationError.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.TopologyValidationError.Coordinate">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.TopologyValidationError.ErrorType">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Operation.Valid.TopologyValidationError.Message">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType">
            <summary>
            Contains information about the nature and location of
            a <see cref="T:DotSpatial.Topology.Geometry"/> validation error.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType.Error">
            <summary>
            Not used.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType.RepeatedPoint">
            <summary>
            No longer used:
            repeated points are considered valid as per the SFS.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType.HoleOutsideShell">
            <summary>
            Indicates that a hole of a polygon lies partially
            or completely in the exterior of the shell.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType.NestedHoles">
            <summary>
            Indicates that a hole lies
            in the interior of another hole in the same polygon.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType.DisconnectedInteriors">
            <summary>
            Indicates that the interior of a polygon is disjoint
            (often caused by set of contiguous holes splitting
            the polygon into two parts).
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType.SelfIntersection">
            <summary>
            Indicates that two rings of a polygonal geometry intersect.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType.RingSelfIntersection">
            <summary>
            Indicates that a ring self-intersects.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType.NestedShells">
            <summary>
            Indicates that a polygon component of a
            <see cref="T:DotSpatial.Topology.MultiPolygon"/> lies inside another polygonal component.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType.DuplicateRings">
            <summary>
            Indicates that a polygonal geometry
            contains two rings which are identical.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType.TooFewPoints">
            <summary>
            Indicates that either:
            - A <see cref="T:DotSpatial.Topology.LineString"/> contains a single point.
            - A <see cref="T:DotSpatial.Topology.LinearRing"/> contains 2 or 3 points.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType.InvalidCoordinate">
            <summary>
            Indicates that the <c>X</c> or <c>Y</c> ordinate of
            a <see cref="T:DotSpatial.Topology.Coordinate"/> is not a valid
            numeric value (e.g. <see cref="F:System.Double.NaN"/>).
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Operation.Valid.TopologyValidationErrorType.RingNotClosed">
            <summary>
            Indicates that a ring is not correctly closed
            (the first and the last coordinate are different).
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Planargraph.Algorithm.ConnectedSubgraphFinder">
            <summary>
            Finds all connected <see cref="T:DotSpatial.Topology.Planargraph.Subgraph"/>s of a <see cref="T:DotSpatial.Topology.Planargraph.PlanarGraph"/>.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Algorithm.ConnectedSubgraphFinder.#ctor(DotSpatial.Topology.Planargraph.PlanarGraph)">
            <summary>
            Initializes a new instance of the ConnectedSubgraphFinder class.
            </summary>
            <param name="graph">The <see cref="T:DotSpatial.Topology.Planargraph.PlanarGraph"/>.</param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Algorithm.ConnectedSubgraphFinder.GetConnectedSubgraphs">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Algorithm.ConnectedSubgraphFinder.AddReachable(DotSpatial.Topology.Planargraph.Node,DotSpatial.Topology.Planargraph.Subgraph)">
            <summary>
            Adds all nodes and edges reachable from this node to the subgraph.
            Uses an explicit stack to avoid a large depth of recursion.
            </summary>
            <param name="startNode"></param>
            <param name="subgraph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Algorithm.ConnectedSubgraphFinder.AddEdges(DotSpatial.Topology.Planargraph.Node,System.Collections.Stack,DotSpatial.Topology.Planargraph.Subgraph)">
            <summary>
            Adds the argument node and all its out edges to the subgraph.
            </summary>
            <param name="node"></param>
            <param name="nodeStack"></param>
            <param name="subgraph"></param>
        </member>
        <member name="T:DotSpatial.Topology.Planargraph.DirectedEdgeStar">
            <summary>
            A sorted collection of <c>DirectedEdge</c>s which leave a <c>Node</c>
            in a <c>PlanarGraph</c>.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Planargraph.DirectedEdgeStar._outEdges">
            <summary>
            The underlying list of outgoing DirectedEdges.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdgeStar.Add(DotSpatial.Topology.Planargraph.DirectedEdge)">
            <summary>
            Adds a new member to this DirectedEdgeStar.
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdgeStar.Remove(DotSpatial.Topology.Planargraph.DirectedEdge)">
            <summary>
            Drops a member of this DirectedEdgeStar.
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdgeStar.GetEnumerator">
            <summary>
            Returns an Iterator over the DirectedEdges, in ascending order by angle with the positive x-axis.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdgeStar.SortEdges">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdgeStar.GetIndex(DotSpatial.Topology.Planargraph.Edge)">
            <summary>
            Returns the zero-based index of the given Edge, after sorting in ascending order
            by angle with the positive x-axis.
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdgeStar.GetIndex(DotSpatial.Topology.Planargraph.DirectedEdge)">
            <summary>
            Returns the zero-based index of the given DirectedEdge, after sorting in ascending order
            by angle with the positive x-axis.
            </summary>
            <param name="dirEdge"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdgeStar.GetIndex(System.Int32)">
            <summary>
            Returns the remainder when i is divided by the number of edges in this
            DirectedEdgeStar.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.DirectedEdgeStar.GetNextEdge(DotSpatial.Topology.Planargraph.DirectedEdge)">
            <summary>
            Returns the DirectedEdge on the left-hand side of the given DirectedEdge (which
            must be a member of this DirectedEdgeStar).
            </summary>
            <param name="dirEdge"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdgeStar.OutEdges">
            <summary>
            The underlying list of outgoing Directed Edges
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdgeStar.Degree">
            <summary>
            Returns the number of edges around the Node associated with this DirectedEdgeStar.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdgeStar.Coordinate">
            <summary>
            Returns the coordinate for the node at wich this star is based.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.DirectedEdgeStar.Edges">
            <summary>
            Returns the DirectedEdges, in ascending order by angle with the positive x-axis.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Planargraph.Node">
            <summary>
            A node in a <c>PlanarGraph</c> is a location where 0 or more <c>Edge</c>s
            meet. A node is connected to each of its incident Edges via an outgoing
            DirectedEdge. Some clients using a <c>PlanarGraph</c> may want to
            subclass <c>Node</c> to add their own application-specific
            data and methods.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Planargraph.Node.DeStar">
            <summary>
            The collection of DirectedEdges that leave this Node.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Planargraph.Node._location">
            <summary>
            The location of this Node.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Node.#ctor(DotSpatial.Topology.Coordinate)">
            <summary>
            Constructs a Node with the given location.
            </summary>
            <param name="location"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Node.#ctor(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Planargraph.DirectedEdgeStar)">
            <summary>
            Constructs a Node with the given location and collection of outgoing DirectedEdges.
            </summary>
            <param name="location"></param>
            <param name="deStar"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Node.GetEdgesBetween(DotSpatial.Topology.Planargraph.Node,DotSpatial.Topology.Planargraph.Node)">
            <summary>
            Returns all Edges that connect the two nodes (which are assumed to be different).
            </summary>
            <param name="node0"></param>
            <param name="node1"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Node.AddOutEdge(DotSpatial.Topology.Planargraph.DirectedEdge)">
            <summary>
            Adds an outgoing DirectedEdge to this Node.
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Node.GetIndex(DotSpatial.Topology.Planargraph.Edge)">
            <summary>
            Returns the zero-based index of the given Edge, after sorting in ascending order
            by angle with the positive x-axis.
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Node.Remove">
            <summary>
            Removes this node from its containing graph.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Node.ToString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.Node.Coordinate">
            <summary>
            Returns the location of this Node.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.Node.OutEdges">
            <summary>
            Returns the collection of DirectedEdges that leave this Node.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.Node.Degree">
            <summary>
            Returns the number of edges around this Node.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.Node.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
            <value></value>
        </member>
        <member name="T:DotSpatial.Topology.Planargraph.NodeMap">
            <summary>
            A map of <c>Node</c>s, indexed by the coordinate of the node.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.NodeMap.Add(DotSpatial.Topology.Planargraph.Node)">
            <summary>
            Adds a node to the map, replacing any that is already at that location.
            </summary>
            <param name="n"></param>
            <returns>The added node.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.NodeMap.Remove(DotSpatial.Topology.Coordinate)">
            <summary>
            Removes the Node at the given location, and returns it (or null if no Node was there).
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.NodeMap.Find(DotSpatial.Topology.Coordinate)">
            <summary>
            Returns the Node at the given location, or null if no Node was there.
            </summary>
            <param name="coord"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.NodeMap.GetEnumerator">
            <summary>
            Returns an Iterator over the Nodes in this NodeMap, sorted in ascending order
            by angle with the positive x-axis.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Planargraph.NodeMap.Values">
            <summary>
            Returns the Nodes in this NodeMap, sorted in ascending order
            by angle with the positive x-axis.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Planargraph.Subgraph">
            <summary>
            A subgraph of a <see cref="T:DotSpatial.Topology.Planargraph.PlanarGraph"/>.
            A subgraph may contain any subset of <see cref="T:DotSpatial.Topology.Planargraph.Edge"/>s
            from the parent graph.
            It will also automatically contain all <see cref="T:DotSpatial.Topology.Planargraph.DirectedEdge"/>s
            and <see cref="T:DotSpatial.Topology.Planargraph.Node"/>s associated with those edges.
            No new objects are created when edges are added -
            all associated components must already exist in the parent graph.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Planargraph.Subgraph.DirEdges">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Planargraph.Subgraph.Edges">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Planargraph.Subgraph.NodeMap">
             <summary>
            
             </summary>
        </member>
        <member name="F:DotSpatial.Topology.Planargraph.Subgraph.ParentGraph">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Subgraph.#ctor(DotSpatial.Topology.Planargraph.PlanarGraph)">
            <summary>
            Creates a new subgraph of the given <see cref="T:DotSpatial.Topology.Planargraph.PlanarGraph"/>.
            </summary>
            <param name="parentGraph"></param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Subgraph.GetParent">
            <summary>
             Gets the <see cref="T:DotSpatial.Topology.Planargraph.PlanarGraph"/> which this subgraph is part of.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Subgraph.Add(DotSpatial.Topology.Planargraph.Edge)">
            <summary>
            Adds an <see cref="T:DotSpatial.Topology.Planargraph.Edge"/> to the subgraph.
            The associated <see cref="T:DotSpatial.Topology.Planargraph.DirectedEdge"/>s and <see cref="T:DotSpatial.Topology.Planargraph.Node"/>s are also added.
            </summary>
            <param name="e">The <see cref="T:DotSpatial.Topology.Planargraph.Edge"/> to add.</param>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Subgraph.GetDirEdgeEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IEnumerator"/> over the <see cref="T:DotSpatial.Topology.Planargraph.DirectedEdge"/>s in this graph,
            in the order in which they were added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Subgraph.GetEdgeEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IEnumerator"/> over the <see cref="T:DotSpatial.Topology.Planargraph.Edge"/>s in this graph,
            in the order in which they were added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Subgraph.GetNodeEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IEnumerator"/> over the <see cref="T:DotSpatial.Topology.Planargraph.Node"/>s in this graph.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Planargraph.Subgraph.Contains(DotSpatial.Topology.Planargraph.Edge)">
            <summary>
            Tests whether an <see cref="T:DotSpatial.Topology.Planargraph.Edge"/> is contained in this subgraph.
            </summary>
            <param name="e">The <see cref="T:DotSpatial.Topology.Planargraph.Edge"/> to test.</param>
            <returns><c>true</c> if the <see cref="T:DotSpatial.Topology.Planargraph.Edge"/> is contained in this subgraph.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Precision.CommonBits">
            <summary>
            Determines the maximum number of common most-significant
            bits in the mantissa of one or numbers.
            Can be used to compute the double-precision number which
            is represented by the common bits.
            If there are no common bits, the number computed is 0.0.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBits.SignExpBits(System.Int64)">
            <summary>
            Computes the bit pattern for the sign and exponent of a
            double-precision number.
            </summary>
            <param name="num"></param>
            <returns>The bit pattern for the sign and exponent.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBits.NumCommonMostSigMantissaBits(System.Int64,System.Int64)">
            <summary>
            This computes the number of common most-significant bits in the mantissas
            of two double-precision numbers.
            It does not count the hidden bit, which is always 1.
            It does not determine whether the numbers have the same exponent - if they do
            not, the value computed by this function is meaningless.
            </summary>
            <param name="num1"></param>
            /// <param name="num2"></param>
            <returns>The number of common most-significant mantissa bits.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBits.ZeroLowerBits(System.Int64,System.Int32)">
            <summary>
            Zeroes the lower n bits of a bitstring.
            </summary>
            <param name="bits">The bitstring to alter.</param>
            <param name="nBits">the number of bits to zero.</param>
            <returns>The zeroed bitstring.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBits.GetBit(System.Int64,System.Int32)">
            <summary>
            Extracts the i'th bit of a bitstring.
            </summary>
            <param name="bits">The bitstring to extract from.</param>
            <param name="i">The bit to extract.</param>
            <returns>The value of the extracted bit.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBits.Add(System.Double)">
             <summary>
            
             </summary>
             <param name="num"></param>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBits.ToString(System.Int64)">
            <summary>
            A representation of the Double bits formatted for easy readability
            </summary>
            <param name="bits"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Precision.CommonBits.Common">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Precision.CommonBitsOp">
            <summary>
            Provides versions of Geometry spatial functions which use
            common bit removal to reduce the likelihood of robustness problems.
            In the current implementation no rounding is performed on the
            reshifted result point, which means that it is possible
            that the returned Geometry is invalid.
            Client classes should check the validity of the returned result themselves.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsOp.#ctor">
            <summary>
            Creates a new instance of class, which reshifts result <c>Geometry</c>s.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsOp.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of class, specifying whether
            the result <c>Geometry</c>s should be reshifted.
            </summary>
            <param name="returnToOriginalPrecision"></param>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsOp.Intersection(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
            <summary>
            Computes the set-theoretic intersection of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic intersection of the input Geometries.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsOp.Union(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
            <summary>
            Computes the set-theoretic union of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic union of the input Geometries.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsOp.Difference(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
            <summary>
            Computes the set-theoretic difference of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry, to be subtracted from the first.</param>
            <returns>The Geometry representing the set-theoretic difference of the input Geometries.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsOp.SymDifference(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
            <summary
            > Computes the set-theoretic symmetric difference of two geometries,
            using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic symmetric difference of the input Geometries.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsOp.Buffer(DotSpatial.Topology.IGeometry,System.Double)">
            <summary>
            Computes the buffer a point, using enhanced precision.
            </summary>
            <param name="geom0">The Geometry to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <returns>The Geometry representing the buffer of the input Geometry.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsOp.ComputeResultPrecision(DotSpatial.Topology.IGeometry)">
            <summary>
            If required, returning the result to the orginal precision if required.
            In this current implementation, no rounding is performed on the
            reshifted result point, which means that it is possible
            that the returned Geometry is invalid.
            </summary>
            <param name="result">The result Geometry to modify.</param>
            <returns>The result Geometry with the required precision.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsOp.RemoveCommonBits(DotSpatial.Topology.IGeometry)">
            <summary>
            Computes a copy of the input <c>Geometry</c> with the calculated common bits
            removed from each coordinate.
            </summary>
            <param name="geom0">The Geometry to remove common bits from.</param>
            <returns>A copy of the input Geometry with common bits removed.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsOp.RemoveCommonBits(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
            <summary>
            Computes a copy of each input <c>Geometry</c>s with the calculated common bits
            removed from each coordinate.
            </summary>
            <param name="geom0">An IGeometry to remove common bits from.</param>
            <param name="geom1">An second IGeometry to remove common bits from.</param>
            <returns>
            An array containing copies
            of the input Geometry's with common bits removed.
            </returns>
        </member>
        <member name="T:DotSpatial.Topology.Precision.CommonBitsRemover">
            <summary>
            Allow computing and removing common mantissa bits from one or more Geometries.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsRemover.Add(DotSpatial.Topology.IGeometry)">
            <summary>
            Add a point to the set of geometries whose common bits are
            being computed.  After this method has executed the
            common coordinate reflects the common bits of all added
            geometries.
            </summary>
            <param name="geom">A Geometry to test for common bits.</param>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsRemover.RemoveCommonBits(DotSpatial.Topology.Geometry)">
            <summary>
            Removes the common coordinate bits from a Geometry.
            The coordinates of the Geometry are changed.
            </summary>
            <param name="geom">The Geometry from which to remove the common coordinate bits.</param>
            <returns>The shifted Geometry.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsRemover.AddCommonBits(DotSpatial.Topology.IGeometry)">
            <summary>
            Adds the common coordinate bits back into a Geometry.
            The coordinates of the Geometry are changed.
            </summary>
            <param name="geom">The Geometry to which to add the common coordinate bits.</param>
        </member>
        <member name="P:DotSpatial.Topology.Precision.CommonBitsRemover.CommonCoordinate">
            <summary>
            The common bits of the Coordinates in the supplied Geometries.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Precision.CommonBitsRemover.CommonCoordinateFilter">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsRemover.CommonCoordinateFilter.Filter(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
        </member>
        <member name="P:DotSpatial.Topology.Precision.CommonBitsRemover.CommonCoordinateFilter.CommonCoordinate">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Precision.CommonBitsRemover.Translater">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsRemover.Translater.#ctor(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="trans"></param>
        </member>
        <member name="M:DotSpatial.Topology.Precision.CommonBitsRemover.Translater.Filter(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
        </member>
        <member name="T:DotSpatial.Topology.Precision.EnhancedPrecisionOp">
            <summary>
            Provides versions of Geometry spatial functions which use
            enhanced precision techniques to reduce the likelihood of robustness problems.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Precision.EnhancedPrecisionOp.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Precision.EnhancedPrecisionOp.Intersection(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
            <summary>
            Computes the set-theoretic intersection of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic intersection of the input Geometries.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.EnhancedPrecisionOp.Union(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
            <summary>
            Computes the set-theoretic union of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic union of the input Geometries.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.EnhancedPrecisionOp.Difference(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
            <summary>
            Computes the set-theoretic difference of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic difference of the input Geometries.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.EnhancedPrecisionOp.SymDifference(DotSpatial.Topology.IGeometry,DotSpatial.Topology.IGeometry)">
            <summary>
            Computes the set-theoretic symmetric difference of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic symmetric difference of the input Geometries.</returns>
        </member>
        <member name="M:DotSpatial.Topology.Precision.EnhancedPrecisionOp.Buffer(DotSpatial.Topology.Geometry,System.Double)">
            <summary>
            Computes the buffer of a <c>Geometry</c>, using enhanced precision.
            This method should no longer be necessary, since the buffer algorithm
            now is highly robust.
            </summary>
            <param name="geom">The first Geometry.</param>
            <param name="distance">The buffer distance.</param>
            <returns>The Geometry representing the buffer of the input Geometry.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Precision.SimpleGeometryPrecisionReducer">
            <summary>
            Reduces the precision of a <c>Geometry</c>
            according to the supplied {PrecisionModel}, without
            attempting to preserve valid topology.
            The topology of the resulting point may be invalid if
            topological collapse occurs due to coordinates being shifted.
            It is up to the client to check this and handle it if necessary.
            Collapses may not matter for some uses. An example
            is simplifying the input to the buffer algorithm.
            The buffer algorithm does not depend on the validity of the input point.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Precision.SimpleGeometryPrecisionReducer.#ctor(DotSpatial.Topology.PrecisionModel)">
             <summary>
            
             </summary>
             <param name="pm"></param>
        </member>
        <member name="M:DotSpatial.Topology.Precision.SimpleGeometryPrecisionReducer.Reduce(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Precision.SimpleGeometryPrecisionReducer.RemoveCollapsedComponents">
            <summary>
            Sets whether the reduction will result in collapsed components
            being removed completely, or simply being collapsed to an (invalid)
            Geometry of the same type.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Precision.SimpleGeometryPrecisionReducer.ChangePrecisionModel">
            <summary>
            Gets/Sets whether the PrecisionModel of the new reduced Geometry
            will be changed to be the PrecisionModel supplied to
            specify the reduction.
            The default is to not change the precision model.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Precision.SimpleGeometryPrecisionReducer.PrecisionReducerCoordinateOperation">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Precision.SimpleGeometryPrecisionReducer.PrecisionReducerCoordinateOperation.#ctor(DotSpatial.Topology.Precision.SimpleGeometryPrecisionReducer)">
             <summary>
            
             </summary>
             <param name="container"></param>
        </member>
        <member name="M:DotSpatial.Topology.Precision.SimpleGeometryPrecisionReducer.PrecisionReducerCoordinateOperation.Edit(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="coordinates"></param>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.ShouldNeverReachHereException">
            <summary>
            A ShouldNeverReachHereException Class
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.ShouldNeverReachHereException.#ctor">
            <summary>
            Creates a new instance of ShouldNeverReachHereException
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Simplify.DouglasPeuckerLineSimplifier">
            <summary>
            Simplifies a line (sequence of points) using
            the standard Douglas-Peucker algorithm.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.DouglasPeuckerLineSimplifier.#ctor(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate})">
             <summary>
            
             </summary>
             <param name="pts"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.DouglasPeuckerLineSimplifier.Simplify(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Double)">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <param name="distanceTolerance"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.DouglasPeuckerLineSimplifier.Simplify">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.DouglasPeuckerLineSimplifier.SimplifySection(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <param name="j"></param>
        </member>
        <member name="T:DotSpatial.Topology.Simplify.DouglasPeuckerSimplifier">
            <summary>
            Simplifies a <c>Geometry</c> using the standard Douglas-Peucker algorithm.
            Ensures that any polygonal geometries returned are valid.
            Simple lines are not guaranteed to remain simple after simplification.
            Notice that in general D-P does not preserve topology -
            e.g. polygons can be split, collapse to lines or disappear
            holes can be created or disappear,
            and lines can cross.
            To simplify point while preserving topology use TopologySafeSimplifier.
            (However, using D-P is significantly faster).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.DouglasPeuckerSimplifier.#ctor(DotSpatial.Topology.Geometry)">
             <summary>
            
             </summary>
             <param name="inputGeom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.DouglasPeuckerSimplifier.Simplify(DotSpatial.Topology.Geometry,System.Double)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <param name="distanceTolerance"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.DouglasPeuckerSimplifier.GetResultGeometry">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.DouglasPeuckerSimplifier.DistanceTolerance">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Simplify.DouglasPeuckerSimplifier.DpTransformer">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.DouglasPeuckerSimplifier.DpTransformer.#ctor(DotSpatial.Topology.Simplify.DouglasPeuckerSimplifier)">
             <summary>
            
             </summary>
             <param name="container"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.DouglasPeuckerSimplifier.DpTransformer.TransformCoordinates(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="coords"></param>
             <param name="parent"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.DouglasPeuckerSimplifier.DpTransformer.TransformPolygon(DotSpatial.Topology.IPolygon,DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <param name="parent"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.DouglasPeuckerSimplifier.DpTransformer.TransformMultiPolygon(DotSpatial.Topology.IMultiPolygon)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.DouglasPeuckerSimplifier.DpTransformer.CreateValidArea(DotSpatial.Topology.IGeometry)">
            <summary>
            Creates a valid area point from one that possibly has
            bad topology (i.e. self-intersections).
            Since buffer can handle invalid topology, but always returns
            valid point, constructing a 0-width buffer "corrects" the
            topology.
            Notice this only works for area geometries, since buffer always returns
            areas.  This also may return empty geometries, if the input
            has no actual area.
            </summary>
            <param name="roughAreaGeom">An area point possibly containing self-intersections.</param>
            <returns>A valid area point.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Simplify.LineSegmentIndex">
            <summary>
            An index of LineSegments.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.LineSegmentIndex.Add(DotSpatial.Topology.Simplify.TaggedLineString)">
             <summary>
            
             </summary>
             <param name="line"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.LineSegmentIndex.Add(DotSpatial.Topology.LineSegment)">
             <summary>
            
             </summary>
             <param name="seg"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.LineSegmentIndex.Remove(DotSpatial.Topology.LineSegment)">
             <summary>
            
             </summary>
             <param name="seg"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.LineSegmentIndex.Query(DotSpatial.Topology.LineSegment)">
             <summary>
            
             </summary>
             <param name="querySeg"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Simplify.LineSegmentVisitor">
            <summary>
            ItemVisitor subclass to reduce volume of query results.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.LineSegmentVisitor.#ctor(DotSpatial.Topology.LineSegment)">
             <summary>
            
             </summary>
             <param name="querySeg"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.LineSegmentVisitor.VisitItem(System.Object)">
             <summary>
            
             </summary>
             <param name="item"></param>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.LineSegmentVisitor.Items">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Simplify.TaggedLineSegment">
            <summary>
            A LineSegment which is tagged with its location in a <c>Geometry</c>.
            Used to index the segments in a point and recover the segment locations
            from the index.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineSegment.#ctor(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate,DotSpatial.Topology.IGeometry,System.Int32)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
             <param name="parent"></param>
             <param name="index"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineSegment.#ctor(DotSpatial.Topology.Coordinate,DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="p0"></param>
             <param name="p1"></param>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.TaggedLineSegment.Parent">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.TaggedLineSegment.Index">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Simplify.TaggedLinesSimplifier">
            <summary>
            Simplifies a collection of TaggedLineStrings, preserving topology
            (in the sense that no new intersections are introduced).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLinesSimplifier.Simplify(System.Collections.IList)">
            <summary>
            Simplify a collection of <c>TaggedLineString</c>s.
            </summary>
            <param name="taggedLines">The collection of lines to simplify.</param>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.TaggedLinesSimplifier.DistanceTolerance">
            <summary>
            Gets/Sets the distance tolerance for the simplification.
            Points closer than this tolerance to a simplified segment may
            be removed.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Simplify.TaggedLineString">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineString.#ctor(DotSpatial.Topology.LineString)">
             <summary>
            
             </summary>
             <param name="parentLine"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineString.#ctor(DotSpatial.Topology.LineString,System.Int32)">
             <summary>
            
             </summary>
             <param name="parentLine"></param>
             <param name="minimumSize"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineString.GetSegment(System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineString.Init">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineString.AddToResult(DotSpatial.Topology.LineSegment)">
             <summary>
            
             </summary>
             <param name="seg"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineString.AsLineString">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineString.AsLinearRing">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineString.ExtractCoordinates(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="segs"></param>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.TaggedLineString.MinimumSize">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.TaggedLineString.Parent">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.TaggedLineString.ParentCoordinates">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.TaggedLineString.ResultCoordinates">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.TaggedLineString.ResultSize">
             <summary>
            
             </summary>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.TaggedLineString.Segments">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier">
            <summary>
            Simplifies a TaggedLineString, preserving topology
            (in the sense that no new intersections are introduced).
            Uses the recursive D-P algorithm.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier.#ctor(DotSpatial.Topology.Simplify.LineSegmentIndex,DotSpatial.Topology.Simplify.LineSegmentIndex)">
             <summary>
            
             </summary>
             <param name="inputIndex"></param>
             <param name="outputIndex"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier.Simplify(DotSpatial.Topology.Simplify.TaggedLineString)">
             <summary>
            
             </summary>
             <param name="line"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier.SimplifySection(System.Int32,System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="i"></param>
             <param name="j"></param>
             <param name="depth"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier.FindFurthestPoint(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},System.Int32,System.Int32,System.Double[])">
             <summary>
            
             </summary>
             <param name="pts"></param>
             <param name="i"></param>
             <param name="j"></param>
             <param name="maxDistance"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier.Flatten(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="start"></param>
             <param name="end"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier.HasBadIntersection(DotSpatial.Topology.Simplify.TaggedLineString,System.Int32[],DotSpatial.Topology.LineSegment)">
             <summary>
            
             </summary>
             <param name="parentLine"></param>
             <param name="sectionIndex"></param>
             <param name="candidateSeg"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier.HasBadOutputIntersection(DotSpatial.Topology.LineSegment)">
             <summary>
            
             </summary>
             <param name="candidateSeg"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier.HasBadInputIntersection(DotSpatial.Topology.Simplify.TaggedLineString,System.Int32[],DotSpatial.Topology.LineSegment)">
             <summary>
            
             </summary>
             <param name="parentLine"></param>
             <param name="sectionIndex"></param>
             <param name="candidateSeg"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier.IsInLineSection(DotSpatial.Topology.Simplify.TaggedLineString,System.Int32[],DotSpatial.Topology.Simplify.TaggedLineSegment)">
            <summary>
            Tests whether a segment is in a section of a TaggedLineString-
            </summary>
            <param name="line"></param>
            <param name="sectionIndex"></param>
            <param name="seg"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier.HasInteriorIntersection(DotSpatial.Topology.ILineSegmentBase,DotSpatial.Topology.ILineSegmentBase)">
             <summary>
            
             </summary>
             <param name="seg0"></param>
             <param name="seg1"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier.Remove(DotSpatial.Topology.Simplify.TaggedLineString,System.Int32,System.Int32)">
            <summary>
            Remove the segs in the section of the line.
            </summary>
            <param name="line"></param>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.TaggedLineStringSimplifier.DistanceTolerance">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Simplify.TopologyPreservingSimplifier">
            <summary>
            Simplifies a point, ensuring that
            the result is a valid point having the
            same dimension and number of components as the input.
            The simplification uses a maximum distance difference algorithm
            similar to the one used in the Douglas-Peucker algorithm.
            In particular, if the input is an areal point
            ( <c>Polygon</c> or <c>MultiPolygon</c> )
            The result has the same number of shells and holes (rings) as the input,
            in the same order
            The result rings touch at no more than the number of touching point in the input
            (although they may touch at fewer points).
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TopologyPreservingSimplifier.#ctor(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="inputGeom"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TopologyPreservingSimplifier.Simplify(DotSpatial.Topology.IGeometry,System.Double)">
             <summary>
            
             </summary>
             <param name="geom"></param>
             <param name="distanceTolerance"></param>
             <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TopologyPreservingSimplifier.GetResultGeometry">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Simplify.TopologyPreservingSimplifier.DistanceTolerance">
             <summary>
            
             </summary>
        </member>
        <member name="T:DotSpatial.Topology.Simplify.TopologyPreservingSimplifier.LineStringMapBuilderFilter">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TopologyPreservingSimplifier.LineStringMapBuilderFilter.#ctor(DotSpatial.Topology.Simplify.TopologyPreservingSimplifier)">
             <summary>
            
             </summary>
             <param name="container"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TopologyPreservingSimplifier.LineStringMapBuilderFilter.Filter(DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="geom"></param>
        </member>
        <member name="T:DotSpatial.Topology.Simplify.TopologyPreservingSimplifier.LineStringTransformer">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TopologyPreservingSimplifier.LineStringTransformer.#ctor(DotSpatial.Topology.Simplify.TopologyPreservingSimplifier)">
             <summary>
            
             </summary>
             <param name="container"></param>
        </member>
        <member name="M:DotSpatial.Topology.Simplify.TopologyPreservingSimplifier.LineStringTransformer.TransformCoordinates(System.Collections.Generic.IList{DotSpatial.Topology.Coordinate},DotSpatial.Topology.IGeometry)">
             <summary>
            
             </summary>
             <param name="coords"></param>
             <param name="parent"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.Assert">
            <summary>
            A utility for making programming assertions.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.Assert.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.Assert.IsTrue(System.Boolean)">
             <summary>
            
             </summary>
             <param name="assertion"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.Assert.IsTrue(System.Boolean,System.String)">
             <summary>
            
             </summary>
             <param name="assertion"></param>
             <param name="message"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.Assert.IsEquals(System.Object,System.Object)">
             <summary>
            
             </summary>
             <param name="expectedValue"></param>
             <param name="actualValue"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.Assert.IsEquals(System.Object,System.Object,System.String)">
             <summary>
            
             </summary>
             <param name="expectedValue"></param>
             <param name="actualValue"></param>
             <param name="message"></param>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.AssertionFailedException">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.AssertionFailedException.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.AssertionFailedException.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="message"></param>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.CollectionUtil">
            <summary>
            Executes a transformation function on each element of a collection
            and returns the results in a new List.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.CollectionUtil.Transform(System.Collections.ICollection,DotSpatial.Topology.Utilities.CollectionUtil.GenericMethod{System.Object})">
            <summary>
            Executes a function on each item in a <see cref="T:System.Collections.ICollection"/>
            and returns the results in a new <see cref="T:System.Collections.IList"/>.
            </summary>
            <param name="coll"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.CollectionUtil.Apply(System.Collections.ICollection,DotSpatial.Topology.Utilities.CollectionUtil.GenericMethod{System.Object})">
            <summary>
            Executes a function on each item in a <see cref="T:System.Collections.ICollection"/>
            but does not accumulate the result.
            </summary>
            <param name="coll"></param>
            <param name="func"></param>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.CollectionUtil.Select(System.Collections.ICollection,DotSpatial.Topology.Utilities.CollectionUtil.GenericMethod{System.Object})">
            <summary>
            Executes a function on each item in a <see cref="T:System.Collections.ICollection"/>
            and collects all the entries for which the result
            of the function is equal to <c>true</c>.
            </summary>
            <param name="coll"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.CollectionUtil.GenericMethod`1">
            <summary>
            The FunctionDelegate defines a structure taking a strong type in and passing a member of the same type back out.
            </summary>
            <typeparam name="T">The type for the method.</typeparam>
            <param name="obj">The object parameter for the method.</param>
            <returns>An object of type T.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.Global">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.Global.GetNfi">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.HexConverter">
             <summary>
            
             </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.HexConverter.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.HexConverter.ConvertAny2Any(System.String,System.Int32,System.Int32)">
            <summary>
            Convert the given numeric value (passed as string) of the base specified by <c>baseIn</c>
            to the value specified by <c>baseOut</c>.
            </summary>
            <param name="valueIn">Numeric value to be converted, as string.</param>
            <param name="baseIn">Base of input value.</param>
            <param name="baseOut">Base to use for conversion.</param>
            <returns>Converted value, as string.</returns>
        </member>
        <member name="T:Iesi.Collections.DictionarySet">
             <summary>
             <p><c>DictionarySet</c> is an abstract class that supports the creation of new <c>Set</c>
             types where the underlying data store is an <c>IDictionary</c> instance.</p>
            
             <p>You can use any object that implements the <c>IDictionary</c> interface to hold set data.
             You can define your own, or you can use one of the objects provided in the Framework.
             The type of <c>IDictionary</c> you choose will affect both the performance and the behavior
             of the <c>Set</c> using it. </p>
            
             <p>To make a <c>Set</c> typed based on your own <c>IDictionary</c>, simply derive a
             new class with a constructor that takes no parameters.  Some <c>Set</c> implmentations
             cannot be defined with a default constructor.  If this is the case for your class,
             you will need to override <c>Clone()</c> as well.</p>
            
             <p>It is also standard practice that at least one of your constructors takes an <c>ICollection</c> or
             an <c>ISet</c> as an argument.</p>
             </summary>
        </member>
        <member name="T:Iesi.Collections.Set">
             <summary><p>A collection that contains no duplicate elements.  This class models the mathematical
             <c>Set</c> abstraction, and is the base class for all other <c>Set</c> implementations.
             The order of elements in a set is dependant on (a)the data-structure implementation, and
             (b)the implementation of the various <c>Set</c> methods, and thus is not guaranteed.</p>
            
             <p>None of the <c>Set</c> implementations in this library are guranteed to be thread-safe
             in any way unless wrapped in a <c>SynchronizedSet</c>.</p>
            
             <p>The following table summarizes the binary operators that are supported by the <c>Set</c> class.</p>
             <list type="table">
            		<listheader>
            			<term>Operation</term>
            			<term>Description</term>
            			<term>Method</term>
            			<term>Operator</term>
            		</listheader>
            		<item>
            			<term>Union (OR)</term>
            			<term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            			<term><c>Union()</c></term>
            			<term><c>|</c></term>
            		</item>
            		<item>
            			<term>Intersection (AND)</term>
            			<term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            			<term><c>InterSect()</c></term>
            			<term><c>&amp;</c></term>
            		</item>
            		<item>
            			<term>Exclusive Or (XOR)</term>
            			<term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            			<term><c>ExclusiveOr()</c></term>
            			<term><c>^</c></term>
            		</item>
            		<item>
            			<term>Minus (n/a)</term>
            			<term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            			them.  Notice that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            			<term><c>Minus()</c></term>
            			<term><c>-</c></term>
            		</item>
             </list>
             </summary>
        </member>
        <member name="T:Iesi.Collections.ISet">
             <summary>
             <p>A collection that contains no duplicate elements.  This interface models the mathematical
             <c>Set</c> abstraction.
             The order of elements in a set is dependant on (a)the data-structure implementation, and
             (b)the implementation of the various <c>Set</c> methods, and thus is not guaranteed.</p>
            
             <p>None of the <c>Set</c> implementations in this library are guranteed to be thread-safe
             in any way unless wrapped in a <c>SynchronizedSet</c>.</p>
            
             <p>The following table summarizes the binary operators that are supported by the <c>Set</c> class.</p>
             <list type="table">
            		<listheader>
            			<term>Operation</term>
            			<term>Description</term>
            			<term>Method</term>
            		</listheader>
            		<item>
            			<term>Union (OR)</term>
            			<term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            			<term><c>Union()</c></term>
            		</item>
            		<item>
            			<term>Intersection (AND)</term>
            			<term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            			<term><c>InterSect()</c></term>
            		</item>
            		<item>
            			<term>Exclusive Or (XOR)</term>
            			<term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            			<term><c>ExclusiveOr()</c></term>
            		</item>
            		<item>
            			<term>Minus (n/a)</term>
            			<term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            			them.  Notice that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            			<term><c>Minus()</c></term>
            		</item>
             </list>
             </summary>
        </member>
        <member name="M:Iesi.Collections.ISet.Union(Iesi.Collections.ISet)">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
            <param name="a">A collection of elements.</param>
            <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.Intersect(Iesi.Collections.ISet)">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <c>a</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.Minus(Iesi.Collections.ISet)">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.ExclusiveOr(Iesi.Collections.ISet)">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.Contains(System.Object)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.ContainsAll(System.Collections.ICollection)">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.Add(System.Object)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.Remove(System.Object)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.RemoveAll(System.Collections.ICollection)">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.RetainAll(System.Collections.ICollection)">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="P:Iesi.Collections.ISet.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Set.Union(Iesi.Collections.ISet)">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
            <param name="a">A collection of elements.</param>
            <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Intersect(Iesi.Collections.ISet)">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <c>a</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Minus(Iesi.Collections.ISet)">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.ExclusiveOr(Iesi.Collections.ISet)">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Add(System.Object)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Set.Contains(System.Object)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.ContainsAll(System.Collections.ICollection)">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Remove(System.Object)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.RemoveAll(System.Collections.ICollection)">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.RetainAll(System.Collections.ICollection)">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Clone">
            <summary>
            Returns a clone of the <c>Set</c> instance.  This will work for derived <c>Set</c>
            classes if the derived class implements a constructor that takes no arguments.
            </summary>
            <returns>A clone of this object.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Iesi.Collections.Set.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
            <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Union(Iesi.Collections.ISet,Iesi.Collections.ISet)">
            <summary>
            Performs a "union" of two sets, where all the elements
            in both are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            The return value is a <c>Clone()</c> of one of the sets (<c>a</c> if it is not <c>null</c>) with elements of the other set
            added in.  Neither of the input sets is modified by the operation.
            </summary>
            <param name="a">The left hand side set of elements to union.</param>
            <param name="b">The right hand side set of elements to union.</param>
            <returns>A set containing the union of the input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.op_BitwiseOr(Iesi.Collections.Set,Iesi.Collections.Set)">
            <summary>
            Performs a "union" of two sets, where all the elements
            in both are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            The return value is a <c>Clone()</c> of one of the sets (<c>a</c> if it is not <c>null</c>) with elements of the other set
            added in.  Neither of the input sets is modified by the operation.
            </summary>
            <param name="a">The left hand side set of elements to union.</param>
            <param name="b">The right hand side set of elements to union.</param>
            <returns>A set containing the union of the input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Intersect(Iesi.Collections.ISet,Iesi.Collections.ISet)">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <c>a</c> and <c>b</c>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<c>a</c> if it is not <c>null</c>) containing the
            elements from the intersect operation.
            </summary>
            <param name="a">The left hand side set of elements to intersect.</param>
            <param name="b">The right hand side set of elements to intersect.</param>
            <returns>The intersection of the two input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.op_BitwiseAnd(Iesi.Collections.Set,Iesi.Collections.Set)">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <c>a</c> and <c>b</c>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<c>a</c> if it is not <c>null</c>) containing the
            elements from the intersect operation.
            </summary>
            <param name="a">The left hand side set of elements to intersect.</param>
            <param name="b">the right hand side set of elements to intersect.</param>
            <returns>The intersection of the two input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Minus(Iesi.Collections.ISet,Iesi.Collections.ISet)">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <c>a</c> containing the elements from the operation.
            </summary>
            <param name="a">The left hand side set of elements to subtract from.</param>
            <param name="b">the right hand side set of elements to subtract.</param>
            <returns>A set containing <c>A - B</c> elements.  <c>null</c> if <c>a</c> is <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.op_Subtraction(Iesi.Collections.Set,Iesi.Collections.Set)">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <c>a</c> containing the elements from the operation.
            </summary>
            <param name="a">The left hand side set of elements to subtract from.</param>
            <param name="b">The right hand side set of elements to subtract.</param>
            <returns>A set containing <c>A - B</c> elements.  <c>null</c> if <c>a</c> is <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.ExclusiveOr(Iesi.Collections.ISet,Iesi.Collections.ISet)">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of one of the sets
            (<c>a</c> if it is not <c>null</c>) containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">One set of elements to use exclusive or with.</param>
            <param name="b">The other set of elements to use exclusive or with.</param>
            <returns>A set containing the result of <c>a ^ b</c>.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.op_ExclusiveOr(Iesi.Collections.Set,Iesi.Collections.Set)">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of one of the sets
            (<c>a</c> if it is not <c>null</c>) containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">One set of elements to use exclusive or with.</param>
            <param name="b">The other set of elements to use exclusive or with.</param>
            <returns>A set containing the result of <c>a ^ b</c>.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="P:Iesi.Collections.Set.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Set.Count">
            <summary>
            The number of elements currently contained in this collection.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Set.IsSynchronized">
            <summary>
            Returns <c>true</c> if the <c>Set</c> is synchronized across threads.  Notice that
            enumeration is inherently not thread-safe.  Use the <c>SyncRoot</c> to lock the
            object during enumeration.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Set.SyncRoot">
            <summary>
            An object that can be used to synchronize this collection to make it thread-safe.
            When implementing this, if your object uses a base object, like an <c>IDictionary</c>,
            or anything that has a <c>SyncRoot</c>, return that object instead of "<c>this</c>".
            </summary>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.Add(System.Object)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.Contains(System.Object)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.ContainsAll(System.Collections.ICollection)">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.Remove(System.Object)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.RemoveAll(System.Collections.ICollection)">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.RetainAll(System.Collections.ICollection)">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
            <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
        </member>
        <member name="P:Iesi.Collections.DictionarySet.InternalDictionary">
            <summary>
            Provides the storage for elements in the <c>Set</c>, stored as the key-set
            of the <c>IDictionary</c> object.  Set this object in the constructor
            if you create your own <c>Set</c> class.
            </summary>
        </member>
        <member name="P:Iesi.Collections.DictionarySet.Placeholder">
            <summary>
            The placeholder object used as the value for the <c>IDictionary</c> instance.
            </summary>
            <remarks>
            There is a single instance of this object globally, used for all <c>Sets</c>.
            </remarks>
        </member>
        <member name="P:Iesi.Collections.DictionarySet.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Iesi.Collections.DictionarySet.Count">
            <summary>
            The number of elements contained in this collection.
            </summary>
        </member>
        <member name="P:Iesi.Collections.DictionarySet.IsSynchronized">
            <summary>
            None of the objects based on <c>DictionarySet</c> are synchronized.  Use the
            <c>SyncRoot</c> property instead.
            </summary>
        </member>
        <member name="P:Iesi.Collections.DictionarySet.SyncRoot">
            <summary>
            Returns an object that can be used to synchronize the <c>Set</c> between threads.
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.CollectionWrapper`1">
            <summary>
            Generic Collection wrapper
            </summary>
            <typeparam name="T">The type of the collection wrapper.</typeparam>
        </member>
        <member name="T:Iesi.Collections.Generic.EnumerableWrapper`1">
            <summary>
            A Simple Wrapper for wrapping an regular Enumerable as a generic Enumberable&lt;T&gt;
            </summary>
            <typeparam name="T">The type of the enumerable wrapper.</typeparam>
            <exception cref="T:System.InvalidCastException">
            If the wrapped has any item that is not of Type T, InvalidCastException could be thrown at any time
            </exception>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumerableWrapper`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            Constructor
            </summary>
            <param name="innerEnumerable"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumerableWrapper`1.GetEnumerator">
            <summary>
            Gets an enumerator for this Enumerable Wrapper
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumerableWrapper`1.Equals(System.Object)">
            <summary>
            Tests equality
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumerableWrapper`1.GetHashCode">
            <summary>
            Obtains a hash code
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.#ctor(System.Collections.ICollection)">
            <summary>
            Constructor for CollectionWrapper
            </summary>
            <param name="toWrap">The Collection to Wrap</param>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.Add(`0)">
            <summary>
            Throws a readonly exception
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.Clear">
            <summary>
             Throws a readonly exception
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.Contains(`0)">
            <summary>
            Returns a boolean that is true if this collection contains item
            </summary>
            <param name="item">The item to test</param>
            <returns>A Boolean that is true if this collection contains item</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies all the members of array to this set
            </summary>
            <param name="array">The array to copy</param>
            <param name="arrayIndex">The index with which to start copying</param>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.Remove(`0)">
            <summary>
            Throws a readonly exception
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:Iesi.Collections.Generic.CollectionWrapper`1.Count">
            <summary>
            The integer count
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.CollectionWrapper`1.IsReadOnly">
            <summary>
            Always returns True
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.DictionarySet`1">
             <summary>
             <p><c>DictionarySet</c> is an abstract class that supports the creation of new <c>Set</c>
             types where the underlying data store is an <c>IDictionary</c> instance.</p>
            
             <p>You can use any object that implements the <c>IDictionary</c> interface to hold set data.
             You can define your own, or you can use one of the objects provided in the Framework.
             The type of <c>IDictionary</c> you choose will affect both the performance and the behavior
             of the <c>Set</c> using it. </p>
            
             <p>To make a <c>Set</c> typed based on your own <c>IDictionary</c>, simply derive a
             new class with a constructor that takes no parameters.  Some <c>Set</c> implmentations
             cannot be defined with a default constructor.  If this is the case for your class,
             you will need to override <c>Clone()</c> as well.</p>
            
             <p>It is also standard practice that at least one of your constructors takes an <c>ICollection</c> or
             an <c>ISet</c> as an argument.</p>
             </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.Set`1">
             <summary><p>A collection that contains no duplicate elements.  This class models the mathematical
             <c>Set</c> abstraction, and is the base class for all other <c>Set</c> implementations.
             The order of elements in a set is dependant on (a)the data-structure implementation, and
             (b)the implementation of the various <c>Set</c> methods, and thus is not guaranteed.</p>
            
             <p>None of the <c>Set</c> implementations in this library are guranteed to be thread-safe
             in any way.</p>
            
             <p>The following table summarizes the binary operators that are supported by the <c>Set</c> class.</p>
             <list type="table">
            		<listheader>
            			<term>Operation</term>
            			<term>Description</term>
            			<term>Method</term>
            			<term>Operator</term>
            		</listheader>
            		<item>
            			<term>Union (OR)</term>
            			<term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            			<term><c>Union()</c></term>
            			<term><c>|</c></term>
            		</item>
            		<item>
            			<term>Intersection (AND)</term>
            			<term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            			<term><c>InterSect()</c></term>
            			<term><c>&amp;</c></term>
            		</item>
            		<item>
            			<term>Exclusive Or (XOR)</term>
            			<term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            			<term><c>ExclusiveOr()</c></term>
            			<term><c>^</c></term>
            		</item>
            		<item>
            			<term>Minus (n/a)</term>
            			<term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            			them.  Notice that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            			<term><c>Minus()</c></term>
            			<term><c>-</c></term>
            		</item>
             </list>
             </summary>
             <remarks>
                 Set&lt;T&gt; supports operator between Set&lt;T&gt; and ISet, however, the ISet must contains only elements of type T
             </remarks>
        </member>
        <member name="T:Iesi.Collections.Generic.ISet`1">
             <summary>
             <p>A collection that contains no duplicate elements.  This interface models the mathematical
             <c>Set</c> abstraction.
             The order of elements in a set is dependant on (a)the data-structure implementation, and
             (b)the implementation of the various <c>Set</c> methods, and thus is not guaranteed.</p>
            
             <p>None of the <c>Set</c> implementations in this library are guranteed to be thread-safe
             in any way.</p>
            
             <p>The following table summarizes the binary operators that are supported by the <c>Set</c> class.</p>
             <list type="table">
            		<listheader>
            			<term>Operation</term>
            			<term>Description</term>
            			<term>Method</term>
            		</listheader>
            		<item>
            			<term>Union (OR)</term>
            			<term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            			<term><c>Union()</c></term>
            		</item>
            		<item>
            			<term>Intersection (AND)</term>
            			<term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            			<term><c>InterSect()</c></term>
            		</item>
            		<item>
            			<term>Exclusive Or (XOR)</term>
            			<term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            			<term><c>ExclusiveOr()</c></term>
            		</item>
            		<item>
            			<term>Minus (n/a)</term>
            			<term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            			them.  Notice that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            			<term><c>Minus()</c></term>
            		</item>
             </list>
             </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Union(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
            <param name="a">A collection of elements.</param>
            <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Intersect(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <c>a</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Minus(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Contains(`0)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Add(`0)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Remove(`0)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Clone">
            <summary>
            Creates a new version if the ISet
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iesi.Collections.Generic.ISet`1.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Union(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
            <param name="a">A collection of elements.</param>
            <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Intersect(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <c>a</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Minus(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
            <param name="a">The set of elements to negate.</param>
            <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Add(`0)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Remove(`0)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as
            a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Contains(`0)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Union(Iesi.Collections.Generic.ISet{`0},Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "union" of two sets, where all the elements
            in both are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            The return value is a <c>Clone()</c> of one of the sets (<c>a</c> if it is not <c>null</c>) with elements of the other set
            added in.  Neither of the input sets is modified by the operation.
            </summary>
            <param name="a">The original set of elements to union with.</param>
            <param name="b">The additional set of elements to union.</param>
            <returns>A set containing the union of the input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.op_BitwiseOr(Iesi.Collections.Generic.Set{`0},Iesi.Collections.Generic.Set{`0})">
            <summary>
            Performs a "union" of two sets, where all the elements
            in both are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            The return value is a <c>Clone()</c> of one of the sets (<c>a</c> if it is not <c>null</c>) with elements of the other set
            added in.  Neither of the input sets is modified by the operation.
            </summary>
            <param name="a">The left hand side set of elements to union with.</param>
            <param name="b">The right hand side set of elements to union.</param>
            <returns>A set containing the union of the input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Intersect(Iesi.Collections.Generic.ISet{`0},Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <c>a</c> and <c>b</c>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<c>a</c> if it is not <c>null</c>) containing the
            elements from the intersect operation.
            </summary>
            <param name="a">The original set of elements.</param>
            <param name="b">The set of elements to intersect with.</param>
            <returns>The intersection of the two input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.op_BitwiseAnd(Iesi.Collections.Generic.Set{`0},Iesi.Collections.Generic.Set{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <c>a</c> and <c>b</c>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<c>a</c> if it is not <c>null</c>) containing the
            elements from the intersect operation.
            </summary>
            <param name="a">The original set of elements.</param>
            <param name="b">The set of elements to intersect with.</param>
            <returns>The intersection of the two input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Minus(Iesi.Collections.Generic.ISet{`0},Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <c>a</c> containing the elements from the operation.
            </summary>
            <param name="a">The original set of elements to subtract from.</param>
            <param name="b">The set of elements to subtract.</param>
            <returns>A set containing <c>A - B</c> elements.  <c>null</c> if <c>a</c> is <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.op_Subtraction(Iesi.Collections.Generic.Set{`0},Iesi.Collections.Generic.Set{`0})">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <c>a</c> containing the elements from the operation.
            </summary>
            <param name="a">The left hand side set of elements to subtract from.</param>
            <param name="b">the right hand side set of elements to subtract.</param>
            <returns>A set containing <c>A - B</c> elements.  <c>null</c> if <c>a</c> is <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0},Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of one of the sets
            (<c>a</c> if it is not <c>null</c>) containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">The original set of elements to use for exclusive or.</param>
            <param name="b">The alternate set of elements to use for exclusive or.</param>
            <returns>A set containing the result of <c>a ^ b</c>.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.op_ExclusiveOr(Iesi.Collections.Generic.Set{`0},Iesi.Collections.Generic.Set{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of one of the sets
            (<c>a</c> if it is not <c>null</c>) containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">The left hand side set of elements to exclusive or.</param>
            <param name="b">The right hand side set of elements to exclusive or.</param>
            <returns>A set containing the result of <c>a ^ b</c>.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Clone">
            <summary>
            Returns a clone of the <c>Set</c> instance.  This will work for derived <c>Set</c>
            classes if the derived class implements a constructor that takes no arguments.
            </summary>
            <returns>A clone of this object.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
            <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
        </member>
        <member name="P:Iesi.Collections.Generic.Set`1.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.Set`1.IsSynchronized">
            <summary>
            Returns <c>true</c> if the <c>Set</c> is synchronized across threads.  Notice that
            enumeration is inherently not thread-safe.  Use the <c>SyncRoot</c> to lock the
            object during enumeration.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.Set`1.SyncRoot">
            <summary>
            An object that can be used to synchronize this collection to make it thread-safe.
            When implementing this, if your object uses a base object, like an <c>IDictionary</c>,
            or anything that has a <c>SyncRoot</c>, return that object instead of "<c>this</c>".
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.Set`1.Count">
            <summary>
            The number of elements currently contained in this collection.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.Set`1.IsReadOnly">
            <summary>
            Returns whether this collection is readonly.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.Add(`0)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.Contains(`0)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.Remove(`0)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
            <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
        </member>
        <member name="P:Iesi.Collections.Generic.DictionarySet`1.InternalDictionary">
            <summary>
            Provides the storage for elements in the <c>Set</c>, stored as the key-set
            of the <c>IDictionary</c> object.  Set this object in the constructor
            if you create your own <c>Set</c> class.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.DictionarySet`1.Placeholder">
            <summary>
            The placeholder object used as the value for the <c>IDictionary</c> instance.
            </summary>
            <remarks>
            There is a single instance of this object globally, used for all <c>Sets</c>.
            </remarks>
        </member>
        <member name="P:Iesi.Collections.Generic.DictionarySet`1.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.DictionarySet`1.Count">
            <summary>
            The number of elements contained in this collection.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.DictionarySet`1.IsSynchronized">
            <summary>
            Gets a boolean that indicates whether the dictionary is synchronized
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.DictionarySet`1.SyncRoot">
            <summary>
            Not Implemented
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.EnumeratorWrapper`1">
            <summary>
            Simple Wrapper for wrapping an regular Enumerator as a generic Enumberator&lt;T&gt;
            </summary>
            <typeparam name="T">The type of the enumeration wrapper.</typeparam>
            <exception cref="T:System.InvalidCastException">
            If the wrapped has any item that is not of Type T, InvalidCastException could be thrown at any time
            </exception>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumeratorWrapper`1.#ctor(System.Collections.IEnumerator)">
            <summary>
            Constructor
            </summary>
            <param name="toWrap"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumeratorWrapper`1.Dispose">
            <summary>
            Disposes the innerEnumerator
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumeratorWrapper`1.MoveNext">
            <summary>
            Moves to the next element
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumeratorWrapper`1.Reset">
            <summary>
            Resets the enumerator to the starting position
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.EnumeratorWrapper`1.Current">
            <summary>
            The current member being enumerated
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.HashedSet`1">
            <summary>
            Implements a <c>Set</c> based on a hash table.  This will give the best lookup, add, and remove
            performance for very large data-sets, but iteration will occur in no particular order.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.HashedSet`1.#ctor">
            <summary>
            Creates a new set instance based on a hash table.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.HashedSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates a new set instance based on a hash table and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="T:Iesi.Collections.Generic.HybridSet`1">
            <summary>
            Implements a <c>Set</c> that automatically changes from a list to a hash table
            when the size reaches a certain threshold.  This is good if you are unsure about
            whether you data-set will be tiny or huge.  Because this uses a dual implementation,
            iteration order is not guaranteed!
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.HybridSet`1.#ctor">
            <summary>
            Creates a new set instance based on either a list or a hash table, depending on which
            will be more efficient based on the data-set size.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.HybridSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates a new set instance based on either a list or a hash table, depending on which
            will be more efficient based on the data-set size, and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.Iesi.Collections.Generic.ReadOnlyException">
            <summary>
            Read only exception
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.Iesi.Collections.Generic.ReadOnlyException.#ctor">
            <summary>
            Creates a new instance of a ReadOnlyException
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.SetWrapper`1">
            <summary>
            A wrapper that can wrap a ISet as a generic ISet&lt;T&gt;
            </summary>
            <typeparam name="T">The type of the set.</typeparam>
            <remarks>
            In most operations, there is no copying of collections. The wrapper just delegate the function to the wrapped.
            The following functions' implementation may involve collection copying:
            Union, Intersect, Minus, ExclusiveOr, ContainsAll, AddAll, RemoveAll, RetainAll
            </remarks>
            <exception cref="T:System.InvalidCastException">
            If the wrapped has any item that is not of Type T, InvalidCastException could be thrown at any time
            </exception>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.#ctor(Iesi.Collections.ISet)">
            <summary>
            Sets the Wrapper
            </summary>
            <param name="toWrap"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Union(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Combines the two Sets
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Intersect(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Intersects the two sets
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Minus(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Subtracts a set from this set
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Creates a new set that includes members in one group or the other but not both
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Contains(`0)">
            <summary>
            Gets or sets a boolean that is true if this set contains o
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            returns a boolean that is true if this set contains all the members of c
            </summary>
            <param name="c">The Collection to test</param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Add(`0)">
            <summary>
            Attempts to add o to this set, and returns true if successful
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Attempts to add the collection c to this set and returns true if successful
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Remove(`0)">
            <summary>
            Attempts to remove o from this set and returns true if successful
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Attempts to remove every member of c from this set and returns true if successful
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Removes any members not in c from this set and returns true if successful
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Clear">
            <summary>
            Clears all the members of the set
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Clone">
            <summary>
            Creates a deep copy of all the members of this set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies all the members of the specified arrayIndex to this set
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.GetEnumerator">
            <summary>
            Creates an enumerator for this set
            </summary>
            <returns>A type specific EnumeratorWrapper </returns>
        </member>
        <member name="P:Iesi.Collections.Generic.SetWrapper`1.IsEmpty">
            <summary>
            Gets a boolean that indicates if this set is empty
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.SetWrapper`1.Count">
            <summary>
            Gets an integer specifying the number of members to this set
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.SetWrapper`1.IsReadOnly">
            <summary>
            Gets a boolean indicating if this set is readonly
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.SortedSet`1">
            <summary>
            Implements a <c>Set</c> based on a sorted tree.  This gives good performance for operations on very
            large data-sets, though not as good - asymptotically - as a <c>HashedSet</c>.  However, iteration
            occurs in order.  Elements that you put into this type of collection must implement <c>IComparable</c>,
            and they must actually be comparable.  You can't mix <c>string</c> and <c>int</c> values, for example.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor">
            <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
            <param name="comparer">The IComparer to use for sorting.</param>
        </member>
        <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.ICollection{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
            <param name="comparer">The IComparer to use for sorting.</param>
        </member>
        <member name="T:Iesi.Collections.HashedSet">
            <summary>
            Implements a <c>Set</c> based on a hash table.  This will give the best lookup, add, and remove
            performance for very large data-sets, but iteration will occur in no particular order.
            </summary>
        </member>
        <member name="M:Iesi.Collections.HashedSet.#ctor">
            <summary>
            Creates a new set instance based on a hash table.
            </summary>
        </member>
        <member name="M:Iesi.Collections.HashedSet.#ctor(System.Collections.ICollection)">
            <summary>
            Creates a new set instance based on a hash table and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="T:Iesi.Collections.HybridSet">
            <summary>
            Implements a <c>Set</c> that automatically changes from a list to a hash table
            when the size reaches a certain threshold.  This is good if you are unsure about
            whether you data-set will be tiny or huge.  Because this uses a dual implementation,
            iteration order is not guaranteed!
            </summary>
        </member>
        <member name="M:Iesi.Collections.HybridSet.#ctor">
            <summary>
            Creates a new set instance based on either a list or a hash table, depending on which
            will be more efficient based on the data-set size.
            </summary>
        </member>
        <member name="M:Iesi.Collections.HybridSet.#ctor(System.Collections.ICollection)">
            <summary>
            Creates a new set instance based on either a list or a hash table, depending on which
            will be more efficient based on the data-set size, and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="T:Iesi.Collections.ListSet">
            <summary>
            Implements a <c>Set</c> based on a list.  Performance is much better for very small lists
            than either <c>HashedSet</c> or <c>SortedSet</c>.  However, performance degrades rapidly as
            the data-set gets bigger.  Use a <c>HybridSet</c> instead if you are not sure your data-set
            will always remain very small.  Iteration produces elements in the order they were added.
            However, element order is not guaranteed to be maintained by the various <c>Set</c>
            mathematical operators.
            </summary>
        </member>
        <member name="M:Iesi.Collections.ListSet.#ctor">
            <summary>
            Creates a new set instance based on a list.
            </summary>
        </member>
        <member name="M:Iesi.Collections.ListSet.#ctor(System.Collections.ICollection)">
            <summary>
            Creates a new set instance based on a list and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="T:Iesi.Collections.SortedSet">
            <summary>
            Implements a <c>Set</c> based on a sorted tree.  This gives good performance for operations on very
            large data-sets, though not as good - asymptotically - as a <c>HashedSet</c>.  However, iteration
            occurs in order.  Elements that you put into this type of collection must implement <c>IComparable</c>,
            and they must actually be comparable.  You can't mix <c>string</c> and <c>int</c> values, for example.
            </summary>
        </member>
        <member name="M:Iesi.Collections.SortedSet.#ctor">
            <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
        </member>
        <member name="M:Iesi.Collections.SortedSet.#ctor(System.Collections.IComparer)">
            <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.IComparer"/> to use for sorting.</param>
        </member>
        <member name="M:Iesi.Collections.SortedSet.#ctor(System.Collections.ICollection)">
            <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="M:Iesi.Collections.SortedSet.#ctor(System.Collections.ICollection,System.Collections.IComparer)">
            <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
            <param name="comparer">The <see cref="T:System.Collections.IComparer"/> to use for sorting.</param>
        </member>
        <member name="T:DotSpatial.Topology.Utilities.UniqueCoordinateArrayFilter">
            <summary>
            A <c>CoordinateFilter</c> that builds a set of <c>Coordinate</c>s.
            The set of coordinates contains no duplicate points.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Utilities.UniqueCoordinateArrayFilter.Filter(DotSpatial.Topology.Coordinate)">
             <summary>
            
             </summary>
             <param name="coord"></param>
        </member>
        <member name="P:DotSpatial.Topology.Utilities.UniqueCoordinateArrayFilter.Coordinates">
            <summary>
            Returns the gathered <c>Coordinate</c>s.
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Voronoi.Fortune">
            <summary>
             Contains static methods and parameters that organize the major elements of
             applying the Fortune linesweep methods
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.Fortune.VVUnkown">
            <summary>
             The default definition of a coordinate that uses double.NaN to clarify
             that no value has yet been assigned to this vector.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.Fortune.VVInfinite">
            <summary>
            Represents an infinite vector location
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.Fortune.DoCleanup">
            <summary>
            Boolean, true if the cleanup method should be called.  This is unnecessary, for
            the mapwindow implementation and will in fact cause the implementation to break
            because infinities and other bad values start showing up.
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Fortune.ComputeVoronoiGraph(System.Double[],System.Double,System.Boolean)">
            <summary>
            Calculates the voronoi graph, but specifies a tolerance below which values should be considered equal.
            </summary>
            <param name="vertices">The original points to use during the calculation</param>
            <param name="tolerance">A double value that controls the test for equality</param>
            <param name="cleanup">This for Ben's code and should be passed as true if cleanup should be done.</param>
            <returns>A VoronoiGraph structure containing the output geometries</returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Fortune.ComputeVoronoiGraph(System.Double[])">
            <summary>
            Calculates a list of edges and junction vertices by using the specified points.
            This defaults to not using any tolerance for determining if points are equal,
            and will not use the cleanup algorithm, which breaks the HandleBoundaries
            method in the Voronoi class.
            </summary>
            <param name="vertices">The original points to use during the calculation</param>
            <returns>A VoronoiGraph structure containing the output geometries</returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Fortune.FilterVg(DotSpatial.Topology.Voronoi.VoronoiGraph,System.Double)">
            <summary>
            Applies an optional cleanup method needed by Benjamine Ditter for
            laser data calculations.  This is not used by the MapWindow calculations
            </summary>
            <param name="vg">The output voronoi graph created in the Compute Voronoi Graph section</param>
            <param name="minLeftRightDist">A minimum left to right distance</param>
            <returns>The Voronoi Graph after it has been filtered.</returns>
        </member>
        <member name="T:DotSpatial.Topology.Voronoi.HashSet`1">
            <summary>
            The HashSet is a dictionary that provides the optimized
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.HashSet`1.Add(`0)">
            <summary>
             Adds the specified object to the hash set collection
            </summary>
            <param name="item">The object to add</param>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.HashSet`1.GetEnumerator">
            <summary>
            Gets the enumerator of the items in the set
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.HashSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the members of this hash set to the specified array, starting at the specified index
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.HashSet`1.Clear">
            <summary>
            Clears the entire set
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.HashSet`1.Contains(`0)">
            <summary>
            Gets a boolean indicating if the specified item is in the set
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.HashSet`1.Remove(`0)">
            <summary>
            Removes the specified item
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:DotSpatial.Topology.Voronoi.HashSet`1.Count">
            <summary>
            Gets the integer count of members in this set
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Voronoi.HashSet`1.IsReadOnly">
            <summary>
            These sets can be modified
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Voronoi.MathTools">
            <summary>
            Contains several helpful tools that allow the voronoi polygon creation to work
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.MathTools.Dist(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculates the euclidean distance
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.MathTools.Ccw(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
             <summary>
            
             </summary>
             <param name="p0X"></param>
             <param name="p0Y"></param>
             <param name="p1X"></param>
             <param name="p1Y"></param>
             <param name="p2X"></param>
             <param name="p2Y"></param>
             <param name="plusOneOnZeroDegrees"></param>
             <returns></returns>
        </member>
        <member name="T:DotSpatial.Topology.Voronoi.Vector2">
            <summary>
            A vector class, implementing all interesting features of vectors
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.Vector2.Tolerance">
            <summary>
            This double controls the test for equality so that values that
            are smaller than this value will be considered equal.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.Vector2.X">
            <summary>
            The x coordinate
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.Vector2.Y">
            <summary>
            The y coordinate
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.#ctor(System.Double[],System.Int32)">
            <summary>
            Creates a vector by reading a long array of vertices and assigning the vector based on that
            </summary>
            <param name="xyvertices"></param>
            <param name="offset"></param>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.#ctor(System.Double[])">
            <summary>
            Build a new vector
            </summary>
            <param name="x">The elements of the vector</param>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.ToCoordinate">
            <summary>
            Transforms the vector into a coordinate with an x and y value
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.ContainsNan">
            <summary>
            True if any of the double values is not a number
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.ToString">
            <summary>
            Convert the vector into a reconstructable string representation
            </summary>
            <returns>A string from which the vector can be rebuilt</returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.Equals(System.Object)">
            <summary>
            Compares this vector with another one
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.Distance(DotSpatial.Topology.Voronoi.Vector2)">
            <summary>
            Calculates the euclidean distance from this cell to another
            </summary>
            <returns>Vector2 stuff</returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.GetHashCode">
            <summary>
            Retrieves a hashcode that is dependent on the elements
            </summary>
            <returns>The hashcode</returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.op_Multiply(DotSpatial.Topology.Voronoi.Vector2,DotSpatial.Topology.Voronoi.Vector2)">
            <summary>
            Get the scalar product of two vectors
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.op_Equality(DotSpatial.Topology.Voronoi.Vector2,DotSpatial.Topology.Voronoi.Vector2)">
            <summary>
            Overrides equality to use the tolerant equality
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.op_Inequality(DotSpatial.Topology.Voronoi.Vector2,DotSpatial.Topology.Voronoi.Vector2)">
            <summary>
            Overrides equality to use the tolerant equality test
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.op_Addition(DotSpatial.Topology.Voronoi.Vector2,DotSpatial.Topology.Voronoi.Vector2)">
            <summary>
            Calculates the vector sum of these two vectors
            </summary>
            <param name="a">One vector to add</param>
            <param name="b">The second vector to add</param>
            <returns>The vector sum of the specified vectors</returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.op_Subtraction(DotSpatial.Topology.Voronoi.Vector2,DotSpatial.Topology.Voronoi.Vector2)">
            <summary>
            Calculates the vector sum of these two vectors
            </summary>
            <param name="a">One vector to add</param>
            <param name="b">The second vector to add</param>
            <returns>The vector sum of the specified vectors</returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.op_Multiply(DotSpatial.Topology.Voronoi.Vector2,System.Double)">
            <summary>
            Multiplies the vector by a scalar
            </summary>
            <param name="a">The vector to modify</param>
            <param name="scale">The double scale to multiply</param>
            <returns>A new Vector2</returns>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.Vector2.op_Multiply(System.Double,DotSpatial.Topology.Voronoi.Vector2)">
            <summary>
            Multiplies the vector by a scalar.
            </summary>
            <param name="scale">The double scale to multiply.</param>
            <param name="a">The vector to modify.</param>
            <returns>A new Vector2.</returns>
        </member>
        <member name="P:DotSpatial.Topology.Voronoi.Vector2.SquaredLength">
            <summary>
            Gets the dot product of this vector with itself
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.VNode.ProcessDataEvent(DotSpatial.Topology.Voronoi.VDataEvent,DotSpatial.Topology.Voronoi.VNode,DotSpatial.Topology.Voronoi.VoronoiGraph,System.Double,DotSpatial.Topology.Voronoi.VDataNode[]@)">
            <summary>
            Will return the new root (unchanged except in start-up)
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Voronoi.VoronoiEdge">
            <summary>
            The Voronoi Edge represents a bisector between two of the original datapoints.  The
            LeftData and RightData represent those original points.  VVertexA and VVertexB represent
            the endpoints of the segment created using those original points.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.VoronoiEdge.Done">
            <summary>
            An internal boolean for tracking some cleanup operations
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.VoronoiEdge.LeftData">
            <summary>
            The other original point in the dataset
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.VoronoiEdge.RightData">
            <summary>
             One of the original points in the dataset
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.VoronoiEdge.VVertexA">
            <summary>
             One of the endpoints for the segment that defines this edge
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.VoronoiEdge.VVertexB">
            <summary>
            THe other endpoint for the segment that defines this edge
            </summary>
        </member>
        <member name="M:DotSpatial.Topology.Voronoi.VoronoiEdge.AddVertex(DotSpatial.Topology.Voronoi.Vector2)">
            <summary>
             Adds VertexA and VertexB sequentially, so that if VertexA is defined,
             then VertexB will become the specified vertex.
            </summary>
            <param name="v"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="P:DotSpatial.Topology.Voronoi.VoronoiEdge.IsInfinite">
            <summary>
            Boolean, true if both the VertexA and VertexB are infinite vectors
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Voronoi.VoronoiEdge.IsPartlyInfinite">
            <summary>
            Indicates that one of the voronoi vertices for this edge is known, but no
            intersection is found to bound the other edge, and it should extend to the
            bounding box.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Voronoi.VoronoiEdge.FixedPoint">
            <summary>
            In the case where the line is infinite, this will return the
            center between the left and right data points.
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Voronoi.VoronoiEdge.DirectionVector">
            <summary>
            Calculates a vector direction that indicates the direction of this
            knwon
            </summary>
        </member>
        <member name="P:DotSpatial.Topology.Voronoi.VoronoiEdge.Length">
            <summary>
            Calculates the length of this edge
            </summary>
        </member>
        <member name="T:DotSpatial.Topology.Voronoi.VoronoiGraph">
            <summary>
            Voronoi Graph
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.VoronoiGraph.Edges">
            <summary>
            The collection of VoronoiEdges.  The Left and Right points are from the
            original set of points that are bisected by the edge.  The A and B
            Vectors are the endpoints of the edge itself.
            </summary>
        </member>
        <member name="F:DotSpatial.Topology.Voronoi.VoronoiGraph.Vertices">
            <summary>
            The vertices that join the voronoi polygon edges (not the original points)
            </summary>
        </member>
    </members>
</doc>
