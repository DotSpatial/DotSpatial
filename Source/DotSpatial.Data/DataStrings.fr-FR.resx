<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArgumentCannotBeNegative_S" xml:space="preserve">
    <value>L'argument %S ne peut être négatif.</value>
  </data>
  <data name="ArgumentNull_S" xml:space="preserve">
    <value>L'argument {0} est null. Tester le cas de nullité avant de faire appel à la procédure.</value>
  </data>
  <data name="ArgumentOfWrongType_S1_S2" xml:space="preserve">
    <value>L'argument %S1 est incorrect pour %S2.</value>
  </data>
  <data name="Argument_Null_S" xml:space="preserve">
    <value>L'argument {0} ne peut être null.</value>
  </data>
  <data name="CalculatingStatistics" xml:space="preserve">
    <value>Calcul des Statistiques</value>
  </data>
  <data name="CannotCopyToSelf_S" xml:space="preserve">
    <value>Le fichier  %S ne peut être copié sur lui-même.</value>
  </data>
  <data name="CopyingValues" xml:space="preserve">
    <value>Copie des valeurs</value>
  </data>
  <data name="CurrentElementNotSpecified" xml:space="preserve">
    <value>L'élément courant n'est pas défini. Avant de tenter de lire l'élément, lui afecter d'abord une valeur.</value>
  </data>
  <data name="EndOfFile" xml:space="preserve">
    <value>Ne peut lire le fichier au-delà de sa fin.</value>
  </data>
  <data name="FeatureTypeMismatch" xml:space="preserve">
    <value>Le type de donnée de l'entité en ajout ne correspond pas au type de donnée du Featureset.</value>
  </data>
  <data name="FeaturetypeUnspecified" xml:space="preserve">
    <value>Le type de donnée n'a pas été indiqué.</value>
  </data>
  <data name="File0ExistsOverwrite" xml:space="preserve">
    <value>Le fichier %S existe déjà. Voulez-vous l'écraser?</value>
  </data>
  <data name="File0NotFound" xml:space="preserve">
    <value>Le fichier {0} n'a pas été trouvé.</value>
  </data>
  <data name="File0NotShapeType1" xml:space="preserve">
    <value>Le fichier  {0}  contient un type de donnée différent de  {1}.</value>
  </data>
  <data name="FileTypeNotSupported" xml:space="preserve">
    <value>Le type de fichier indiqué n'est pas supporté.</value>
  </data>
  <data name="HfaEnumerationNotFound" xml:space="preserve">
    <value>Tentative d'affectation d'une valeur inconnue  '{0}'  à un champ énumération .</value>
  </data>
  <data name="HfaFieldTypeException" xml:space="preserve">
    <value>Le caractère '{0}' n'est pas un type de champ connu: 124cCesStlLfdmMbox"</value>
  </data>
  <data name="HfaInvalidCountException" xml:space="preserve">
    <value>Le nombre de lignes et de colonnes doivent être supérieur à 0, mais l'ebtête de l'élément a renvoyé  {0} lignes et {1} colonnes.</value>
  </data>
  <data name="HfaNotCompressedException" xml:space="preserve">
    <value>Vous devez d'abord compresser les données avant d'accéder à cette valeur.</value>
  </data>
  <data name="HfaPointerInsertNotSupportedException" xml:space="preserve">
    <value>L'Insertion à travers SetInstValue() n'est pas encore supportée pour les pointeurs.</value>
  </data>
  <data name="IndexingErrorIn_S" xml:space="preserve">
    <value>Erreur lors de l'indexation de %S</value>
  </data>
  <data name="NotImplemented" xml:space="preserve">
    <value>Ceci n'est pas encore implémenté.</value>
  </data>
  <data name="NumberException_TooLarge_S" xml:space="preserve">
    <value>La valeur {0} est trop grande pour un encodage en caractère ASCII 18.</value>
  </data>
  <data name="NumberException_TooSmall_S" xml:space="preserve">
    <value>La valeur {0} est trop petite pour un encodage en caractère ASCII 18.</value>
  </data>
  <data name="ParseFailed_S" xml:space="preserve">
    <value>La valeur saisie ne peut être convertie en %S. S'assurer que la valeur se trouve dans l'intervalle requis.</value>
  </data>
  <data name="PngInsuficientLengthException" xml:space="preserve">
    <value>La longueur souhaitée de  {0} est trop grande. La longueur totale est {1} et le décalage {2}.</value>
  </data>
  <data name="PngInvalidSignatureException" xml:space="preserve">
    <value>Les 8 premiers octects du fichier ne coreespondent pas à une signature png.</value>
  </data>
  <data name="PyramidByteMismatchException" xml:space="preserve">
    <value>Le nombre d'octects devrait être  4 * lignes * cols depuis que seul le format ARGB est supporté.</value>
  </data>
  <data name="PyramidHeaderException" xml:space="preserve">
    <value>L'entête n'a pas été définie pour cette échelle d'image.</value>
  </data>
  <data name="PyramidOutOfBoundsException" xml:space="preserve">
    <value>Les lignes ou colonnes devraient s'étendre au-delà du nombre de lignes ou de colonnes pour l'échelle indiquée.</value>
  </data>
  <data name="RasterRequiresCast" xml:space="preserve">
    <value>Pour exploiter un outil autre que raster memoire, il faudrait d'abord convertir le raster dans le bon format de données.</value>
  </data>
  <data name="RastersNeedSameCellSize" xml:space="preserve">
    <value>Les rasters doivent avoir des pixels équitables pour faire appel à cette procédure.</value>
  </data>
  <data name="RasterTooLarge" xml:space="preserve">
    <value>Le raster est trop grand pour tenir en mémoire.</value>
  </data>
  <data name="ReadingValuesFrom_S" xml:space="preserve">
    <value>Lecture de valeurs à partir de %S</value>
  </data>
  <data name="WritingValues_S" xml:space="preserve">
    <value>Ecriture des valeurs dans %S</value>
  </data>
  <data name="Shape_WrongFeatureType" xml:space="preserve">
    <value>{0} suposé être  {1} , a eu  {2}.</value>
    <comment>{0} object that was checked, {1} expected FeatureType, {2} FeatureType that was found</comment>
  </data>
  <data name="Shape_ZeroPointsError" xml:space="preserve">
    <value>L'entité doit avoir aumoins 1 point.</value>
  </data>
  <data name="FeatureSet_ExportShapefilePackage_NotImplemented" xml:space="preserve">
    <value>La fonctionnalité ExportShapefilePackage n'est pas encore implémentée pour ce type de jeu de données.</value>
  </data>
  <data name="File0ExistsOverwritingNotAllowed" xml:space="preserve">
    <value>Le fichier {0} exite déjà et ne devrait pas être écrasé.</value>
  </data>
  <data name="ShapeTypeNotYetSupported" xml:space="preserve">
    <value>Cette forme géométrique n'est pas encore supportée.</value>
  </data>
  <data name="FileExtension0NotSupportedByShapefileDataProvider" xml:space="preserve">
    <value>L'extension {0} n'est pas supportée par le Shapefile data provider.</value>
  </data>
  <data name="FileNameShouldNotBeNull" xml:space="preserve">
    <value>Le nom de fichier ne devrait pas être vide.</value>
  </data>
  <data name="ReadingExtentFromStringFailedOnTerm" xml:space="preserve">
    <value>La tentative de récupération de l'extent a échoué en lisant le {0} term.</value>
  </data>
  <data name="ShapeType0NotSupported" xml:space="preserve">
    <value>La forme géométrique {0}  n'est pas supportée.</value>
  </data>
</root>